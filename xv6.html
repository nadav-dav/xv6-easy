<html>
<head>
    <title>XV6 github.com/nadav-dav</title>
    <style>
        body {
            font-family: monospace;
            white-space: pre;
            font-size: 1.2em;
            background: black;
            color: #ccc;
        }

        .content {
            width: 800px;
            margin: 0 auto;
            background: #333;
            padding: 10px;
        }

        .lines {

        }

        a {
            color: #eee;
        }

        a.define-ref {
            color: #4aa7db;
        }

        a.str-ref {
            color: #ffc425;
        }

        a.func-ref {
            color: #00b159;
        }

        a.<a class='str-ref' href='#Sfile'>file</a>-ref {
            color: #ffc425;
        }

        span.reserved {
            color: #4aa7db;
            pointer-events: none;
        }

        span.hash {
            color: #ee4035;
        }

        span.comment {
            color: #777 !important;
        }

        span.comment a {
            color: #777 !important;
        }
    </style>
</head>
<body>
<div class='content'>
    


<hr/><a name='Itypes.h'>###### <a class='page-ref' href='#Itypes.h'>types.h</a> ########</a>

<span class='reserved'>typedef</span> unsigned int   uint;
<span class='reserved'>typedef</span> unsigned short ushort;
<span class='reserved'>typedef</span> unsigned char  uchar;
<span class='reserved'>typedef</span> uint pde_t;



<hr/><a name='Iparam.h'>###### <a class='page-ref' href='#Iparam.h'>param.h</a> ########</a>

<a name='ANPROC'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANPROC'>NPROC</a>        64  <span class='comment'>// maximum number of processes</span><a name='AKSTACKSIZE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKSTACKSIZE'>KSTACKSIZE</a> 4096  <span class='comment'>// size of per-process kernel stack</span><a name='ANCPU'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANCPU'>NCPU</a>          8  <span class='comment'>// maximum number of CPUs</span><a name='ANOFILE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANOFILE'>NOFILE</a>       16  <span class='comment'>// open files per process</span><a name='ANFILE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANFILE'>NFILE</a>       100  <span class='comment'>// open files per system</span><a name='ANBUF'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANBUF'>NBUF</a>         10  <span class='comment'>// size of disk block cache</span><a name='ANINODE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANINODE'>NINODE</a>       50  <span class='comment'>// maximum number of active i-nodes</span><a name='ANDEV'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANDEV'>NDEV</a>         10  <span class='comment'>// maximum major device number</span><a name='AROOTDEV'></a><span class='hash'>#define</span> <a class='define-ref' href='#AROOTDEV'>ROOTDEV</a>       1  <span class='comment'>// device number of <a class='str-ref' href='#Sfile'>file</a> system root disk</span><a name='AMAXARG'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMAXARG'>MAXARG</a>       32  <span class='comment'>// max <a class='func-ref' href='#Fexec'>exec</a> arguments</span><a name='ALOGSIZE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ALOGSIZE'>LOGSIZE</a>      10  <span class='comment'>// max data sectors in on-disk <a class='str-ref' href='#Slog'>log</a></span>



<hr/><a name='Imemlayout.h'>###### <a class='page-ref' href='#Imemlayout.h'>memlayout.h</a> ########</a>

<span class='comment'>// Memory layout</span>
<a name='AEXTMEM'></a><span class='hash'>#define</span> <a class='define-ref' href='#AEXTMEM'>EXTMEM</a>  0x100000            <span class='comment'>// Start of extended memory</span><a name='APHYSTOP'></a><span class='hash'>#define</span> <a class='define-ref' href='#APHYSTOP'>PHYSTOP</a> 0xE000000           <span class='comment'>// Top physical memory</span><a name='ADEVSPACE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ADEVSPACE'>DEVSPACE</a> 0xFE000000         <span class='comment'>// Other devices are at high addresses</span>
<span class='comment'>// Key addresses <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> address space layout (see kmap in <a class='page-ref' href='#Ivm.c'>vm.c</a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> layout)</span><a name='AKERNBASE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKERNBASE'>KERNBASE</a> 0x80000000         <span class='comment'>// First kernel virtual address</span><a name='AKERNLINK'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKERNLINK'>KERNLINK</a> (<a class='define-ref' href='#AKERNBASE'>KERNBASE</a>+<a class='define-ref' href='#AEXTMEM'>EXTMEM</a>)  <span class='comment'>// Address where kernel is linked</span>
#ifndef __ASSEMBLER__

<span class='reserved'>static</span> inline uint v2p(void *a) { <span class='reserved'>return</span> ((uint) (a))  - <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>; }
<span class='reserved'>static</span> inline void *p2v(uint a) { <span class='reserved'>return</span> (void *) ((a) + <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>); }

#endif

<a name='AV2P'></a><span class='hash'>#define</span> <a class='define-ref' href='#AV2P'>V2P</a>(a) (((uint) (a)) - <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>)
<a name='AP2V'></a><span class='hash'>#define</span> <a class='define-ref' href='#AP2V'>P2V</a>(a) (((void *) (a)) + <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>)

<a name='AV2P_WO'></a><span class='hash'>#define</span> <a class='define-ref' href='#AV2P_WO'>V2P_WO</a>(x) ((x) - <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>)    <span class='comment'>// same as <a class='define-ref' href='#AV2P'>V2P</a>, but without casts</span><a name='AP2V_WO'></a><span class='hash'>#define</span> <a class='define-ref' href='#AP2V_WO'>P2V_WO</a>(x) ((x) + <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>)    <span class='comment'>// same as <a class='define-ref' href='#AV2P'>V2P</a>, but without casts</span>


<hr/><a name='Idefs.h'>###### <a class='page-ref' href='#Idefs.h'>defs.h</a> ########</a>

<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Sstat'>stat</a>;
<span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a>;

<span class='comment'>// <a class='page-ref' href='#Ibio.c'>bio.c</a></span>void            <a class='func-ref' href='#Fbinit'>binit</a>(void);
<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*     <a class='func-ref' href='#Fbread'>bread</a>(uint, uint);
void            <a class='func-ref' href='#Fbrelse'>brelse</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*);
void            <a class='func-ref' href='#Fbwrite'>bwrite</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*);

<span class='comment'>// <a class='page-ref' href='#Iconsole.c'>console.c</a></span>void            <a class='func-ref' href='#Fconsoleinit'>consoleinit</a>(void);
void            <a class='func-ref' href='#Fcprintf'>cprintf</a>(char*, ...);
void            <a class='func-ref' href='#Fconsoleintr'>consoleintr</a>(int(*)(void));
void            <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>(char*) <a class='func-ref' href='#F__attribute__'>__attribute__</a>((noreturn));

<span class='comment'>// <a class='page-ref' href='#Iexec.c'><a class='func-ref' href='#Fexec'>exec</a>.c</a></span>int             <a class='func-ref' href='#Fexec'>exec</a>(char*, char**);

<span class='comment'>// <a class='page-ref' href='#Ifile.c'><a class='str-ref' href='#Sfile'>file</a>.c</a></span><span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*    <a class='func-ref' href='#Ffilealloc'>filealloc</a>(void);
void            <a class='func-ref' href='#Ffileclose'>fileclose</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*    <a class='func-ref' href='#Ffiledup'>filedup</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*);
void            <a class='func-ref' href='#Ffileinit'>fileinit</a>(void);
int             <a class='func-ref' href='#Ffileread'>fileread</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*, char*, int n);
int             <a class='func-ref' href='#Ffilestat'>filestat</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*, <span class='reserved'>struct</span> <a class='str-ref' href='#Sstat'>stat</a>*);
int             <a class='func-ref' href='#Ffilewrite'>filewrite</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*, char*, int n);

<span class='comment'>// <a class='page-ref' href='#Ifs.c'>fs.c</a></span>void            <a class='func-ref' href='#Freadsb'>readsb</a>(int dev, <span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a> *sb);
int             <a class='func-ref' href='#Fdirlink'>dirlink</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, char*, uint);
<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*   <a class='func-ref' href='#Fdirlookup'>dirlookup</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, char*, uint*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*   <a class='func-ref' href='#Fialloc'>ialloc</a>(uint, short);
<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*   <a class='func-ref' href='#Fidup'>idup</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*);
void            <a class='func-ref' href='#Fiinit'>iinit</a>(void);
void            <a class='func-ref' href='#Filock'>ilock</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*);
void            <a class='func-ref' href='#Fiput'>iput</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*);
void            <a class='func-ref' href='#Fiunlock'>iunlock</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*);
void            <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*);
void            <a class='func-ref' href='#Fiupdate'>iupdate</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*);
int             <a class='func-ref' href='#Fnamecmp'>namecmp</a>(const char*, const char*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*   <a class='func-ref' href='#Fnamei'>namei</a>(char*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*   <a class='func-ref' href='#Fnameiparent'>nameiparent</a>(char*, char*);
int             <a class='func-ref' href='#Freadi'>readi</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, char*, uint, uint);
void            <a class='func-ref' href='#Fstati'>stati</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, <span class='reserved'>struct</span> <a class='str-ref' href='#Sstat'>stat</a>*);
int             <a class='func-ref' href='#Fwritei'>writei</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, char*, uint, uint);

<span class='comment'>// <a class='page-ref' href='#Iide.c'>ide.c</a></span>void            <a class='func-ref' href='#Fideinit'>ideinit</a>(void);
void            <a class='func-ref' href='#Fideintr'>ideintr</a>(void);
void            <a class='func-ref' href='#Fiderw'>iderw</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*);

<span class='comment'>// <a class='page-ref' href='#Iioapic.c'><a class='str-ref' href='#Sioapic'>ioapic</a>.c</a></span>void            <a class='func-ref' href='#Fioapicenable'>ioapicenable</a>(int irq, int <a class='str-ref' href='#Scpu'>cpu</a>);
<span class='reserved'>extern</span> uchar    ioapicid;
void            <a class='func-ref' href='#Fioapicinit'>ioapicinit</a>(void);

<span class='comment'>// <a class='page-ref' href='#Ikalloc.c'><a class='func-ref' href='#Fkalloc'>kalloc</a>.c</a></span>char*           <a class='func-ref' href='#Fkalloc'>kalloc</a>(void);
void            <a class='func-ref' href='#Fkfree'>kfree</a>(char*);
void            <a class='func-ref' href='#Fkinit1'>kinit1</a>(void*, void*);
void            <a class='func-ref' href='#Fkinit2'>kinit2</a>(void*, void*);

<span class='comment'>// <a class='page-ref' href='#Ikbd.c'>kbd.c</a></span>void            <a class='func-ref' href='#Fkbdintr'>kbdintr</a>(void);

<span class='comment'>// <a class='page-ref' href='#Ilapic.c'>lapic.c</a></span>int             <a class='func-ref' href='#Fcpunum'>cpunum</a>(void);
<span class='reserved'>extern</span> volatile uint*    lapic;
void            <a class='func-ref' href='#Flapiceoi'>lapiceoi</a>(void);
void            <a class='func-ref' href='#Flapicinit'>lapicinit</a>(void);
void            <a class='func-ref' href='#Flapicstartap'>lapicstartap</a>(uchar, uint);
void            <a class='func-ref' href='#Fmicrodelay'>microdelay</a>(int);

<span class='comment'>// <a class='page-ref' href='#Ilog.c'><a class='str-ref' href='#Slog'>log</a>.c</a></span>void            <a class='func-ref' href='#Finitlog'>initlog</a>(void);
void            <a class='func-ref' href='#Flog_write'>log_write</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*);
void            <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();
void            <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();

<span class='comment'>// <a class='page-ref' href='#Imp.c'><a class='str-ref' href='#Smp'>mp</a>.c</a></span><span class='reserved'>extern</span> int      ismp;
int             <a class='func-ref' href='#Fmpbcpu'>mpbcpu</a>(void);
void            <a class='func-ref' href='#Fmpinit'>mpinit</a>(void);
void            mpstartthem(void);

<span class='comment'>// <a class='page-ref' href='#Ipicirq.c'>picirq.c</a></span>void            <a class='func-ref' href='#Fpicenable'>picenable</a>(int);
void            <a class='func-ref' href='#Fpicinit'>picinit</a>(void);

<span class='comment'>// <a class='page-ref' href='#Ipipe.c'><a class='str-ref' href='#Spipe'>pipe</a>.c</a></span>int             <a class='func-ref' href='#Fpipealloc'>pipealloc</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>**, <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>**);
void            <a class='func-ref' href='#Fpipeclose'>pipeclose</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a>*, int);
int             <a class='func-ref' href='#Fpiperead'>piperead</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a>*, char*, int);
int             <a class='func-ref' href='#Fpipewrite'>pipewrite</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a>*, char*, int);

<span class='comment'>//PAGEBREAK: 16</span><span class='comment'>// <a class='page-ref' href='#Iproc.c'><a class='str-ref' href='#Sproc'>proc</a>.c</a></span><span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a>*    copyproc(<span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a>*);
void            <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>(void);
int             <a class='func-ref' href='#Ffork'>fork</a>(void);
int             <a class='func-ref' href='#Fgrowproc'>growproc</a>(int);
int             <a class='func-ref' href='#Fkill'>kill</a>(int);
void            <a class='func-ref' href='#Fpinit'>pinit</a>(void);
void            <a class='func-ref' href='#Fprocdump'>procdump</a>(void);
void            <a class='func-ref' href='#Fscheduler'>scheduler</a>(void) <a class='func-ref' href='#F__attribute__'>__attribute__</a>((noreturn));
void            <a class='func-ref' href='#Fsched'>sched</a>(void);
void            <a class='func-ref' href='#Fsleep'>sleep</a>(void*, <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a>*);
void            <a class='func-ref' href='#Fuserinit'>userinit</a>(void);
int             <a class='func-ref' href='#Fwait'>wait</a>(void);
void            <a class='func-ref' href='#Fwakeup'>wakeup</a>(void*);
void            <a class='func-ref' href='#Fyield'>yield</a>(void);

<span class='comment'>// <a class='page-ref' href='#Iswtch.S'><a class='func-ref' href='#Fswtch'>swtch</a>.S</a></span>void            <a class='func-ref' href='#Fswtch'>swtch</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a>**, <span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a>*);

<span class='comment'>// <a class='page-ref' href='#Ispinlock.c'><a class='str-ref' href='#Sspinlock'>spinlock</a>.c</a></span>void            <a class='func-ref' href='#Facquire'>acquire</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a>*);
void            <a class='func-ref' href='#Fgetcallerpcs'>getcallerpcs</a>(void*, uint*);
int             <a class='func-ref' href='#Fholding'>holding</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a>*);
void            <a class='func-ref' href='#Finitlock'>initlock</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a>*, char*);
void            <a class='func-ref' href='#Frelease'>release</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a>*);
void            <a class='func-ref' href='#Fpushcli'>pushcli</a>(void);
void            <a class='func-ref' href='#Fpopcli'>popcli</a>(void);

<span class='comment'>// <a class='page-ref' href='#Istring.c'>string.c</a></span>int             <a class='func-ref' href='#Fmemcmp'>memcmp</a>(const void*, const void*, uint);
void*           <a class='func-ref' href='#Fmemmove'>memmove</a>(void*, const void*, uint);
void*           <a class='func-ref' href='#Fmemset'>memset</a>(void*, int, uint);
char*           <a class='func-ref' href='#Fsafestrcpy'>safestrcpy</a>(char*, const char*, int);
int             <a class='func-ref' href='#Fstrlen'>strlen</a>(const char*);
int             <a class='func-ref' href='#Fstrncmp'>strncmp</a>(const char*, const char*, uint);
char*           <a class='func-ref' href='#Fstrncpy'>strncpy</a>(char*, const char*, int);

<span class='comment'>// <a class='page-ref' href='#Isyscall.c'><a class='func-ref' href='#Fsyscall'>syscall</a>.c</a></span>int             <a class='func-ref' href='#Fargint'>argint</a>(int, int*);
int             <a class='func-ref' href='#Fargptr'>argptr</a>(int, char**, int);
int             <a class='func-ref' href='#Fargstr'>argstr</a>(int, char**);
int             <a class='func-ref' href='#Ffetchint'>fetchint</a>(uint, int*);
int             <a class='func-ref' href='#Ffetchstr'>fetchstr</a>(uint, char**);
void            <a class='func-ref' href='#Fsyscall'>syscall</a>(void);

<span class='comment'>// <a class='page-ref' href='#Itimer.c'>timer.c</a></span>void            <a class='func-ref' href='#Ftimerinit'>timerinit</a>(void);

<span class='comment'>// <a class='page-ref' href='#Itrap.c'><a class='func-ref' href='#Ftrap'>trap</a>.c</a></span>void            <a class='func-ref' href='#Fidtinit'>idtinit</a>(void);
<span class='reserved'>extern</span> uint     ticks;
void            <a class='func-ref' href='#Ftvinit'>tvinit</a>(void);
<span class='reserved'>extern</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> tickslock;

<span class='comment'>// <a class='page-ref' href='#Iuart.c'>uart.c</a></span>void            <a class='func-ref' href='#Fuartinit'>uartinit</a>(void);
void            <a class='func-ref' href='#Fuartintr'>uartintr</a>(void);
void            <a class='func-ref' href='#Fuartputc'>uartputc</a>(int);

<span class='comment'>// <a class='page-ref' href='#Ivm.c'>vm.c</a></span>void            <a class='func-ref' href='#Fseginit'>seginit</a>(void);
void            <a class='func-ref' href='#Fkvmalloc'>kvmalloc</a>(void);
void            vmenable(void);
pde_t*          <a class='func-ref' href='#Fsetupkvm'>setupkvm</a>(void);
char*           <a class='func-ref' href='#Fuva2ka'>uva2ka</a>(pde_t*, char*);
int             <a class='func-ref' href='#Fallocuvm'>allocuvm</a>(pde_t*, uint, uint);
int             <a class='func-ref' href='#Fdeallocuvm'>deallocuvm</a>(pde_t*, uint, uint);
void            <a class='func-ref' href='#Ffreevm'>freevm</a>(pde_t*);
void            <a class='func-ref' href='#Finituvm'>inituvm</a>(pde_t*, char*, uint);
int             <a class='func-ref' href='#Floaduvm'>loaduvm</a>(pde_t*, char*, <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, uint, uint);
pde_t*          <a class='func-ref' href='#Fcopyuvm'>copyuvm</a>(pde_t*, uint);
void            <a class='func-ref' href='#Fswitchuvm'>switchuvm</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a>*);
void            <a class='func-ref' href='#Fswitchkvm'>switchkvm</a>(void);
int             <a class='func-ref' href='#Fcopyout'>copyout</a>(pde_t*, uint, void*, uint);
void            <a class='func-ref' href='#Fclearpteu'>clearpteu</a>(pde_t *pgdir, char *uva);

<span class='comment'>// number of elements in fixed-size array</span><a name='ANELEM'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANELEM'>NELEM</a>(x) (sizeof(x)/sizeof((x)[0]))



<hr/><a name='Ix86.h'>###### <a class='page-ref' href='#Ix86.h'>x86.h</a> ########</a>

<span class='comment'>// Routines to let <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a> code use special x86 instructions.</span>
<span class='reserved'>static</span> inline uchar
<a name='Finb'><a class='func-ref' href='#Finb'>inb</a></a>(ushort port)
{
  uchar data;

  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
  <span class='reserved'>return</span> data;
}

<span class='reserved'>static</span> inline void
<a name='Finsl'><a class='func-ref' href='#Finsl'>insl</a></a>(int port, void *addr, int cnt)
{
  asm volatile("cld; rep <a class='func-ref' href='#Finsl'>insl</a>" :
               "=D" (addr), "=c" (cnt) :
               "d" (port), "0" (addr), "1" (cnt) :
               "memory", "cc");
}

<span class='reserved'>static</span> inline void
<a name='Foutb'><a class='func-ref' href='#Foutb'>outb</a></a>(ushort port, uchar data)
{
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
}

<span class='reserved'>static</span> inline void
<a name='Foutw'><a class='func-ref' href='#Foutw'>outw</a></a>(ushort port, ushort data)
{
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
}

<span class='reserved'>static</span> inline void
<a name='Foutsl'><a class='func-ref' href='#Foutsl'>outsl</a></a>(int port, const void *addr, int cnt)
{
  asm volatile("cld; rep <a class='func-ref' href='#Foutsl'>outsl</a>" :
               "=S" (addr), "=c" (cnt) :
               "d" (port), "0" (addr), "1" (cnt) :
               "cc");
}

<span class='reserved'>static</span> inline void
<a name='Fstosb'><a class='func-ref' href='#Fstosb'>stosb</a></a>(void *addr, int data, int cnt)
{
  asm volatile("cld; rep <a class='func-ref' href='#Fstosb'>stosb</a>" :
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}

<span class='reserved'>static</span> inline void
<a name='Fstosl'><a class='func-ref' href='#Fstosl'>stosl</a></a>(void *addr, int data, int cnt)
{
  asm volatile("cld; rep <a class='func-ref' href='#Fstosl'>stosl</a>" :
               "=D" (addr), "=c" (cnt) :
               "0" (addr), "1" (cnt), "a" (data) :
               "memory", "cc");
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Ssegdesc'>segdesc</a>;

<span class='reserved'>static</span> inline void
<a name='Flgdt'><a class='func-ref' href='#Flgdt'>lgdt</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Ssegdesc'>segdesc</a> *p, int size)
{
  volatile ushort pd[3];

  pd[0] = size-1;
  pd[1] = (uint)p;
  pd[2] = (uint)p &gt;&gt; 16;

  asm volatile("<a class='func-ref' href='#Flgdt'>lgdt</a> (%0)" : : "r" (pd));
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Sgatedesc'>gatedesc</a>;

<span class='reserved'>static</span> inline void
<a name='Flidt'><a class='func-ref' href='#Flidt'>lidt</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sgatedesc'>gatedesc</a> *p, int size)
{
  volatile ushort pd[3];

  pd[0] = size-1;
  pd[1] = (uint)p;
  pd[2] = (uint)p &gt;&gt; 16;

  asm volatile("<a class='func-ref' href='#Flidt'>lidt</a> (%0)" : : "r" (pd));
}

<span class='reserved'>static</span> inline void
<a name='Fltr'><a class='func-ref' href='#Fltr'>ltr</a></a>(ushort sel)
{
  asm volatile("<a class='func-ref' href='#Fltr'>ltr</a> %0" : : "r" (sel));
}

<span class='reserved'>static</span> inline uint
<a name='Freadeflags'><a class='func-ref' href='#Freadeflags'>readeflags</a></a>(void)
{
  uint eflags;
  asm volatile("pushfl; popl %0" : "=r" (eflags));
  <span class='reserved'>return</span> eflags;
}

<span class='reserved'>static</span> inline void
<a name='Floadgs'><a class='func-ref' href='#Floadgs'>loadgs</a></a>(ushort v)
{
  asm volatile("movw %0, %%gs" : : "r" (v));
}

<span class='reserved'>static</span> inline void
<a name='Fcli'><a class='func-ref' href='#Fcli'>cli</a></a>(void)
{
  asm volatile("<a class='func-ref' href='#Fcli'>cli</a>");
}

<span class='reserved'>static</span> inline void
<a name='Fsti'><a class='func-ref' href='#Fsti'>sti</a></a>(void)
{
  asm volatile("<a class='func-ref' href='#Fsti'>sti</a>");
}

<span class='reserved'>static</span> inline uint
<a name='Fxchg'><a class='func-ref' href='#Fxchg'>xchg</a></a>(volatile uint *addr, uint newval)
{
  uint result;
  
  <span class='comment'>// The + in "+m" denotes a read-modify-write operand.</span>  asm volatile("lock; xchgl %0, %1" :
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  <span class='reserved'>return</span> result;
}

<span class='reserved'>static</span> inline uint
<a name='Frcr2'><a class='func-ref' href='#Frcr2'>rcr2</a></a>(void)
{
  uint val;
  asm volatile("movl %%cr2,%0" : "=r" (val));
  <span class='reserved'>return</span> val;
}

<span class='reserved'>static</span> inline void
<a name='Flcr3'><a class='func-ref' href='#Flcr3'>lcr3</a></a>(uint val) 
{
  asm volatile("movl %0,%%cr3" : : "r" (val));
}

<span class='comment'>//PAGEBREAK: 36</span><span class='comment'>// Layout of the <a class='func-ref' href='#Ftrap'>trap</a> frame built on the stack by the</span><span class='comment'>// hardware and by <a class='page-ref' href='#Itrapasm.S'>trapasm.S</a>, and passed to <a class='func-ref' href='#Ftrap'>trap</a>().</span><a name='Strapframe'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Strapframe'>trapframe</a> {
  <span class='comment'>// registers as pushed by pusha</span>  uint edi;
  uint esi;
  uint ebp;
  uint oesp;      <span class='comment'>// useless & ignored</span>  uint ebx;
  uint edx;
  uint ecx;
  uint eax;

  <span class='comment'>// rest of <a class='func-ref' href='#Ftrap'>trap</a> frame</span>  ushort gs;
  ushort padding1;
  ushort fs;
  ushort padding2;
  ushort es;
  ushort padding3;
  ushort ds;
  ushort padding4;
  uint trapno;

  <span class='comment'>// below here defined by x86 hardware</span>  uint err;
  uint eip;
  ushort cs;
  ushort padding5;
  uint eflags;

  <span class='comment'>// below here only when crossing rings, such as from user to kernel</span>  uint esp;
  ushort ss;
  ushort padding6;
};



<hr/><a name='Iasm.h'>###### <a class='page-ref' href='#Iasm.h'>asm.h</a> ########</a>

<span class='comment'>//</span><span class='comment'>// assembler macros to <a class='func-ref' href='#Fcreate'>create</a> x86 segments</span><span class='comment'>//</span>
<a name='ASEG_NULLASM'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_NULLASM'>SEG_NULLASM</a>                                             \
        .word 0, 0;                                             \
        .byte 0, 0, 0, 0

<span class='comment'>// The 0xC0 means the limit is in 4096-byte units</span><span class='comment'>// and (<a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> executable segments) 32-bit mode.</span><a name='ASEG_ASM'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_ASM'>SEG_ASM</a>(type,base,lim)                                  \
        .word (((lim) &gt;&gt; 12) & 0xffff), ((base) & 0xffff);      \
        .byte (((base) &gt;&gt; 16) & 0xff), (0x90 | (type)),         \
                (0xC0 | (((lim) &gt;&gt; 28) & 0xf)), (((base) &gt;&gt; 24) & 0xff)

<a name='ASTA_X'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_X'><a class='define-ref' href='#ASTA_X'>STA_X</a></a>     0x8       <span class='comment'>// Executable segment</span><a name='ASTA_E'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_E'><a class='define-ref' href='#ASTA_E'>STA_E</a></a>     0x4       <span class='comment'>// Expand down (non-executable segments)</span><a name='ASTA_C'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_C'><a class='define-ref' href='#ASTA_C'>STA_C</a></a>     0x4       <span class='comment'>// Conforming code segment (executable only)</span><a name='ASTA_W'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_W'><a class='define-ref' href='#ASTA_W'>STA_W</a></a>     0x2       <span class='comment'>// Writeable (non-executable segments)</span><a name='ASTA_R'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_R'><a class='define-ref' href='#ASTA_R'>STA_R</a></a>     0x2       <span class='comment'>// Readable (executable segments)</span><a name='ASTA_A'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_A'><a class='define-ref' href='#ASTA_A'>STA_A</a></a>     0x1       <span class='comment'>// Accessed</span>


<hr/><a name='Immu.h'>###### <a class='page-ref' href='#Immu.h'>mmu.h</a> ########</a>

<span class='comment'>// This <a class='str-ref' href='#Sfile'>file</a> contains definitions <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the </span><span class='comment'>// x86 memory management unit (MMU).</span>
<span class='comment'>// Eflags register</span><a name='AFL_CF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_CF'>FL_CF</a>           0x00000001      <span class='comment'>// Carry Flag</span><a name='AFL_PF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_PF'>FL_PF</a>           0x00000004      <span class='comment'>// Parity Flag</span><a name='AFL_AF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_AF'>FL_AF</a>           0x00000010      <span class='comment'>// Auxiliary carry Flag</span><a name='AFL_ZF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_ZF'>FL_ZF</a>           0x00000040      <span class='comment'>// Zero Flag</span><a name='AFL_SF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_SF'>FL_SF</a>           0x00000080      <span class='comment'>// Sign Flag</span><a name='AFL_TF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_TF'>FL_TF</a>           0x00000100      <span class='comment'>// Trap Flag</span><a name='AFL_IF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_IF'>FL_IF</a>           0x00000200      <span class='comment'>// Interrupt Enable</span><a name='AFL_DF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_DF'>FL_DF</a>           0x00000400      <span class='comment'>// Direction Flag</span><a name='AFL_OF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_OF'>FL_OF</a>           0x00000800      <span class='comment'>// Overflow Flag</span><a name='AFL_IOPL_MASK'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_IOPL_MASK'>FL_IOPL_MASK</a>    0x00003000      <span class='comment'>// I/O Privilege Level bitmask</span><a name='AFL_IOPL_0'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_IOPL_0'>FL_IOPL_0</a>       0x00000000      <span class='comment'>//   IOPL == 0</span><a name='AFL_IOPL_1'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_IOPL_1'>FL_IOPL_1</a>       0x00001000      <span class='comment'>//   IOPL == 1</span><a name='AFL_IOPL_2'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_IOPL_2'>FL_IOPL_2</a>       0x00002000      <span class='comment'>//   IOPL == 2</span><a name='AFL_IOPL_3'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_IOPL_3'>FL_IOPL_3</a>       0x00003000      <span class='comment'>//   IOPL == 3</span><a name='AFL_NT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_NT'>FL_NT</a>           0x00004000      <span class='comment'>// Nested Task</span><a name='AFL_RF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_RF'>FL_RF</a>           0x00010000      <span class='comment'>// Resume Flag</span><a name='AFL_VM'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_VM'>FL_VM</a>           0x00020000      <span class='comment'>// Virtual 8086 mode</span><a name='AFL_AC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_AC'>FL_AC</a>           0x00040000      <span class='comment'>// Alignment Check</span><a name='AFL_VIF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_VIF'>FL_VIF</a>          0x00080000      <span class='comment'>// Virtual Interrupt Flag</span><a name='AFL_VIP'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_VIP'>FL_VIP</a>          0x00100000      <span class='comment'>// Virtual Interrupt Pending</span><a name='AFL_ID'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFL_ID'>FL_ID</a>           0x00200000      <span class='comment'>// <a class='define-ref' href='#AID'>ID</a> flag</span>
<span class='comment'>// Control Register <a class='define-ref' href='#Aflags'>flags</a></span><a name='ACR0_PE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_PE'>CR0_PE</a>          0x00000001      <span class='comment'>// Protection Enable</span><a name='ACR0_MP'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_MP'>CR0_MP</a>          0x00000002      <span class='comment'>// Monitor coProcessor</span><a name='ACR0_EM'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_EM'>CR0_EM</a>          0x00000004      <span class='comment'>// Emulation</span><a name='ACR0_TS'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_TS'>CR0_TS</a>          0x00000008      <span class='comment'>// Task Switched</span><a name='ACR0_ET'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_ET'>CR0_ET</a>          0x00000010      <span class='comment'>// Extension Type</span><a name='ACR0_NE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_NE'>CR0_NE</a>          0x00000020      <span class='comment'>// Numeric Errror</span><a name='ACR0_WP'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_WP'>CR0_WP</a>          0x00010000      <span class='comment'>// Write Protect</span><a name='ACR0_AM'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_AM'>CR0_AM</a>          0x00040000      <span class='comment'>// Alignment Mask</span><a name='ACR0_NW'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_NW'>CR0_NW</a>          0x20000000      <span class='comment'>// Not Writethrough</span><a name='ACR0_CD'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_CD'>CR0_CD</a>          0x40000000      <span class='comment'>// Cache Disable</span><a name='ACR0_PG'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR0_PG'>CR0_PG</a>          0x80000000      <span class='comment'>// Paging</span>
<a name='ACR4_PSE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACR4_PSE'>CR4_PSE</a>         0x00000010      <span class='comment'>// Page size extension</span>
<a name='ASEG_KCODE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_KCODE'>SEG_KCODE</a> 1  <span class='comment'>// kernel code</span><a name='ASEG_KDATA'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_KDATA'>SEG_KDATA</a> 2  <span class='comment'>// kernel data+stack</span><a name='ASEG_KCPU'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_KCPU'>SEG_KCPU</a>  3  <span class='comment'>// kernel per-<a class='str-ref' href='#Scpu'>cpu</a> data</span><a name='ASEG_UCODE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_UCODE'>SEG_UCODE</a> 4  <span class='comment'>// user code</span><a name='ASEG_UDATA'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_UDATA'>SEG_UDATA</a> 5  <span class='comment'>// user data+stack</span><a name='ASEG_TSS'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG_TSS'>SEG_TSS</a>   6  <span class='comment'>// this process's task state</span>
<span class='comment'>//PAGEBREAK!</span>#ifndef __ASSEMBLER__
<span class='comment'>// Segment Descriptor</span><a name='Ssegdesc'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Ssegdesc'>segdesc</a> {
  uint lim_15_0 : 16;  <span class='comment'>// Low bits of segment limit</span>  uint base_15_0 : 16; <span class='comment'>// Low bits of segment base address</span>  uint base_23_16 : 8; <span class='comment'>// Middle bits of segment base address</span>  uint type : 4;       <span class='comment'>// Segment type (see STS_ constants)</span>  uint s : 1;          <span class='comment'>// 0 = system, 1 = application</span>  uint dpl : 2;        <span class='comment'>// Descriptor Privilege Level</span>  uint p : 1;          <span class='comment'>// Present</span>  uint lim_19_16 : 4;  <span class='comment'>// High bits of segment limit</span>  uint avl : 1;        <span class='comment'>// Unused (available <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> software use)</span>  uint rsv1 : 1;       <span class='comment'>// Reserved</span>  uint db : 1;         <span class='comment'>// 0 = 16-bit segment, 1 = 32-bit segment</span>  uint g : 1;          <span class='comment'>// Granularity: limit scaled by 4K when set</span>  uint base_31_24 : 8; <span class='comment'>// High bits of segment base address</span>};

<span class='comment'>// Normal segment</span><a name='ASEG'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG'>SEG</a>(type, base, lim, dpl) (<span class='reserved'>struct</span> <a class='str-ref' href='#Ssegdesc'>segdesc</a>)    \
{ ((lim) &gt;&gt; 12) & 0xffff, (uint)(base) & 0xffff,      \
  ((uint)(base) &gt;&gt; 16) & 0xff, type, 1, dpl, 1,       \
  (uint)(lim) &gt;&gt; 28, 0, 0, 1, 1, (uint)(base) &gt;&gt; 24 }
<a name='ASEG16'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASEG16'>SEG16</a>(type, base, lim, dpl) (<span class='reserved'>struct</span> <a class='str-ref' href='#Ssegdesc'>segdesc</a>)  \
{ (lim) & 0xffff, (uint)(base) & 0xffff,              \
  ((uint)(base) &gt;&gt; 16) & 0xff, type, 1, dpl, 1,       \
  (uint)(lim) &gt;&gt; 16, 0, 0, 1, 0, (uint)(base) &gt;&gt; 24 }
#endif

<a name='ADPL_USER'></a><span class='hash'>#define</span> <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>    0x3     <span class='comment'>// User DPL</span>
<span class='comment'>// Application segment type bits</span><a name='ASTA_X'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_X'><a class='define-ref' href='#ASTA_X'>STA_X</a></a>       0x8     <span class='comment'>// Executable segment</span><a name='ASTA_E'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_E'><a class='define-ref' href='#ASTA_E'>STA_E</a></a>       0x4     <span class='comment'>// Expand down (non-executable segments)</span><a name='ASTA_C'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_C'><a class='define-ref' href='#ASTA_C'>STA_C</a></a>       0x4     <span class='comment'>// Conforming code segment (executable only)</span><a name='ASTA_W'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_W'><a class='define-ref' href='#ASTA_W'>STA_W</a></a>       0x2     <span class='comment'>// Writeable (non-executable segments)</span><a name='ASTA_R'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_R'><a class='define-ref' href='#ASTA_R'>STA_R</a></a>       0x2     <span class='comment'>// Readable (executable segments)</span><a name='ASTA_A'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTA_A'><a class='define-ref' href='#ASTA_A'>STA_A</a></a>       0x1     <span class='comment'>// Accessed</span>
<span class='comment'>// System segment type bits</span><a name='ASTS_T16A'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_T16A'>STS_T16A</a>    0x1     <span class='comment'>// Available 16-bit TSS</span><a name='ASTS_LDT'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_LDT'>STS_LDT</a>     0x2     <span class='comment'>// Local Descriptor Table</span><a name='ASTS_T16B'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_T16B'>STS_T16B</a>    0x3     <span class='comment'>// Busy 16-bit TSS</span><a name='ASTS_CG16'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_CG16'>STS_CG16</a>    0x4     <span class='comment'>// 16-bit Call Gate</span><a name='ASTS_TG'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_TG'>STS_TG</a>      0x5     <span class='comment'>// Task Gate / Coum Transmitions</span><a name='ASTS_IG16'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_IG16'>STS_IG16</a>    0x6     <span class='comment'>// 16-bit Interrupt Gate</span><a name='ASTS_TG16'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_TG16'>STS_TG16</a>    0x7     <span class='comment'>// 16-bit Trap Gate</span><a name='ASTS_T32A'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_T32A'>STS_T32A</a>    0x9     <span class='comment'>// Available 32-bit TSS</span><a name='ASTS_T32B'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_T32B'>STS_T32B</a>    0xB     <span class='comment'>// Busy 32-bit TSS</span><a name='ASTS_CG32'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_CG32'>STS_CG32</a>    0xC     <span class='comment'>// 32-bit Call Gate</span><a name='ASTS_IG32'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_IG32'>STS_IG32</a>    0xE     <span class='comment'>// 32-bit Interrupt Gate</span><a name='ASTS_TG32'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTS_TG32'>STS_TG32</a>    0xF     <span class='comment'>// 32-bit Trap Gate</span>
<span class='comment'>// A virtual address 'la' has a three-part structure as follows:</span><span class='comment'>//</span><span class='comment'>// +--------10------+-------10-------+---------12----------+</span><span class='comment'>// | Page Directory |   Page Table   | Offset within Page  |</span><span class='comment'>// |      Index     |      Index     |                     |</span><span class='comment'>// +----------------+----------------+---------------------+</span><span class='comment'>//  \--- <a class='define-ref' href='#APDX'>PDX</a>(va) --/ \--- <a class='define-ref' href='#APTX'>PTX</a>(va) --/ </span>
<span class='comment'>// page directory index</span><a name='APDX'></a><span class='hash'>#define</span> <a class='define-ref' href='#APDX'>PDX</a>(va)         (((uint)(va) &gt;&gt; <a class='define-ref' href='#APDXSHIFT'>PDXSHIFT</a>) & 0x3FF)

<span class='comment'>// page table index</span><a name='APTX'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTX'>PTX</a>(va)         (((uint)(va) &gt;&gt; <a class='define-ref' href='#APTXSHIFT'>PTXSHIFT</a>) & 0x3FF)

<span class='comment'>// construct virtual address from indexes and offset</span><a name='APGADDR'></a><span class='hash'>#define</span> <a class='define-ref' href='#APGADDR'>PGADDR</a>(d, t, o) ((uint)((d) &lt;&lt; <a class='define-ref' href='#APDXSHIFT'>PDXSHIFT</a> | (t) &lt;&lt; <a class='define-ref' href='#APTXSHIFT'>PTXSHIFT</a> | (o)))

<span class='comment'>// Page directory and page table constants.</span><a name='ANPDENTRIES'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANPDENTRIES'>NPDENTRIES</a>      1024    <span class='comment'>// # directory entries per page directory</span><a name='ANPTENTRIES'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANPTENTRIES'>NPTENTRIES</a>      1024    <span class='comment'>// # PTEs per page table</span><a name='APGSIZE'></a><span class='hash'>#define</span> <a class='define-ref' href='#APGSIZE'>PGSIZE</a>          4096    <span class='comment'>// bytes mapped by a page</span>
<a name='APGSHIFT'></a><span class='hash'>#define</span> <a class='define-ref' href='#APGSHIFT'>PGSHIFT</a>         12      <span class='comment'>// log2(<a class='define-ref' href='#APGSIZE'>PGSIZE</a>)</span><a name='APTXSHIFT'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTXSHIFT'>PTXSHIFT</a>        12      <span class='comment'>// offset of <a class='define-ref' href='#APTX'>PTX</a> in a linear address</span><a name='APDXSHIFT'></a><span class='hash'>#define</span> <a class='define-ref' href='#APDXSHIFT'>PDXSHIFT</a>        22      <span class='comment'>// offset of <a class='define-ref' href='#APDX'>PDX</a> in a linear address</span>
<a name='APGROUNDUP'></a><span class='hash'>#define</span> <a class='define-ref' href='#APGROUNDUP'>PGROUNDUP</a>(sz)  (((sz)+<a class='define-ref' href='#APGSIZE'>PGSIZE</a>-1) & ~(<a class='define-ref' href='#APGSIZE'>PGSIZE</a>-1))
<a name='APGROUNDDOWN'></a><span class='hash'>#define</span> <a class='define-ref' href='#APGROUNDDOWN'>PGROUNDDOWN</a>(a) (((a)) & ~(<a class='define-ref' href='#APGSIZE'>PGSIZE</a>-1))

<span class='comment'>// Page table/directory <a class='func-ref' href='#Fentry'>entry</a> <a class='define-ref' href='#Aflags'>flags</a>.</span><a name='APTE_P'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_P'>PTE_P</a>           0x001   <span class='comment'>// Present</span><a name='APTE_W'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_W'>PTE_W</a>           0x002   <span class='comment'>// Writeable</span><a name='APTE_U'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_U'>PTE_U</a>           0x004   <span class='comment'>// User</span><a name='APTE_PWT'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_PWT'>PTE_PWT</a>         0x008   <span class='comment'>// Write-Through</span><a name='APTE_PCD'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_PCD'>PTE_PCD</a>         0x010   <span class='comment'>// Cache-Disable</span><a name='APTE_A'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_A'>PTE_A</a>           0x020   <span class='comment'>// Accessed</span><a name='APTE_D'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_D'>PTE_D</a>           0x040   <span class='comment'>// Dirty</span><a name='APTE_PS'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_PS'>PTE_PS</a>          0x080   <span class='comment'>// Page Size</span><a name='APTE_MBZ'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_MBZ'>PTE_MBZ</a>         0x180   <span class='comment'>// Bits must be zero</span>
<span class='comment'>// Address in page table or page directory <a class='func-ref' href='#Fentry'>entry</a></span><a name='APTE_ADDR'></a><span class='hash'>#define</span> <a class='define-ref' href='#APTE_ADDR'>PTE_ADDR</a>(pte)   ((uint)(pte) & ~0xFFF)

#ifndef __ASSEMBLER__
<span class='reserved'>typedef</span> uint pte_t;

<span class='comment'>// Task state segment format</span><a name='Staskstate'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Staskstate'>taskstate</a> {
  uint link;         <span class='comment'>// Old ts selector</span>  uint esp0;         <span class='comment'>// Stack pointers and segment selectors</span>  ushort ss0;        <span class='comment'>//   after an increase in privilege level</span>  ushort padding1;
  uint *esp1;
  ushort ss1;
  ushort padding2;
  uint *esp2;
  ushort ss2;
  ushort padding3;
  void *cr3;         <span class='comment'>// Page directory base</span>  uint *eip;         <span class='comment'>// Saved state from last task <span class='reserved'>switch</span></span>  uint eflags;
  uint eax;          <span class='comment'>// More saved state (registers)</span>  uint ecx;
  uint edx;
  uint ebx;
  uint *esp;
  uint *ebp;
  uint esi;
  uint edi;
  ushort es;         <span class='comment'>// Even more saved state (segment selectors)</span>  ushort padding4;
  ushort cs;
  ushort padding5;
  ushort ss;
  ushort padding6;
  ushort ds;
  ushort padding7;
  ushort fs;
  ushort padding8;
  ushort gs;
  ushort padding9;
  ushort ldt;
  ushort padding10;
  ushort t;          <span class='comment'>// Trap on task <span class='reserved'>switch</span></span>  ushort iomb;       <span class='comment'>// I/O map base address</span>};

<span class='comment'>// PAGEBREAK: 12</span><span class='comment'>// Gate descriptors <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> interrupts and traps</span><a name='Sgatedesc'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sgatedesc'>gatedesc</a> {
  uint off_15_0 : 16;   <span class='comment'>// low 16 bits of offset in segment</span>  uint cs : 16;         <span class='comment'>// code segment selector</span>  uint args : 5;        <span class='comment'>// # args, 0 <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> interrupt/<a class='func-ref' href='#Ftrap'>trap</a> gates</span>  uint rsv1 : 3;        <span class='comment'>// reserved(should be zero I guess)</span>  uint type : 4;        <span class='comment'>// type(STS_{TG,IG32,TG32})</span>  uint s : 1;           <span class='comment'>// must be 0 (system)</span>  uint dpl : 2;         <span class='comment'>// descriptor(meaning new) privilege level</span>  uint p : 1;           <span class='comment'>// Present</span>  uint off_31_16 : 16;  <span class='comment'>// high bits of offset in segment</span>};

<span class='comment'>// Set up a normal interrupt/<a class='func-ref' href='#Ftrap'>trap</a> gate descriptor.</span><span class='comment'>// - istrap: 1 <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a <a class='func-ref' href='#Ftrap'>trap</a> (= exception) gate, 0 <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> an interrupt gate.</span><span class='comment'>//   interrupt gate clears <a class='define-ref' href='#AFL_IF'>FL_IF</a>, <a class='func-ref' href='#Ftrap'>trap</a> gate leaves <a class='define-ref' href='#AFL_IF'>FL_IF</a> alone</span><span class='comment'>// - sel: Code segment selector <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> interrupt/<a class='func-ref' href='#Ftrap'>trap</a> handler</span><span class='comment'>// - off: Offset in code segment <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> interrupt/<a class='func-ref' href='#Ftrap'>trap</a> handler</span><span class='comment'>// - dpl: Descriptor Privilege Level -</span><span class='comment'>//        the privilege level required <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> software to invoke</span><span class='comment'>//        this interrupt/<a class='func-ref' href='#Ftrap'>trap</a> gate explicitly using an int instruction.</span><a name='ASETGATE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASETGATE'>SETGATE</a>(gate, istrap, sel, off, d)                \
{                                                         \
  (gate).off_15_0 = (uint)(off) & 0xffff;                \
  (gate).cs = (sel);                                      \
  (gate).args = 0;                                        \
  (gate).rsv1 = 0;                                        \
  (gate).type = (istrap) ? <a class='define-ref' href='#ASTS_TG32'>STS_TG32</a> : <a class='define-ref' href='#ASTS_IG32'>STS_IG32</a>;           \
  (gate).s = 0;                                           \
  (gate).dpl = (d);                                       \
  (gate).p = 1;                                           \
  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \
}

#endif



<hr/><a name='Ielf.h'>###### <a class='page-ref' href='#Ielf.h'>elf.h</a> ########</a>

<span class='comment'>// Format of an ELF executable <a class='str-ref' href='#Sfile'>file</a></span>
<a name='AELF_MAGIC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AELF_MAGIC'>ELF_MAGIC</a> 0x464C457FU  <span class='comment'>// "\x7FELF" in little endian</span>
<span class='comment'>// File header</span><a name='Selfhdr'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Selfhdr'>elfhdr</a> {
  uint <a class='define-ref' href='#Amagic'>magic</a>;  <span class='comment'>// must equal <a class='define-ref' href='#AELF_MAGIC'>ELF_MAGIC</a></span>  uchar elf[12];
  ushort type;
  ushort machine;
  uint version;
  uint <a class='func-ref' href='#Fentry'>entry</a>;
  uint phoff;
  uint shoff;
  uint <a class='define-ref' href='#Aflags'>flags</a>;
  ushort ehsize;
  ushort phentsize;
  ushort phnum;
  ushort shentsize;
  ushort shnum;
  ushort shstrndx;
};

<span class='comment'>// Program section header</span><a name='Sproghdr'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sproghdr'>proghdr</a> {
  uint type;
  uint off;
  uint vaddr;
  uint paddr;
  uint filesz;
  uint memsz;
  uint <a class='define-ref' href='#Aflags'>flags</a>;
  uint align;
};

<span class='comment'>// Values <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> Proghdr type</span><a name='AELF_PROG_LOAD'></a><span class='hash'>#define</span> <a class='define-ref' href='#AELF_PROG_LOAD'>ELF_PROG_LOAD</a>           1

<span class='comment'>// Flag bits <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> Proghdr <a class='define-ref' href='#Aflags'>flags</a></span><a name='AELF_PROG_FLAG_EXEC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AELF_PROG_FLAG_EXEC'>ELF_PROG_FLAG_EXEC</a>      1
<a name='AELF_PROG_FLAG_WRITE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AELF_PROG_FLAG_WRITE'>ELF_PROG_FLAG_WRITE</a>     2
<a name='AELF_PROG_FLAG_READ'></a><span class='hash'>#define</span> <a class='define-ref' href='#AELF_PROG_FLAG_READ'>ELF_PROG_FLAG_READ</a>      4



<hr/><a name='Ientry.S'>###### <a class='page-ref' href='#Ientry.S'><a class='func-ref' href='#Fentry'>entry</a>.S</a> ########</a>

# Multiboot header, <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> multiboot boot loaders like GNU Grub.
# http:<span class='comment'>//www.gnu.org/software/grub/manual/multiboot/multiboot.html</span>#
# Using GRUB 2, you can boot xv6 from a <a class='str-ref' href='#Sfile'>file</a> stored in a
# Linux <a class='str-ref' href='#Sfile'>file</a> system by copying kernel or kernelmemfs to /boot
# and then adding this menu <a class='func-ref' href='#Fentry'>entry</a>:
#
# menuentry "xv6" {
# 	insmod ext2
# 	set root='(hd0,msdos1)'
# 	set kernel='/boot/kernel'
# 	echo "Loading ${kernel}..."
# 	multiboot ${kernel} ${kernel}
# 	boot
# }

<span class='hash'>#include</span> "<a class='page-ref' href='#Iasm.h'>asm.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"

# Multiboot header.  Data to direct multiboot loader.
.p2align 2
.text
.globl <a class='func-ref' href='#Fmultiboot_header'>multiboot_header</a>
<a name='Fmultiboot_header'><a class='func-ref' href='#Fmultiboot_header'>multiboot_header</a></a>:
  <a name='Amagic'></a><span class='hash'>#define</span> <a class='define-ref' href='#Amagic'>magic</a> 0x1badb002
  <a name='Aflags'></a><span class='hash'>#define</span> <a class='define-ref' href='#Aflags'>flags</a> 0
  .long <a class='define-ref' href='#Amagic'>magic</a>
  .long <a class='define-ref' href='#Aflags'>flags</a>
  .long (-<a class='define-ref' href='#Amagic'>magic</a>-<a class='define-ref' href='#Aflags'>flags</a>)

# By convention, the _start symbol specifies the ELF <a class='func-ref' href='#Fentry'>entry</a> point.
# Since we haven't set up virtual memory yet, our <a class='func-ref' href='#Fentry'>entry</a> point is
# the physical address of '<a class='func-ref' href='#Fentry'>entry</a>'.
.globl _start
_start = <a class='define-ref' href='#AV2P_WO'>V2P_WO</a>(<a class='func-ref' href='#Fentry'>entry</a>)

# Entering xv6 on boot processor, with paging off.
.globl <a class='func-ref' href='#Fentry'>entry</a>
<a name='Fentry'><a class='func-ref' href='#Fentry'>entry</a></a>:
  # Turn on page size extension <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> 4Mbyte pages
  movl    %cr4, %eax
  orl     $(<a class='define-ref' href='#ACR4_PSE'>CR4_PSE</a>), %eax
  movl    %eax, %cr4
  # Set page directory
  movl    $(<a class='define-ref' href='#AV2P_WO'>V2P_WO</a>(entrypgdir)), %eax
  movl    %eax, %cr3
  # Turn on paging.
  movl    %cr0, %eax
  orl     $(<a class='define-ref' href='#ACR0_PG'>CR0_PG</a>|<a class='define-ref' href='#ACR0_WP'>CR0_WP</a>), %eax
  movl    %eax, %cr0

  # Set up the stack pointer.
  movl $(stack + <a class='define-ref' href='#AKSTACKSIZE'>KSTACKSIZE</a>), %esp

  # Jump to <a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a>(), and <span class='reserved'>switch</span> to executing at
  # high addresses. The indirect call is needed because
  # the assembler produces a PC-relative instruction
  # <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a direct jump.
  mov $<a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a>, %eax
  jmp *%eax

.comm stack, <a class='define-ref' href='#AKSTACKSIZE'>KSTACKSIZE</a>



<hr/><a name='Ientryother.S'>###### <a class='page-ref' href='#Ientryother.S'>entryother.S</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Iasm.h'>asm.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
	
# Each non-boot CPU ("AP") is started up in response to a <a class='define-ref' href='#ASTARTUP'>STARTUP</a>
# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
# Specification says that the AP will <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> in real mode with CS:IP
# set to XY00:0000, where XY is an 8-bit value sent with the
# <a class='define-ref' href='#ASTARTUP'>STARTUP</a>. Thus this code must <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> at a 4096-byte boundary.
#
# Because this code sets DS to zero, it must sit
# at an address in the low 2^16 bytes.
#
# Startothers (in <a class='page-ref' href='#Imain.c'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a>.c</a>) sends the STARTUPs one at a time.
# It copies this code (<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>) at 0x7000.  It puts the address of
# a newly allocated per-core stack in <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-4,the address of the
# place to jump to (<a class='func-ref' href='#Fmpenter'>mpenter</a>) in <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-8, and the physical address
# of entrypgdir in <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-12.
#
# This code is identical to <a class='page-ref' href='#Ibootasm.S'>bootasm.S</a> except:
#   - it does not need to enable A20
#   - it uses the address at <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-4, <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-8, and <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-12

.code16           
.globl <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>
<a name='Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a></a>:
  <a class='func-ref' href='#Fcli'>cli</a>            

  xorw    %ax,%ax
  movw    %ax,%ds
  movw    %ax,%es
  movw    %ax,%ss

  <a class='func-ref' href='#Flgdt'>lgdt</a>    <a class='func-ref' href='#Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'>gdtdesc</a></a>
  movl    %cr0, %eax
  orl     $<a class='define-ref' href='#ACR0_PE'>CR0_PE</a>, %eax
  movl    %eax, %cr0

<span class='comment'>//PAGEBREAK!</span>  ljmpl    $(<a class='define-ref' href='#ASEG_KCODE'>SEG_KCODE</a>&lt;&lt;3), $(<a class='func-ref' href='#Fstart32'><a class='func-ref' href='#Fstart32'>start32</a></a>)

.code32
<a name='Fstart32'><a class='func-ref' href='#Fstart32'><a class='func-ref' href='#Fstart32'>start32</a></a></a>:
  movw    $(<a class='define-ref' href='#ASEG_KDATA'>SEG_KDATA</a>&lt;&lt;3), %ax
  movw    %ax, %ds
  movw    %ax, %es
  movw    %ax, %ss
  movw    $0, %ax
  movw    %ax, %fs
  movw    %ax, %gs

  # Turn on page size extension <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> 4Mbyte pages
  movl    %cr4, %eax
  orl     $(<a class='define-ref' href='#ACR4_PSE'>CR4_PSE</a>), %eax
  movl    %eax, %cr4
  # Use enterpgdir as our initial page table
  movl    (<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-12), %eax
  movl    %eax, %cr3
  # Turn on paging.
  movl    %cr0, %eax
  orl     $(<a class='define-ref' href='#ACR0_PE'>CR0_PE</a>|<a class='define-ref' href='#ACR0_PG'>CR0_PG</a>|<a class='define-ref' href='#ACR0_WP'>CR0_WP</a>), %eax
  movl    %eax, %cr0

  # Switch to the stack allocated by <a class='func-ref' href='#Fstartothers'>startothers</a>()
  movl    (<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-4), %esp
  # Call <a class='func-ref' href='#Fmpenter'>mpenter</a>()
  call	 *(<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>-8)

  movw    $0x8a00, %ax
  movw    %ax, %dx
  <a class='func-ref' href='#Foutw'>outw</a>    %ax, %dx
  movw    $0x8ae0, %ax
  <a class='func-ref' href='#Foutw'>outw</a>    %ax, %dx
<a name='Fspin'><a class='func-ref' href='#Fspin'><a class='func-ref' href='#Fspin'>spin</a></a></a>:
  jmp     <a class='func-ref' href='#Fspin'><a class='func-ref' href='#Fspin'>spin</a></a>

.p2align 2
<a name='Fgdt'><a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a></a>:
  <a class='define-ref' href='#ASEG_NULLASM'>SEG_NULLASM</a>
  <a class='define-ref' href='#ASEG_ASM'>SEG_ASM</a>(<a class='define-ref' href='#ASTA_X'><a class='define-ref' href='#ASTA_X'>STA_X</a></a>|<a class='define-ref' href='#ASTA_R'><a class='define-ref' href='#ASTA_R'>STA_R</a></a>, 0, 0xffffffff)
  <a class='define-ref' href='#ASEG_ASM'>SEG_ASM</a>(<a class='define-ref' href='#ASTA_W'><a class='define-ref' href='#ASTA_W'>STA_W</a></a>, 0, 0xffffffff)


<a name='Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'>gdtdesc</a></a></a>:
  .word   (<a class='func-ref' href='#Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'>gdtdesc</a></a> - <a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a> - 1)
  .long   <a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>




<hr/><a name='Imain.c'>###### <a class='page-ref' href='#Imain.c'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a>.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"

<span class='reserved'>static</span> void <a class='func-ref' href='#Fstartothers'>startothers</a>(void);
<span class='reserved'>static</span> void <a class='func-ref' href='#Fmpmain'>mpmain</a>(void)  <a class='func-ref' href='#F__attribute__'>__attribute__</a>((noreturn));
<span class='reserved'>extern</span> pde_t *kpgdir;
<span class='reserved'>extern</span> char end[]; <span class='comment'>// first address after kernel loaded from ELF <a class='str-ref' href='#Sfile'>file</a></span>
<span class='comment'>// Bootstrap processor starts running <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a> code here.</span><span class='comment'>// Allocate a real stack and <span class='reserved'>switch</span> to it, first</span><span class='comment'>// doing some setup required <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> memory allocator to work.</span>int
<a name='Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a></a>(void)
{
  <a class='func-ref' href='#Fkinit1'>kinit1</a>(end, <a class='define-ref' href='#AP2V'>P2V</a>(4*1024*1024)); <span class='comment'>// phys page allocator</span>  <a class='func-ref' href='#Fkvmalloc'>kvmalloc</a>();      <span class='comment'>// kernel page table</span>  <a class='func-ref' href='#Fmpinit'>mpinit</a>();        <span class='comment'>// collect info about this machine</span>  <a class='func-ref' href='#Flapicinit'>lapicinit</a>();
  <a class='func-ref' href='#Fseginit'>seginit</a>();       <span class='comment'>// set up segments</span>  <a class='func-ref' href='#Fcprintf'>cprintf</a>("\ncpu%d: starting xv6\n\n", <a class='str-ref' href='#Scpu'>cpu</a>-&gt;id);
  <a class='func-ref' href='#Fpicinit'>picinit</a>();       <span class='comment'>// interrupt controller</span>  <a class='func-ref' href='#Fioapicinit'>ioapicinit</a>();    <span class='comment'>// another interrupt controller</span>  <a class='func-ref' href='#Fconsoleinit'>consoleinit</a>();   <span class='comment'>// I/O devices & their interrupts</span>  <a class='func-ref' href='#Fuartinit'>uartinit</a>();      <span class='comment'>// serial port</span>  <a class='func-ref' href='#Fpinit'>pinit</a>();         <span class='comment'>// process table</span>  <a class='func-ref' href='#Ftvinit'>tvinit</a>();        <span class='comment'>// <a class='func-ref' href='#Ftrap'>trap</a> vectors</span>  <a class='func-ref' href='#Fbinit'>binit</a>();         <span class='comment'>// buffer cache</span>  <a class='func-ref' href='#Ffileinit'>fileinit</a>();      <span class='comment'>// <a class='str-ref' href='#Sfile'>file</a> table</span>  <a class='func-ref' href='#Fiinit'>iinit</a>();         <span class='comment'>// <a class='str-ref' href='#Sinode'>inode</a> cache</span>  <a class='func-ref' href='#Fideinit'>ideinit</a>();       <span class='comment'>// disk</span>  <span class='reserved'>if</span>(!ismp)
    <a class='func-ref' href='#Ftimerinit'>timerinit</a>();   <span class='comment'>// uniprocessor timer</span>  <a class='func-ref' href='#Fstartothers'>startothers</a>();   <span class='comment'>// <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> other processors</span>  <a class='func-ref' href='#Fkinit2'>kinit2</a>(<a class='define-ref' href='#AP2V'>P2V</a>(4*1024*1024), <a class='define-ref' href='#AP2V'>P2V</a>(<a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>)); <span class='comment'>// must come after <a class='func-ref' href='#Fstartothers'>startothers</a>()</span>  <a class='func-ref' href='#Fuserinit'>userinit</a>();      <span class='comment'>// first user process</span>  <span class='comment'>// Finish setting up this processor in <a class='func-ref' href='#Fmpmain'>mpmain</a>.</span>  <a class='func-ref' href='#Fmpmain'>mpmain</a>();
}

<span class='comment'>// Other CPUs jump here from <a class='page-ref' href='#Ientryother.S'>entryother.S</a>.</span><span class='reserved'>static</span> void
<a name='Fmpenter'><a class='func-ref' href='#Fmpenter'>mpenter</a></a>(void)
{
  <a class='func-ref' href='#Fswitchkvm'>switchkvm</a>(); 
  <a class='func-ref' href='#Fseginit'>seginit</a>();
  <a class='func-ref' href='#Flapicinit'>lapicinit</a>();
  <a class='func-ref' href='#Fmpmain'>mpmain</a>();
}

<span class='comment'>// Common CPU setup code.</span><span class='reserved'>static</span> void
<a name='Fmpmain'><a class='func-ref' href='#Fmpmain'>mpmain</a></a>(void)
{
  <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='str-ref' href='#Scpu'>cpu</a>%d: starting\n", <a class='str-ref' href='#Scpu'>cpu</a>-&gt;id);
  <a class='func-ref' href='#Fidtinit'>idtinit</a>();       <span class='comment'>// load idt register</span>  <a class='func-ref' href='#Fxchg'>xchg</a>(&<a class='str-ref' href='#Scpu'>cpu</a>-&gt;started, 1); <span class='comment'>// tell <a class='func-ref' href='#Fstartothers'>startothers</a>() we're up</span>  <a class='func-ref' href='#Fscheduler'>scheduler</a>();     <span class='comment'>// <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> running processes</span>}

pde_t entrypgdir[];  <span class='comment'>// For <a class='page-ref' href='#Ientry.S'><a class='func-ref' href='#Fentry'>entry</a>.S</a></span>
<span class='comment'>// Start the non-boot (AP) processors.</span><span class='reserved'>static</span> void
<a name='Fstartothers'><a class='func-ref' href='#Fstartothers'>startothers</a></a>(void)
{
  <span class='reserved'>extern</span> uchar _binary_entryother_start[], _binary_entryother_size[];
  uchar *code;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> *c;
  char *stack;

  <span class='comment'>// Write <a class='func-ref' href='#Fentry'>entry</a> code to unused memory at 0x7000.</span>  <span class='comment'>// The linker has placed the image of <a class='page-ref' href='#Ientryother.S'>entryother.S</a> in</span>  <span class='comment'>// _binary_entryother_start.</span>  code = p2v(0x7000);
  <a class='func-ref' href='#Fmemmove'>memmove</a>(code, _binary_entryother_start, (uint)_binary_entryother_size);

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(c = cpus; c &lt; cpus+ncpu; c++){
    <span class='reserved'>if</span>(c == cpus+<a class='func-ref' href='#Fcpunum'>cpunum</a>())  <span class='comment'>// We've started already.</span>      continue;

    <span class='comment'>// Tell <a class='page-ref' href='#Ientryother.S'>entryother.S</a> what stack to use, where to enter, and what </span>    <span class='comment'>// pgdir to use. We cannot use kpgdir yet, because the AP processor</span>    <span class='comment'>// is running in low  memory, so we use entrypgdir <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the APs too.</span>    stack = <a class='func-ref' href='#Fkalloc'>kalloc</a>();
    *(void**)(code-4) = stack + <a class='define-ref' href='#AKSTACKSIZE'>KSTACKSIZE</a>;
    *(void**)(code-8) = <a class='func-ref' href='#Fmpenter'>mpenter</a>;
    *(int**)(code-12) = (void *) v2p(entrypgdir);

    <a class='func-ref' href='#Flapicstartap'>lapicstartap</a>(c-&gt;id, v2p(code));

    <span class='comment'>// <a class='func-ref' href='#Fwait'>wait</a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> <a class='str-ref' href='#Scpu'>cpu</a> to finish <a class='func-ref' href='#Fmpmain'>mpmain</a>()</span>    <span class='reserved'>while</span>(c-&gt;started == 0)
      ;
  }
}

<span class='comment'>// Boot page table used in <a class='page-ref' href='#Ientry.S'><a class='func-ref' href='#Fentry'>entry</a>.S</a> and <a class='page-ref' href='#Ientryother.S'>entryother.S</a>.</span><span class='comment'>// Page directories (and page tables), must <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> on a page boundary,</span><span class='comment'>// hence the "__aligned__" attribute.  </span><span class='comment'>// Use <a class='define-ref' href='#APTE_PS'>PTE_PS</a> in page directory <a class='func-ref' href='#Fentry'>entry</a> to enable 4Mbyte pages.</span><a name='F__attribute__'><a class='func-ref' href='#F__attribute__'>__attribute__</a></a>((__aligned__(<a class='define-ref' href='#APGSIZE'>PGSIZE</a>)))
pde_t entrypgdir[<a class='define-ref' href='#ANPDENTRIES'>NPDENTRIES</a>] = {
  <span class='comment'>// Map VA's [0, 4MB) to PA's [0, 4MB)</span>  [0] = (0) | <a class='define-ref' href='#APTE_P'>PTE_P</a> | <a class='define-ref' href='#APTE_W'>PTE_W</a> | <a class='define-ref' href='#APTE_PS'>PTE_PS</a>,
  <span class='comment'>// Map VA's [<a class='define-ref' href='#AKERNBASE'>KERNBASE</a>, <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>+4MB) to PA's [0, 4MB)</span>  [<a class='define-ref' href='#AKERNBASE'>KERNBASE</a>&gt;&gt;<a class='define-ref' href='#APDXSHIFT'>PDXSHIFT</a>] = (0) | <a class='define-ref' href='#APTE_P'>PTE_P</a> | <a class='define-ref' href='#APTE_W'>PTE_W</a> | <a class='define-ref' href='#APTE_PS'>PTE_PS</a>,
};

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Blank page.</span>



<hr/><a name='Ispinlock.h'>###### <a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a> ########</a>

<span class='comment'>// Mutual exclusion lock.</span><a name='Sspinlock'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> {
  uint locked;       <span class='comment'>// Is the lock held?</span>  
  <span class='comment'>// For debugging:</span>  char *name;        <span class='comment'>// Name of lock.</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> *<a class='str-ref' href='#Scpu'>cpu</a>;   <span class='comment'>// The <a class='str-ref' href='#Scpu'>cpu</a> <a class='func-ref' href='#Fholding'>holding</a> the lock.</span>  uint pcs[10];      <span class='comment'>// The call stack (an array of program counters)</span>                     <span class='comment'>// that locked the lock.</span>};




<hr/><a name='Ispinlock.c'>###### <a class='page-ref' href='#Ispinlock.c'><a class='str-ref' href='#Sspinlock'>spinlock</a>.c</a> ########</a>

<span class='comment'>// Mutual exclusion <a class='func-ref' href='#Fspin'><a class='func-ref' href='#Fspin'>spin</a></a> locks.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"

void
<a name='Finitlock'><a class='func-ref' href='#Finitlock'>initlock</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> *lk, char *name)
{
  lk-&gt;name = name;
  lk-&gt;locked = 0;
  lk-&gt;<a class='str-ref' href='#Scpu'>cpu</a> = 0;
}

<span class='comment'>// Acquire the lock.</span><span class='comment'>// Loops (spins) until the lock is acquired.</span><span class='comment'>// Holding a lock <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a long time may cause</span><span class='comment'>// other CPUs to waste time spinning to <a class='func-ref' href='#Facquire'>acquire</a> it.</span>void
<a name='Facquire'><a class='func-ref' href='#Facquire'>acquire</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> *lk)
{
  <a class='func-ref' href='#Fpushcli'>pushcli</a>(); <span class='comment'>// disable interrupts to avoid deadlock.</span>  <span class='reserved'>if</span>(<a class='func-ref' href='#Fholding'>holding</a>(lk))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Facquire'>acquire</a>");

  <span class='comment'>// The <a class='func-ref' href='#Fxchg'>xchg</a> is atomic.</span>  <span class='comment'>// It also serializes, so that reads after <a class='func-ref' href='#Facquire'>acquire</a> are not</span>  <span class='comment'>// reordered before it. </span>  <span class='reserved'>while</span>(<a class='func-ref' href='#Fxchg'>xchg</a>(&lk-&gt;locked, 1) != 0)
    ;

  <span class='comment'>// Record info about lock acquisition <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> debugging.</span>  lk-&gt;<a class='str-ref' href='#Scpu'>cpu</a> = <a class='str-ref' href='#Scpu'>cpu</a>;
  <a class='func-ref' href='#Fgetcallerpcs'>getcallerpcs</a>(&lk, lk-&gt;pcs);
}

<span class='comment'>// Release the lock.</span>void
<a name='Frelease'><a class='func-ref' href='#Frelease'>release</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> *lk)
{
  <span class='reserved'>if</span>(!<a class='func-ref' href='#Fholding'>holding</a>(lk))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Frelease'>release</a>");

  lk-&gt;pcs[0] = 0;
  lk-&gt;<a class='str-ref' href='#Scpu'>cpu</a> = 0;

  <span class='comment'>// The <a class='func-ref' href='#Fxchg'>xchg</a> serializes, so that reads before <a class='func-ref' href='#Frelease'>release</a> are </span>  <span class='comment'>// not reordered after it.  The 1996 PentiumPro manual (Volume 3,</span>  <span class='comment'>// 7.2) says reads can be carried out speculatively and in</span>  <span class='comment'>// any order, which implies we need to serialize here.</span>  <span class='comment'>// But the 2007 Intel 64 Architecture Memory Ordering White</span>  <span class='comment'>// Paper says that Intel 64 and IA-32 will not move a load</span>  <span class='comment'>// after a store. So lock-&gt;locked = 0 would work here.</span>  <span class='comment'>// The <a class='func-ref' href='#Fxchg'>xchg</a> being asm volatile ensures gcc emits it after</span>  <span class='comment'>// the above assignments (and after the critical section).</span>  <a class='func-ref' href='#Fxchg'>xchg</a>(&lk-&gt;locked, 0);

  <a class='func-ref' href='#Fpopcli'>popcli</a>();
}

<span class='comment'>// Record the current call stack in pcs[] by following the %ebp chain.</span>void
<a name='Fgetcallerpcs'><a class='func-ref' href='#Fgetcallerpcs'>getcallerpcs</a></a>(void *v, uint pcs[])
{
  uint *ebp;
  int i;
  
  ebp = (uint*)v - 2;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; 10; i++){
    <span class='reserved'>if</span>(ebp == 0 || ebp &lt; (uint*)<a class='define-ref' href='#AKERNBASE'>KERNBASE</a> || ebp == (uint*)0xffffffff)
      <span class='reserved'>break</span>;
    pcs[i] = ebp[1];     <span class='comment'>// saved %eip</span>    ebp = (uint*)ebp[0]; <span class='comment'>// saved %ebp</span>  }
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(; i &lt; 10; i++)
    pcs[i] = 0;
}

<span class='comment'>// Check whether this <a class='str-ref' href='#Scpu'>cpu</a> is <a class='func-ref' href='#Fholding'>holding</a> the lock.</span>int
<a name='Fholding'><a class='func-ref' href='#Fholding'>holding</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> *lock)
{
  <span class='reserved'>return</span> lock-&gt;locked && lock-&gt;<a class='str-ref' href='#Scpu'>cpu</a> == <a class='str-ref' href='#Scpu'>cpu</a>;
}


<span class='comment'>// Pushcli/<a class='func-ref' href='#Fpopcli'>popcli</a> are like <a class='func-ref' href='#Fcli'>cli</a>/<a class='func-ref' href='#Fsti'>sti</a> except that they are matched:</span><span class='comment'>// it takes two <a class='func-ref' href='#Fpopcli'>popcli</a> to undo two <a class='func-ref' href='#Fpushcli'>pushcli</a>.  Also, <span class='reserved'>if</span> interrupts</span><span class='comment'>// are off, then <a class='func-ref' href='#Fpushcli'>pushcli</a>, <a class='func-ref' href='#Fpopcli'>popcli</a> leaves them off.</span>
void
<a name='Fpushcli'><a class='func-ref' href='#Fpushcli'>pushcli</a></a>(void)
{
  int eflags;
  
  eflags = <a class='func-ref' href='#Freadeflags'>readeflags</a>();
  <a class='func-ref' href='#Fcli'>cli</a>();
  <span class='reserved'>if</span>(<a class='str-ref' href='#Scpu'>cpu</a>-&gt;ncli++ == 0)
    <a class='str-ref' href='#Scpu'>cpu</a>-&gt;intena = eflags & <a class='define-ref' href='#AFL_IF'>FL_IF</a>;
}

void
<a name='Fpopcli'><a class='func-ref' href='#Fpopcli'>popcli</a></a>(void)
{
  <span class='reserved'>if</span>(<a class='func-ref' href='#Freadeflags'>readeflags</a>()&<a class='define-ref' href='#AFL_IF'>FL_IF</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fpopcli'>popcli</a> - interruptible");
  <span class='reserved'>if</span>(--<a class='str-ref' href='#Scpu'>cpu</a>-&gt;ncli &lt; 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fpopcli'>popcli</a>");
  <span class='reserved'>if</span>(<a class='str-ref' href='#Scpu'>cpu</a>-&gt;ncli == 0 && <a class='str-ref' href='#Scpu'>cpu</a>-&gt;intena)
    <a class='func-ref' href='#Fsti'>sti</a>();
}




<hr/><a name='Ivm.c'>###### <a class='page-ref' href='#Ivm.c'>vm.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ielf.h'>elf.h</a>"

<span class='reserved'>extern</span> char data[];  <span class='comment'>// defined by kernel.ld</span>pde_t *kpgdir;  <span class='comment'>// <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> use in <a class='func-ref' href='#Fscheduler'>scheduler</a>()</span><span class='reserved'>struct</span> <a class='str-ref' href='#Ssegdesc'>segdesc</a> <a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ANSEGS'>NSEGS</a>];

<span class='comment'>// Set up CPU's kernel segment descriptors.</span><span class='comment'>// Run once on <a class='func-ref' href='#Fentry'>entry</a> on each CPU.</span>void
<a name='Fseginit'><a class='func-ref' href='#Fseginit'>seginit</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> *c;

  <span class='comment'>// Map "logical" addresses to virtual addresses using identity map.</span>  <span class='comment'>// Cannot share a CODE descriptor <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> both kernel and user</span>  <span class='comment'>// because it would have to have DPL_USR, but the CPU forbids</span>  <span class='comment'>// an interrupt from CPL=0 to DPL=3.</span>  c = &cpus[<a class='func-ref' href='#Fcpunum'>cpunum</a>()];
  c-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ASEG_KCODE'>SEG_KCODE</a>] = <a class='define-ref' href='#ASEG'>SEG</a>(<a class='define-ref' href='#ASTA_X'><a class='define-ref' href='#ASTA_X'>STA_X</a></a>|<a class='define-ref' href='#ASTA_R'><a class='define-ref' href='#ASTA_R'>STA_R</a></a>, 0, 0xffffffff, 0);
  c-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ASEG_KDATA'>SEG_KDATA</a>] = <a class='define-ref' href='#ASEG'>SEG</a>(<a class='define-ref' href='#ASTA_W'><a class='define-ref' href='#ASTA_W'>STA_W</a></a>, 0, 0xffffffff, 0);
  c-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ASEG_UCODE'>SEG_UCODE</a>] = <a class='define-ref' href='#ASEG'>SEG</a>(<a class='define-ref' href='#ASTA_X'><a class='define-ref' href='#ASTA_X'>STA_X</a></a>|<a class='define-ref' href='#ASTA_R'><a class='define-ref' href='#ASTA_R'>STA_R</a></a>, 0, 0xffffffff, <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>);
  c-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ASEG_UDATA'>SEG_UDATA</a>] = <a class='define-ref' href='#ASEG'>SEG</a>(<a class='define-ref' href='#ASTA_W'><a class='define-ref' href='#ASTA_W'>STA_W</a></a>, 0, 0xffffffff, <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>);

  <span class='comment'>// Map <a class='str-ref' href='#Scpu'>cpu</a>, and curproc</span>  c-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ASEG_KCPU'>SEG_KCPU</a>] = <a class='define-ref' href='#ASEG'>SEG</a>(<a class='define-ref' href='#ASTA_W'><a class='define-ref' href='#ASTA_W'>STA_W</a></a>, &c-&gt;<a class='str-ref' href='#Scpu'>cpu</a>, 8, 0);

  <a class='func-ref' href='#Flgdt'>lgdt</a>(c-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>, sizeof(c-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>));
  <a class='func-ref' href='#Floadgs'>loadgs</a>(<a class='define-ref' href='#ASEG_KCPU'>SEG_KCPU</a> &lt;&lt; 3);
  
  <span class='comment'>// Initialize <a class='str-ref' href='#Scpu'>cpu</a>-local storage.</span>  <a class='str-ref' href='#Scpu'>cpu</a> = c;
  <a class='str-ref' href='#Sproc'>proc</a> = 0;
}

<span class='comment'>// Return the address of the PTE in page table pgdir</span><span class='comment'>// that corresponds to virtual address va.  If alloc!=0,</span><span class='comment'>// <a class='func-ref' href='#Fcreate'>create</a> any required page table pages.</span><span class='reserved'>static</span> pte_t *
<a name='Fwalkpgdir'><a class='func-ref' href='#Fwalkpgdir'>walkpgdir</a></a>(pde_t *pgdir, const void *va, int alloc)
{
  pde_t *pde;
  pte_t *pgtab;

  pde = &pgdir[<a class='define-ref' href='#APDX'>PDX</a>(va)];
  <span class='reserved'>if</span>(*pde & <a class='define-ref' href='#APTE_P'>PTE_P</a>){
    pgtab = (pte_t*)p2v(<a class='define-ref' href='#APTE_ADDR'>PTE_ADDR</a>(*pde));
  } <span class='reserved'>else</span> {
    <span class='reserved'>if</span>(!alloc || (pgtab = (pte_t*)<a class='func-ref' href='#Fkalloc'>kalloc</a>()) == 0)
      <span class='reserved'>return</span> 0;
    <span class='comment'>// Make sure all those <a class='define-ref' href='#APTE_P'>PTE_P</a> bits are zero.</span>    <a class='func-ref' href='#Fmemset'>memset</a>(pgtab, 0, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>);
    <span class='comment'>// The permissions here are overly generous, but they can</span>    <span class='comment'>// be further restricted by the permissions in the page table </span>    <span class='comment'>// entries, <span class='reserved'>if</span> necessary.</span>    *pde = v2p(pgtab) | <a class='define-ref' href='#APTE_P'>PTE_P</a> | <a class='define-ref' href='#APTE_W'>PTE_W</a> | <a class='define-ref' href='#APTE_U'>PTE_U</a>;
  }
  <span class='reserved'>return</span> &pgtab[<a class='define-ref' href='#APTX'>PTX</a>(va)];
}

<span class='comment'>// Create PTEs <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> virtual addresses starting at va that refer to</span><span class='comment'>// physical addresses starting at pa. va and size might not</span><span class='comment'>// be page-aligned.</span><span class='reserved'>static</span> int
<a name='Fmappages'><a class='func-ref' href='#Fmappages'>mappages</a></a>(pde_t *pgdir, void *va, uint size, uint pa, int perm)
{
  char *a, *last;
  pte_t *pte;
  
  a = (char*)<a class='define-ref' href='#APGROUNDDOWN'>PGROUNDDOWN</a>((uint)va);
  last = (char*)<a class='define-ref' href='#APGROUNDDOWN'>PGROUNDDOWN</a>(((uint)va) + size - 1);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(;;){
    <span class='reserved'>if</span>((pte = <a class='func-ref' href='#Fwalkpgdir'>walkpgdir</a>(pgdir, a, 1)) == 0)
      <span class='reserved'>return</span> -1;
    <span class='reserved'>if</span>(*pte & <a class='define-ref' href='#APTE_P'>PTE_P</a>)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("remap");
    *pte = pa | perm | <a class='define-ref' href='#APTE_P'>PTE_P</a>;
    <span class='reserved'>if</span>(a == last)
      <span class='reserved'>break</span>;
    a += <a class='define-ref' href='#APGSIZE'>PGSIZE</a>;
    pa += <a class='define-ref' href='#APGSIZE'>PGSIZE</a>;
  }
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// There is one page table per process, plus one that's used when</span><span class='comment'>// a CPU is not running any process (kpgdir). The kernel uses the</span><span class='comment'>// current process's page table during system calls and interrupts;</span><span class='comment'>// page protection bits prevent user code from using the kernel's</span><span class='comment'>// mappings.</span><span class='comment'>// </span><span class='comment'>// <a class='func-ref' href='#Fsetupkvm'>setupkvm</a>() and <a class='func-ref' href='#Fexec'>exec</a>() set up every page table like this:</span><span class='comment'>//</span><span class='comment'>//   0..<a class='define-ref' href='#AKERNBASE'>KERNBASE</a>: user memory (text+data+stack+heap), mapped to</span><span class='comment'>//                phys memory allocated by the kernel</span><span class='comment'>//   <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>..<a class='define-ref' href='#AKERNBASE'>KERNBASE</a>+<a class='define-ref' href='#AEXTMEM'>EXTMEM</a>: mapped to 0..<a class='define-ref' href='#AEXTMEM'>EXTMEM</a> (<a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> I/O space)</span><span class='comment'>//   <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>+<a class='define-ref' href='#AEXTMEM'>EXTMEM</a>..data: mapped to <a class='define-ref' href='#AEXTMEM'>EXTMEM</a>..<a class='define-ref' href='#AV2P'>V2P</a>(data)</span><span class='comment'>//                <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the kernel's instructions and r/o data</span><span class='comment'>//   data..<a class='define-ref' href='#AKERNBASE'>KERNBASE</a>+<a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>: mapped to <a class='define-ref' href='#AV2P'>V2P</a>(data)..<a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>, </span><span class='comment'>//                                  rw data + free physical memory</span><span class='comment'>//   0xfe000000..0: mapped direct (devices such as <a class='str-ref' href='#Sioapic'>ioapic</a>)</span><span class='comment'>//</span><span class='comment'>// The kernel allocates physical memory <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> its heap and <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> user memory</span><span class='comment'>// between <a class='define-ref' href='#AV2P'>V2P</a>(end) and the end of physical memory (<a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>)</span><span class='comment'>// (directly addressable from end..<a class='define-ref' href='#AP2V'>P2V</a>(<a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>)).</span>
<span class='comment'>// This table defines the kernel's mappings, which are present in</span><span class='comment'>// every process's page table.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> kmap {
  void *virt;
  uint phys_start;
  uint phys_end;
  int perm;
} kmap[] = {
 { (void*)<a class='define-ref' href='#AKERNBASE'>KERNBASE</a>, 0,             <a class='define-ref' href='#AEXTMEM'>EXTMEM</a>,    <a class='define-ref' href='#APTE_W'>PTE_W</a>}, <span class='comment'>// I/O space</span> { (void*)<a class='define-ref' href='#AKERNLINK'>KERNLINK</a>, <a class='define-ref' href='#AV2P'>V2P</a>(<a class='define-ref' href='#AKERNLINK'>KERNLINK</a>), <a class='define-ref' href='#AV2P'>V2P</a>(data), 0},     <span class='comment'>// kern text+rodata</span> { (void*)data,     <a class='define-ref' href='#AV2P'>V2P</a>(data),     <a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>,   <a class='define-ref' href='#APTE_W'>PTE_W</a>}, <span class='comment'>// kern data+memory</span> { (void*)<a class='define-ref' href='#ADEVSPACE'>DEVSPACE</a>, <a class='define-ref' href='#ADEVSPACE'>DEVSPACE</a>,      0,         <a class='define-ref' href='#APTE_W'>PTE_W</a>}, <span class='comment'>// more devices</span>};

<span class='comment'>// Set up kernel part of a page table.</span>pde_t*
<a name='Fsetupkvm'><a class='func-ref' href='#Fsetupkvm'>setupkvm</a></a>(void)
{
  pde_t *pgdir;
  <span class='reserved'>struct</span> kmap *k;

  <span class='reserved'>if</span>((pgdir = (pde_t*)<a class='func-ref' href='#Fkalloc'>kalloc</a>()) == 0)
    <span class='reserved'>return</span> 0;
  <a class='func-ref' href='#Fmemset'>memset</a>(pgdir, 0, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>);
  <span class='reserved'>if</span> (p2v(<a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>) &gt; (void*)<a class='define-ref' href='#ADEVSPACE'>DEVSPACE</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='define-ref' href='#APHYSTOP'>PHYSTOP</a> too high");
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(k = kmap; k &lt; &kmap[<a class='define-ref' href='#ANELEM'>NELEM</a>(kmap)]; k++)
    <span class='reserved'>if</span>(<a class='func-ref' href='#Fmappages'>mappages</a>(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start, 
                (uint)k-&gt;phys_start, k-&gt;perm) &lt; 0)
      <span class='reserved'>return</span> 0;
  <span class='reserved'>return</span> pgdir;
}

<span class='comment'>// Allocate one page table <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the machine <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the kernel address</span><span class='comment'>// space <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> <a class='func-ref' href='#Fscheduler'>scheduler</a> processes.</span>void
<a name='Fkvmalloc'><a class='func-ref' href='#Fkvmalloc'>kvmalloc</a></a>(void)
{
  kpgdir = <a class='func-ref' href='#Fsetupkvm'>setupkvm</a>();
  <a class='func-ref' href='#Fswitchkvm'>switchkvm</a>();
}

<span class='comment'>// Switch h/w page table register to the kernel-only page table,</span><span class='comment'>// <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> when no process is running.</span>void
<a name='Fswitchkvm'><a class='func-ref' href='#Fswitchkvm'>switchkvm</a></a>(void)
{
  <a class='func-ref' href='#Flcr3'>lcr3</a>(v2p(kpgdir));   <span class='comment'>// <span class='reserved'>switch</span> to the kernel page table</span>}

<span class='comment'>// Switch TSS and h/w page table to correspond to process p.</span>void
<a name='Fswitchuvm'><a class='func-ref' href='#Fswitchuvm'>switchuvm</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p)
{
  <a class='func-ref' href='#Fpushcli'>pushcli</a>();
  <a class='str-ref' href='#Scpu'>cpu</a>-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ASEG_TSS'>SEG_TSS</a>] = <a class='define-ref' href='#ASEG16'>SEG16</a>(<a class='define-ref' href='#ASTS_T32A'>STS_T32A</a>, &<a class='str-ref' href='#Scpu'>cpu</a>-&gt;ts, sizeof(<a class='str-ref' href='#Scpu'>cpu</a>-&gt;ts)-1, 0);
  <a class='str-ref' href='#Scpu'>cpu</a>-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ASEG_TSS'>SEG_TSS</a>].s = 0;
  <a class='str-ref' href='#Scpu'>cpu</a>-&gt;ts.ss0 = <a class='define-ref' href='#ASEG_KDATA'>SEG_KDATA</a> &lt;&lt; 3;
  <a class='str-ref' href='#Scpu'>cpu</a>-&gt;ts.esp0 = (uint)<a class='str-ref' href='#Sproc'>proc</a>-&gt;kstack + <a class='define-ref' href='#AKSTACKSIZE'>KSTACKSIZE</a>;
  <a class='func-ref' href='#Fltr'>ltr</a>(<a class='define-ref' href='#ASEG_TSS'>SEG_TSS</a> &lt;&lt; 3);
  <span class='reserved'>if</span>(p-&gt;pgdir == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fswitchuvm'>switchuvm</a>: no pgdir");
  <a class='func-ref' href='#Flcr3'>lcr3</a>(v2p(p-&gt;pgdir));  <span class='comment'>// <span class='reserved'>switch</span> to new address space</span>  <a class='func-ref' href='#Fpopcli'>popcli</a>();
}

<span class='comment'>// Load the initcode into address 0 of pgdir.</span><span class='comment'>// sz must be less than a page.</span>void
<a name='Finituvm'><a class='func-ref' href='#Finituvm'>inituvm</a></a>(pde_t *pgdir, char *<a class='func-ref' href='#Finit'>init</a>, uint sz)
{
  char *mem;
  
  <span class='reserved'>if</span>(sz &gt;= <a class='define-ref' href='#APGSIZE'>PGSIZE</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Finituvm'>inituvm</a>: more than a page");
  mem = <a class='func-ref' href='#Fkalloc'>kalloc</a>();
  <a class='func-ref' href='#Fmemset'>memset</a>(mem, 0, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>);
  <a class='func-ref' href='#Fmappages'>mappages</a>(pgdir, 0, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>, v2p(mem), <a class='define-ref' href='#APTE_W'>PTE_W</a>|<a class='define-ref' href='#APTE_U'>PTE_U</a>);
  <a class='func-ref' href='#Fmemmove'>memmove</a>(mem, <a class='func-ref' href='#Finit'>init</a>, sz);
}

<span class='comment'>// Load a program segment into pgdir.  addr must be page-aligned</span><span class='comment'>// and the pages from addr to addr+sz must already be mapped.</span>int
<a name='Floaduvm'><a class='func-ref' href='#Floaduvm'>loaduvm</a></a>(pde_t *pgdir, char *addr, <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, uint offset, uint sz)
{
  uint i, pa, n;
  pte_t *pte;

  <span class='reserved'>if</span>((uint) addr % <a class='define-ref' href='#APGSIZE'>PGSIZE</a> != 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Floaduvm'>loaduvm</a>: addr must be page aligned");
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; sz; i += <a class='define-ref' href='#APGSIZE'>PGSIZE</a>){
    <span class='reserved'>if</span>((pte = <a class='func-ref' href='#Fwalkpgdir'>walkpgdir</a>(pgdir, addr+i, 0)) == 0)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Floaduvm'>loaduvm</a>: address should exist");
    pa = <a class='define-ref' href='#APTE_ADDR'>PTE_ADDR</a>(*pte);
    <span class='reserved'>if</span>(sz - i &lt; <a class='define-ref' href='#APGSIZE'>PGSIZE</a>)
      n = sz - i;
    <span class='reserved'>else</span>
      n = <a class='define-ref' href='#APGSIZE'>PGSIZE</a>;
    <span class='reserved'>if</span>(<a class='func-ref' href='#Freadi'>readi</a>(ip, p2v(pa), offset+i, n) != n)
      <span class='reserved'>return</span> -1;
  }
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Allocate page tables and physical memory to grow process from oldsz to</span><span class='comment'>// newsz, which need not be page aligned.  Returns new size or 0 on error.</span>int
<a name='Fallocuvm'><a class='func-ref' href='#Fallocuvm'>allocuvm</a></a>(pde_t *pgdir, uint oldsz, uint newsz)
{
  char *mem;
  uint a;

  <span class='reserved'>if</span>(newsz &gt;= <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>)
    <span class='reserved'>return</span> 0;
  <span class='reserved'>if</span>(newsz &lt; oldsz)
    <span class='reserved'>return</span> oldsz;

  a = <a class='define-ref' href='#APGROUNDUP'>PGROUNDUP</a>(oldsz);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(; a &lt; newsz; a += <a class='define-ref' href='#APGSIZE'>PGSIZE</a>){
    mem = <a class='func-ref' href='#Fkalloc'>kalloc</a>();
    <span class='reserved'>if</span>(mem == 0){
      <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='func-ref' href='#Fallocuvm'>allocuvm</a> out of memory\n");
      <a class='func-ref' href='#Fdeallocuvm'>deallocuvm</a>(pgdir, newsz, oldsz);
      <span class='reserved'>return</span> 0;
    }
    <a class='func-ref' href='#Fmemset'>memset</a>(mem, 0, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>);
    <a class='func-ref' href='#Fmappages'>mappages</a>(pgdir, (char*)a, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>, v2p(mem), <a class='define-ref' href='#APTE_W'>PTE_W</a>|<a class='define-ref' href='#APTE_U'>PTE_U</a>);
  }
  <span class='reserved'>return</span> newsz;
}

<span class='comment'>// Deallocate user pages to bring the process size from oldsz to</span><span class='comment'>// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span><span class='comment'>// need to be less than oldsz.  oldsz can be larger than the actual</span><span class='comment'>// process size.  Returns the new process size.</span>int
<a name='Fdeallocuvm'><a class='func-ref' href='#Fdeallocuvm'>deallocuvm</a></a>(pde_t *pgdir, uint oldsz, uint newsz)
{
  pte_t *pte;
  uint a, pa;

  <span class='reserved'>if</span>(newsz &gt;= oldsz)
    <span class='reserved'>return</span> oldsz;

  a = <a class='define-ref' href='#APGROUNDUP'>PGROUNDUP</a>(newsz);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(; a  &lt; oldsz; a += <a class='define-ref' href='#APGSIZE'>PGSIZE</a>){
    pte = <a class='func-ref' href='#Fwalkpgdir'>walkpgdir</a>(pgdir, (char*)a, 0);
    <span class='reserved'>if</span>(!pte)
      a += (<a class='define-ref' href='#ANPTENTRIES'>NPTENTRIES</a> - 1) * <a class='define-ref' href='#APGSIZE'>PGSIZE</a>;
    <span class='reserved'>else</span> <span class='reserved'>if</span>((*pte & <a class='define-ref' href='#APTE_P'>PTE_P</a>) != 0){
      pa = <a class='define-ref' href='#APTE_ADDR'>PTE_ADDR</a>(*pte);
      <span class='reserved'>if</span>(pa == 0)
        <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fkfree'>kfree</a>");
      char *v = p2v(pa);
      <a class='func-ref' href='#Fkfree'>kfree</a>(v);
      *pte = 0;
    }
  }
  <span class='reserved'>return</span> newsz;
}

<span class='comment'>// Free a page table and all the physical memory pages</span><span class='comment'>// in the user part.</span>void
<a name='Ffreevm'><a class='func-ref' href='#Ffreevm'>freevm</a></a>(pde_t *pgdir)
{
  uint i;

  <span class='reserved'>if</span>(pgdir == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Ffreevm'>freevm</a>: no pgdir");
  <a class='func-ref' href='#Fdeallocuvm'>deallocuvm</a>(pgdir, <a class='define-ref' href='#AKERNBASE'>KERNBASE</a>, 0);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; <a class='define-ref' href='#ANPDENTRIES'>NPDENTRIES</a>; i++){
    <span class='reserved'>if</span>(pgdir[i] & <a class='define-ref' href='#APTE_P'>PTE_P</a>){
      char * v = p2v(<a class='define-ref' href='#APTE_ADDR'>PTE_ADDR</a>(pgdir[i]));
      <a class='func-ref' href='#Fkfree'>kfree</a>(v);
    }
  }
  <a class='func-ref' href='#Fkfree'>kfree</a>((char*)pgdir);
}

<span class='comment'>// Clear <a class='define-ref' href='#APTE_U'>PTE_U</a> on a page. Used to <a class='func-ref' href='#Fcreate'>create</a> an inaccessible</span><span class='comment'>// page beneath the user stack.</span>void
<a name='Fclearpteu'><a class='func-ref' href='#Fclearpteu'>clearpteu</a></a>(pde_t *pgdir, char *uva)
{
  pte_t *pte;

  pte = <a class='func-ref' href='#Fwalkpgdir'>walkpgdir</a>(pgdir, uva, 0);
  <span class='reserved'>if</span>(pte == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fclearpteu'>clearpteu</a>");
  *pte &= ~<a class='define-ref' href='#APTE_U'>PTE_U</a>;
}

<span class='comment'>// Given a parent process's page table, <a class='func-ref' href='#Fcreate'>create</a> a copy</span><span class='comment'>// of it <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a child.</span>pde_t*
<a name='Fcopyuvm'><a class='func-ref' href='#Fcopyuvm'>copyuvm</a></a>(pde_t *pgdir, uint sz)
{
  pde_t *d;
  pte_t *pte;
  uint pa, i;
  char *mem;

  <span class='reserved'>if</span>((d = <a class='func-ref' href='#Fsetupkvm'>setupkvm</a>()) == 0)
    <span class='reserved'>return</span> 0;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; sz; i += <a class='define-ref' href='#APGSIZE'>PGSIZE</a>){
    <span class='reserved'>if</span>((pte = <a class='func-ref' href='#Fwalkpgdir'>walkpgdir</a>(pgdir, (void *) i, 0)) == 0)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fcopyuvm'>copyuvm</a>: pte should exist");
    <span class='reserved'>if</span>(!(*pte & <a class='define-ref' href='#APTE_P'>PTE_P</a>))
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fcopyuvm'>copyuvm</a>: page not present");
    pa = <a class='define-ref' href='#APTE_ADDR'>PTE_ADDR</a>(*pte);
    <span class='reserved'>if</span>((mem = <a class='func-ref' href='#Fkalloc'>kalloc</a>()) == 0)
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
    <a class='func-ref' href='#Fmemmove'>memmove</a>(mem, (char*)p2v(pa), <a class='define-ref' href='#APGSIZE'>PGSIZE</a>);
    <span class='reserved'>if</span>(<a class='func-ref' href='#Fmappages'>mappages</a>(d, (void*)i, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>, v2p(mem), <a class='define-ref' href='#APTE_W'>PTE_W</a>|<a class='define-ref' href='#APTE_U'>PTE_U</a>) &lt; 0)
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  }
  <span class='reserved'>return</span> d;

<a name='Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a></a>:
  <a class='func-ref' href='#Ffreevm'>freevm</a>(d);
  <span class='reserved'>return</span> 0;
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Map user virtual address to kernel address.</span>char*
<a name='Fuva2ka'><a class='func-ref' href='#Fuva2ka'>uva2ka</a></a>(pde_t *pgdir, char *uva)
{
  pte_t *pte;

  pte = <a class='func-ref' href='#Fwalkpgdir'>walkpgdir</a>(pgdir, uva, 0);
  <span class='reserved'>if</span>((*pte & <a class='define-ref' href='#APTE_P'>PTE_P</a>) == 0)
    <span class='reserved'>return</span> 0;
  <span class='reserved'>if</span>((*pte & <a class='define-ref' href='#APTE_U'>PTE_U</a>) == 0)
    <span class='reserved'>return</span> 0;
  <span class='reserved'>return</span> (char*)p2v(<a class='define-ref' href='#APTE_ADDR'>PTE_ADDR</a>(*pte));
}

<span class='comment'>// Copy len bytes from p to user address va in page table pgdir.</span><span class='comment'>// Most useful when pgdir is not the current page table.</span><span class='comment'>// <a class='func-ref' href='#Fuva2ka'>uva2ka</a> ensures this only works <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> <a class='define-ref' href='#APTE_U'>PTE_U</a> pages.</span>int
<a name='Fcopyout'><a class='func-ref' href='#Fcopyout'>copyout</a></a>(pde_t *pgdir, uint va, void *p, uint len)
{
  char *<a class='str-ref' href='#Sbuf'>buf</a>, *pa0;
  uint n, va0;

  <a class='str-ref' href='#Sbuf'>buf</a> = (char*)p;
  <span class='reserved'>while</span>(len &gt; 0){
    va0 = (uint)<a class='define-ref' href='#APGROUNDDOWN'>PGROUNDDOWN</a>(va);
    pa0 = <a class='func-ref' href='#Fuva2ka'>uva2ka</a>(pgdir, (char*)va0);
    <span class='reserved'>if</span>(pa0 == 0)
      <span class='reserved'>return</span> -1;
    n = <a class='define-ref' href='#APGSIZE'>PGSIZE</a> - (va - va0);
    <span class='reserved'>if</span>(n &gt; len)
      n = len;
    <a class='func-ref' href='#Fmemmove'>memmove</a>(pa0 + (va - va0), <a class='str-ref' href='#Sbuf'>buf</a>, n);
    len -= n;
    <a class='str-ref' href='#Sbuf'>buf</a> += n;
    va = va0 + <a class='define-ref' href='#APGSIZE'>PGSIZE</a>;
  }
  <span class='reserved'>return</span> 0;
}



<hr/><a name='Iproc.h'>###### <a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a> ########</a>

<span class='comment'>// Segments in <a class='str-ref' href='#Sproc'>proc</a>-&gt;<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>.</span><a name='ANSEGS'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANSEGS'>NSEGS</a>     7

<span class='comment'>// Per-CPU state</span><a name='Scpu'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> {
  uchar id;                    <span class='comment'>// Local APIC <a class='define-ref' href='#AID'>ID</a>; index into cpus[] below</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a> *<a class='func-ref' href='#Fscheduler'>scheduler</a>;   <span class='comment'>// <a class='func-ref' href='#Fswtch'>swtch</a>() here to enter <a class='func-ref' href='#Fscheduler'>scheduler</a></span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Staskstate'>taskstate</a> ts;         <span class='comment'>// Used by x86 to find stack <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> interrupt</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Ssegdesc'>segdesc</a> <a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>[<a class='define-ref' href='#ANSEGS'>NSEGS</a>];   <span class='comment'>// x86 global descriptor table</span>  volatile uint started;       <span class='comment'>// Has the CPU started?</span>  int ncli;                    <span class='comment'>// Depth of <a class='func-ref' href='#Fpushcli'>pushcli</a> nesting.</span>  int intena;                  <span class='comment'>// Were interrupts enabled before <a class='func-ref' href='#Fpushcli'>pushcli</a>?</span>  
  <span class='comment'>// Cpu-local storage variables; see below</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> *<a class='str-ref' href='#Scpu'>cpu</a>;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *<a class='str-ref' href='#Sproc'>proc</a>;           <span class='comment'>// The currently-running process.</span>};

<span class='reserved'>extern</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> cpus[<a class='define-ref' href='#ANCPU'>NCPU</a>];
<span class='reserved'>extern</span> int ncpu;

<span class='comment'>// Per-CPU variables, <a class='func-ref' href='#Fholding'>holding</a> pointers to the</span><span class='comment'>// current <a class='str-ref' href='#Scpu'>cpu</a> and to the current process.</span><span class='comment'>// The asm suffix tells gcc to use "%gs:0" to refer to <a class='str-ref' href='#Scpu'>cpu</a></span><span class='comment'>// and "%gs:4" to refer to <a class='str-ref' href='#Sproc'>proc</a>.  <a class='func-ref' href='#Fseginit'>seginit</a> sets up the</span><span class='comment'>// %gs segment register so that %gs refers to the memory</span><span class='comment'>// <a class='func-ref' href='#Fholding'>holding</a> those two variables in the local <a class='str-ref' href='#Scpu'>cpu</a>'s <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a>.</span><span class='comment'>// This is similar to how thread-local variables are implemented</span><span class='comment'>// in thread libraries such as Linux pthreads.</span><span class='reserved'>extern</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> *<a class='str-ref' href='#Scpu'>cpu</a> asm("%gs:0");       <span class='comment'>// &cpus[<a class='func-ref' href='#Fcpunum'>cpunum</a>()]</span><span class='reserved'>extern</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *<a class='str-ref' href='#Sproc'>proc</a> asm("%gs:4");     <span class='comment'>// cpus[<a class='func-ref' href='#Fcpunum'>cpunum</a>()].<a class='str-ref' href='#Sproc'>proc</a></span>
<span class='comment'>//PAGEBREAK: 17</span><span class='comment'>// Saved registers <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> kernel <a class='str-ref' href='#Scontext'>context</a> switches.</span><span class='comment'>// Don't need to save all the segment registers (%cs, etc),</span><span class='comment'>// because they are constant across kernel contexts.</span><span class='comment'>// Don't need to save %eax, %ecx, %edx, because the</span><span class='comment'>// x86 convention is that the caller has saved them.</span><span class='comment'>// Contexts are stored at the bottom of the stack they</span><span class='comment'>// describe; the stack pointer is the address of the <a class='str-ref' href='#Scontext'>context</a>.</span><span class='comment'>// The layout of the <a class='str-ref' href='#Scontext'>context</a> matches the layout of the stack in <a class='page-ref' href='#Iswtch.S'><a class='func-ref' href='#Fswtch'>swtch</a>.S</a></span><span class='comment'>// at the "Switch stacks" comment. Switch doesn't save eip explicitly,</span><span class='comment'>// but it is on the stack and <a class='func-ref' href='#Fallocproc'>allocproc</a>() manipulates it.</span><a name='Scontext'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a> {
  uint edi;
  uint esi;
  uint ebx;
  uint ebp;
  uint eip;
};

enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };

<span class='comment'>// Per-process state</span><a name='Sproc'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> {
  uint sz;                     <span class='comment'>// Size of process memory (bytes)</span>  pde_t* pgdir;                <span class='comment'>// Page table</span>  char *kstack;                <span class='comment'>// Bottom of kernel stack <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> this process</span>  enum procstate state;        <span class='comment'>// Process state</span>  volatile int pid;            <span class='comment'>// Process <a class='define-ref' href='#AID'>ID</a></span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *parent;         <span class='comment'>// Parent process</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Strapframe'>trapframe</a> *tf;        <span class='comment'>// Trap frame <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> current <a class='func-ref' href='#Fsyscall'>syscall</a></span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a> *<a class='str-ref' href='#Scontext'>context</a>;     <span class='comment'>// <a class='func-ref' href='#Fswtch'>swtch</a>() here to <a class='str-ref' href='#Srun'>run</a> process</span>  void *chan;                  <span class='comment'>// If non-zero, sleeping on chan</span>  int killed;                  <span class='comment'>// If non-zero, have been killed</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *ofile[<a class='define-ref' href='#ANOFILE'>NOFILE</a>];  <span class='comment'>// Open files</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *cwd;           <span class='comment'>// Current directory</span>  char name[16];               <span class='comment'>// Process name (debugging)</span>};

<span class='comment'>// Process memory is laid out contiguously, low addresses first:</span><span class='comment'>//   text</span><span class='comment'>//   original data and bss</span><span class='comment'>//   fixed-size stack</span><span class='comment'>//   expandable heap</span>


<hr/><a name='Iproc.c'>###### <a class='page-ref' href='#Iproc.c'><a class='str-ref' href='#Sproc'>proc</a>.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"

<a name='Sptable'></a><span class='reserved'>struct</span> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> <a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>];
} <a class='str-ref' href='#Sptable'>ptable</a>;

<span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *initproc;

int nextpid = 1;
<span class='reserved'>extern</span> void <a class='func-ref' href='#Fforkret'>forkret</a>(void);
<span class='reserved'>extern</span> void <a class='func-ref' href='#Ftrapret'>trapret</a>(void);

<span class='reserved'>static</span> void <a class='func-ref' href='#Fwakeup1'>wakeup1</a>(void *chan);

void
<a name='Fpinit'><a class='func-ref' href='#Fpinit'>pinit</a></a>(void)
{
  <a class='func-ref' href='#Finitlock'>initlock</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock, "<a class='str-ref' href='#Sptable'>ptable</a>");
}

<span class='comment'>//PAGEBREAK: 32</span><span class='comment'>// Look in the process table <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> an UNUSED <a class='str-ref' href='#Sproc'>proc</a>.</span><span class='comment'>// If <a class='func-ref' href='#Ffound'>found</a>, change state to EMBRYO and initialize</span><span class='comment'>// state required to <a class='str-ref' href='#Srun'>run</a> in the kernel.</span><span class='comment'>// Otherwise <span class='reserved'>return</span> 0.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a>*
<a name='Fallocproc'><a class='func-ref' href='#Fallocproc'>allocproc</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;
  char *sp;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = <a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>; p &lt; &<a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>]; p++)
    <span class='reserved'>if</span>(p-&gt;state == UNUSED)
      goto <a class='func-ref' href='#Ffound'>found</a>;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
  <span class='reserved'>return</span> 0;

<a name='Ffound'><a class='func-ref' href='#Ffound'>found</a></a>:
  p-&gt;state = EMBRYO;
  p-&gt;pid = nextpid++;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);

  <span class='comment'>// Allocate kernel stack.</span>  <span class='reserved'>if</span>((p-&gt;kstack = <a class='func-ref' href='#Fkalloc'>kalloc</a>()) == 0){
    p-&gt;state = UNUSED;
    <span class='reserved'>return</span> 0;
  }
  sp = p-&gt;kstack + <a class='define-ref' href='#AKSTACKSIZE'>KSTACKSIZE</a>;
  
  <span class='comment'>// Leave room <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> <a class='func-ref' href='#Ftrap'>trap</a> frame.</span>  sp -= sizeof *p-&gt;tf;
  p-&gt;tf = (<span class='reserved'>struct</span> <a class='str-ref' href='#Strapframe'>trapframe</a>*)sp;
  
  <span class='comment'>// Set up new <a class='str-ref' href='#Scontext'>context</a> to <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> executing at <a class='func-ref' href='#Fforkret'>forkret</a>,</span>  <span class='comment'>// which returns to <a class='func-ref' href='#Ftrapret'>trapret</a>.</span>  sp -= 4;
  *(uint*)sp = (uint)<a class='func-ref' href='#Ftrapret'>trapret</a>;

  sp -= sizeof *p-&gt;<a class='str-ref' href='#Scontext'>context</a>;
  p-&gt;<a class='str-ref' href='#Scontext'>context</a> = (<span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a>*)sp;
  <a class='func-ref' href='#Fmemset'>memset</a>(p-&gt;<a class='str-ref' href='#Scontext'>context</a>, 0, sizeof *p-&gt;<a class='str-ref' href='#Scontext'>context</a>);
  p-&gt;<a class='str-ref' href='#Scontext'>context</a>-&gt;eip = (uint)<a class='func-ref' href='#Fforkret'>forkret</a>;

  <span class='reserved'>return</span> p;
}

<span class='comment'>//PAGEBREAK: 32</span><span class='comment'>// Set up first user process.</span>void
<a name='Fuserinit'><a class='func-ref' href='#Fuserinit'>userinit</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;
  <span class='reserved'>extern</span> char _binary_initcode_start[], _binary_initcode_size[];
  
  p = <a class='func-ref' href='#Fallocproc'>allocproc</a>();
  initproc = p;
  <span class='reserved'>if</span>((p-&gt;pgdir = <a class='func-ref' href='#Fsetupkvm'>setupkvm</a>()) == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fuserinit'>userinit</a>: out of memory?");
  <a class='func-ref' href='#Finituvm'>inituvm</a>(p-&gt;pgdir, _binary_initcode_start, (int)_binary_initcode_size);
  p-&gt;sz = <a class='define-ref' href='#APGSIZE'>PGSIZE</a>;
  <a class='func-ref' href='#Fmemset'>memset</a>(p-&gt;tf, 0, sizeof(*p-&gt;tf));
  p-&gt;tf-&gt;cs = (<a class='define-ref' href='#ASEG_UCODE'>SEG_UCODE</a> &lt;&lt; 3) | <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>;
  p-&gt;tf-&gt;ds = (<a class='define-ref' href='#ASEG_UDATA'>SEG_UDATA</a> &lt;&lt; 3) | <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>;
  p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;
  p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;
  p-&gt;tf-&gt;eflags = <a class='define-ref' href='#AFL_IF'>FL_IF</a>;
  p-&gt;tf-&gt;esp = <a class='define-ref' href='#APGSIZE'>PGSIZE</a>;
  p-&gt;tf-&gt;eip = 0;  <span class='comment'>// beginning of <a class='page-ref' href='#Iinitcode.S'>initcode.S</a></span>
  <a class='func-ref' href='#Fsafestrcpy'>safestrcpy</a>(p-&gt;name, "initcode", sizeof(p-&gt;name));
  p-&gt;cwd = <a class='func-ref' href='#Fnamei'>namei</a>("/");

  p-&gt;state = RUNNABLE;
}

<span class='comment'>// Grow current process's memory by n bytes.</span><span class='comment'>// Return 0 on success, -1 on failure.</span>int
<a name='Fgrowproc'><a class='func-ref' href='#Fgrowproc'>growproc</a></a>(int n)
{
  uint sz;
  
  sz = <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz;
  <span class='reserved'>if</span>(n &gt; 0){
    <span class='reserved'>if</span>((sz = <a class='func-ref' href='#Fallocuvm'>allocuvm</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;pgdir, sz, sz + n)) == 0)
      <span class='reserved'>return</span> -1;
  } <span class='reserved'>else</span> <span class='reserved'>if</span>(n &lt; 0){
    <span class='reserved'>if</span>((sz = <a class='func-ref' href='#Fdeallocuvm'>deallocuvm</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;pgdir, sz, sz + n)) == 0)
      <span class='reserved'>return</span> -1;
  }
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz = sz;
  <a class='func-ref' href='#Fswitchuvm'>switchuvm</a>(<a class='str-ref' href='#Sproc'>proc</a>);
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Create a new process copying p as the parent.</span><span class='comment'>// Sets up stack to <span class='reserved'>return</span> as <span class='reserved'>if</span> from system call.</span><span class='comment'>// Caller must set state of returned <a class='str-ref' href='#Sproc'>proc</a> to RUNNABLE.</span>int
<a name='Ffork'><a class='func-ref' href='#Ffork'>fork</a></a>(void)
{
  int i, pid;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *np;

  <span class='comment'>// Allocate process.</span>  <span class='reserved'>if</span>((np = <a class='func-ref' href='#Fallocproc'>allocproc</a>()) == 0)
    <span class='reserved'>return</span> -1;

  <span class='comment'>// Copy process state from p.</span>  <span class='reserved'>if</span>((np-&gt;pgdir = <a class='func-ref' href='#Fcopyuvm'>copyuvm</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;pgdir, <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz)) == 0){
    <a class='func-ref' href='#Fkfree'>kfree</a>(np-&gt;kstack);
    np-&gt;kstack = 0;
    np-&gt;state = UNUSED;
    <span class='reserved'>return</span> -1;
  }
  np-&gt;sz = <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz;
  np-&gt;parent = <a class='str-ref' href='#Sproc'>proc</a>;
  *np-&gt;tf = *<a class='str-ref' href='#Sproc'>proc</a>-&gt;tf;

  <span class='comment'>// Clear %eax so that <a class='func-ref' href='#Ffork'>fork</a> returns 0 in the child.</span>  np-&gt;tf-&gt;eax = 0;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; <a class='define-ref' href='#ANOFILE'>NOFILE</a>; i++)
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[i])
      np-&gt;ofile[i] = <a class='func-ref' href='#Ffiledup'>filedup</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[i]);
  np-&gt;cwd = <a class='func-ref' href='#Fidup'>idup</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;cwd);
 
  pid = np-&gt;pid;
  np-&gt;state = RUNNABLE;
  <a class='func-ref' href='#Fsafestrcpy'>safestrcpy</a>(np-&gt;name, <a class='str-ref' href='#Sproc'>proc</a>-&gt;name, sizeof(<a class='str-ref' href='#Sproc'>proc</a>-&gt;name));
  <span class='reserved'>return</span> pid;
}

<span class='comment'>// Exit the current process.  Does not <span class='reserved'>return</span>.</span><span class='comment'>// An exited process remains in the zombie state</span><span class='comment'>// until its parent calls <a class='func-ref' href='#Fwait'>wait</a>() to find out it exited.</span>void
<a name='Fexit'><a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;
  int fd;

  <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a> == initproc)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Finit'>init</a> exiting");

  <span class='comment'>// Close all open files.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(fd = 0; fd &lt; <a class='define-ref' href='#ANOFILE'>NOFILE</a>; fd++){
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd]){
      <a class='func-ref' href='#Ffileclose'>fileclose</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd]);
      <a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd] = 0;
    }
  }

  <a class='func-ref' href='#Fiput'>iput</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;cwd);
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;cwd = 0;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);

  <span class='comment'>// Parent might be sleeping in <a class='func-ref' href='#Fwait'>wait</a>().</span>  <a class='func-ref' href='#Fwakeup1'>wakeup1</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;parent);

  <span class='comment'>// Pass abandoned children to <a class='func-ref' href='#Finit'>init</a>.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = <a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>; p &lt; &<a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>]; p++){
    <span class='reserved'>if</span>(p-&gt;parent == <a class='str-ref' href='#Sproc'>proc</a>){
      p-&gt;parent = initproc;
      <span class='reserved'>if</span>(p-&gt;state == ZOMBIE)
        <a class='func-ref' href='#Fwakeup1'>wakeup1</a>(initproc);
    }
  }

  <span class='comment'>// Jump into the <a class='func-ref' href='#Fscheduler'>scheduler</a>, never to <span class='reserved'>return</span>.</span>  <a class='str-ref' href='#Sproc'>proc</a>-&gt;state = ZOMBIE;
  <a class='func-ref' href='#Fsched'>sched</a>();
  <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("zombie <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>");
}

<span class='comment'>// Wait <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a child process to <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a> and <span class='reserved'>return</span> its pid.</span><span class='comment'>// Return -1 <span class='reserved'>if</span> this process has no children.</span>int
<a name='Fwait'><a class='func-ref' href='#Fwait'>wait</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;
  int havekids, pid;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(;;){
    <span class='comment'>// Scan through table looking <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> zombie children.</span>    havekids = 0;
    <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = <a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>; p &lt; &<a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>]; p++){
      <span class='reserved'>if</span>(p-&gt;parent != <a class='str-ref' href='#Sproc'>proc</a>)
        continue;
      havekids = 1;
      <span class='reserved'>if</span>(p-&gt;state == ZOMBIE){
        <span class='comment'>// Found one.</span>        pid = p-&gt;pid;
        <a class='func-ref' href='#Fkfree'>kfree</a>(p-&gt;kstack);
        p-&gt;kstack = 0;
        <a class='func-ref' href='#Ffreevm'>freevm</a>(p-&gt;pgdir);
        p-&gt;state = UNUSED;
        p-&gt;pid = 0;
        p-&gt;parent = 0;
        p-&gt;name[0] = 0;
        p-&gt;killed = 0;
        <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
        <span class='reserved'>return</span> pid;
      }
    }

    <span class='comment'>// No point waiting <span class='reserved'>if</span> we don't have any children.</span>    <span class='reserved'>if</span>(!havekids || <a class='str-ref' href='#Sproc'>proc</a>-&gt;killed){
      <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
      <span class='reserved'>return</span> -1;
    }

    <span class='comment'>// Wait <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> children to <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>.  (See <a class='func-ref' href='#Fwakeup1'>wakeup1</a> call in proc_exit.)</span>    <a class='func-ref' href='#Fsleep'>sleep</a>(<a class='str-ref' href='#Sproc'>proc</a>, &<a class='str-ref' href='#Sptable'>ptable</a>.lock);  <span class='comment'>//DOC: <a class='func-ref' href='#Fwait'>wait</a>-<a class='func-ref' href='#Fsleep'>sleep</a></span>  }
}

<span class='comment'>//PAGEBREAK: 42</span><span class='comment'>// Per-CPU process <a class='func-ref' href='#Fscheduler'>scheduler</a>.</span><span class='comment'>// Each CPU calls <a class='func-ref' href='#Fscheduler'>scheduler</a>() after setting itself up.</span><span class='comment'>// Scheduler never returns.  It loops, doing:</span><span class='comment'>//  - choose a process to <a class='str-ref' href='#Srun'>run</a></span><span class='comment'>//  - <a class='func-ref' href='#Fswtch'>swtch</a> to <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> running that process</span><span class='comment'>//  - eventually that process transfers control</span><span class='comment'>//      via <a class='func-ref' href='#Fswtch'>swtch</a> back to the <a class='func-ref' href='#Fscheduler'>scheduler</a>.</span>void
<a name='Fscheduler'><a class='func-ref' href='#Fscheduler'>scheduler</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(;;){
    <span class='comment'>// Enable interrupts on this processor.</span>    <a class='func-ref' href='#Fsti'>sti</a>();

    <span class='comment'>// Loop over process table looking <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> process to <a class='str-ref' href='#Srun'>run</a>.</span>    <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
    <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = <a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>; p &lt; &<a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>]; p++){
      <span class='reserved'>if</span>(p-&gt;state != RUNNABLE)
        continue;

      <span class='comment'>// Switch to chosen process.  It is the process's job</span>      <span class='comment'>// to <a class='func-ref' href='#Frelease'>release</a> <a class='str-ref' href='#Sptable'>ptable</a>.lock and then reacquire it</span>      <span class='comment'>// before jumping back to us.</span>      <a class='str-ref' href='#Sproc'>proc</a> = p;
      <a class='func-ref' href='#Fswitchuvm'>switchuvm</a>(p);
      p-&gt;state = RUNNING;
      <a class='func-ref' href='#Fswtch'>swtch</a>(&<a class='str-ref' href='#Scpu'>cpu</a>-&gt;<a class='func-ref' href='#Fscheduler'>scheduler</a>, <a class='str-ref' href='#Sproc'>proc</a>-&gt;<a class='str-ref' href='#Scontext'>context</a>);
      <a class='func-ref' href='#Fswitchkvm'>switchkvm</a>();

      <span class='comment'>// Process is done running <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> now.</span>      <span class='comment'>// It should have changed its p-&gt;state before coming back.</span>      <a class='str-ref' href='#Sproc'>proc</a> = 0;
    }
    <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);

  }
}

<span class='comment'>// Enter <a class='func-ref' href='#Fscheduler'>scheduler</a>.  Must hold only <a class='str-ref' href='#Sptable'>ptable</a>.lock</span><span class='comment'>// and have changed <a class='str-ref' href='#Sproc'>proc</a>-&gt;state.</span>void
<a name='Fsched'><a class='func-ref' href='#Fsched'>sched</a></a>(void)
{
  int intena;

  <span class='reserved'>if</span>(!<a class='func-ref' href='#Fholding'>holding</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fsched'>sched</a> <a class='str-ref' href='#Sptable'>ptable</a>.lock");
  <span class='reserved'>if</span>(<a class='str-ref' href='#Scpu'>cpu</a>-&gt;ncli != 1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fsched'>sched</a> locks");
  <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;state == RUNNING)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fsched'>sched</a> running");
  <span class='reserved'>if</span>(<a class='func-ref' href='#Freadeflags'>readeflags</a>()&<a class='define-ref' href='#AFL_IF'>FL_IF</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fsched'>sched</a> interruptible");
  intena = <a class='str-ref' href='#Scpu'>cpu</a>-&gt;intena;
  <a class='func-ref' href='#Fswtch'>swtch</a>(&<a class='str-ref' href='#Sproc'>proc</a>-&gt;<a class='str-ref' href='#Scontext'>context</a>, <a class='str-ref' href='#Scpu'>cpu</a>-&gt;<a class='func-ref' href='#Fscheduler'>scheduler</a>);
  <a class='str-ref' href='#Scpu'>cpu</a>-&gt;intena = intena;
}

<span class='comment'>// Give up the CPU <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> one scheduling round.</span>void
<a name='Fyield'><a class='func-ref' href='#Fyield'>yield</a></a>(void)
{
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);  <span class='comment'>//DOC: yieldlock</span>  <a class='str-ref' href='#Sproc'>proc</a>-&gt;state = RUNNABLE;
  <a class='func-ref' href='#Fsched'>sched</a>();
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
}

<span class='comment'>// A <a class='func-ref' href='#Ffork'>fork</a> child's very first scheduling by <a class='func-ref' href='#Fscheduler'>scheduler</a>()</span><span class='comment'>// will <a class='func-ref' href='#Fswtch'>swtch</a> here.  "Return" to user space.</span>void
<a name='Fforkret'><a class='func-ref' href='#Fforkret'>forkret</a></a>(void)
{
  <span class='reserved'>static</span> int first = 1;
  <span class='comment'>// Still <a class='func-ref' href='#Fholding'>holding</a> <a class='str-ref' href='#Sptable'>ptable</a>.lock from <a class='func-ref' href='#Fscheduler'>scheduler</a>.</span>  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);

  <span class='reserved'>if</span> (first) {
    <span class='comment'>// Some initialization functions must be <a class='str-ref' href='#Srun'>run</a> in the <a class='str-ref' href='#Scontext'>context</a></span>    <span class='comment'>// of a regular process (e.g., they call <a class='func-ref' href='#Fsleep'>sleep</a>), and thus cannot </span>    <span class='comment'>// be <a class='str-ref' href='#Srun'>run</a> from <a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a>().</span>    first = 0;
    <a class='func-ref' href='#Finitlog'>initlog</a>();
  }
  
  <span class='comment'>// Return to "caller", actually <a class='func-ref' href='#Ftrapret'>trapret</a> (see <a class='func-ref' href='#Fallocproc'>allocproc</a>).</span>}

<span class='comment'>// Atomically <a class='func-ref' href='#Frelease'>release</a> lock and <a class='func-ref' href='#Fsleep'>sleep</a> on chan.</span><span class='comment'>// Reacquires lock when awakened.</span>void
<a name='Fsleep'><a class='func-ref' href='#Fsleep'>sleep</a></a>(void *chan, <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> *lk)
{
  <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a> == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fsleep'>sleep</a>");

  <span class='reserved'>if</span>(lk == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fsleep'>sleep</a> without lk");

  <span class='comment'>// Must <a class='func-ref' href='#Facquire'>acquire</a> <a class='str-ref' href='#Sptable'>ptable</a>.lock in order to</span>  <span class='comment'>// change p-&gt;state and then call <a class='func-ref' href='#Fsched'>sched</a>.</span>  <span class='comment'>// Once we hold <a class='str-ref' href='#Sptable'>ptable</a>.lock, we can be</span>  <span class='comment'>// guaranteed that we won't miss any <a class='func-ref' href='#Fwakeup'>wakeup</a></span>  <span class='comment'>// (<a class='func-ref' href='#Fwakeup'>wakeup</a> runs with <a class='str-ref' href='#Sptable'>ptable</a>.lock locked),</span>  <span class='comment'>// so it's okay to <a class='func-ref' href='#Frelease'>release</a> lk.</span>  <span class='reserved'>if</span>(lk != &<a class='str-ref' href='#Sptable'>ptable</a>.lock){  <span class='comment'>//DOC: sleeplock0</span>    <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);  <span class='comment'>//DOC: sleeplock1</span>    <a class='func-ref' href='#Frelease'>release</a>(lk);
  }

  <span class='comment'>// Go to <a class='func-ref' href='#Fsleep'>sleep</a>.</span>  <a class='str-ref' href='#Sproc'>proc</a>-&gt;chan = chan;
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;state = SLEEPING;
  <a class='func-ref' href='#Fsched'>sched</a>();

  <span class='comment'>// Tidy up.</span>  <a class='str-ref' href='#Sproc'>proc</a>-&gt;chan = 0;

  <span class='comment'>// Reacquire original lock.</span>  <span class='reserved'>if</span>(lk != &<a class='str-ref' href='#Sptable'>ptable</a>.lock){  <span class='comment'>//DOC: sleeplock2</span>    <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
    <a class='func-ref' href='#Facquire'>acquire</a>(lk);
  }
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Wake up all processes sleeping on chan.</span><span class='comment'>// The <a class='str-ref' href='#Sptable'>ptable</a> lock must be held.</span><span class='reserved'>static</span> void
<a name='Fwakeup1'><a class='func-ref' href='#Fwakeup1'>wakeup1</a></a>(void *chan)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = <a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>; p &lt; &<a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>]; p++)
    <span class='reserved'>if</span>(p-&gt;state == SLEEPING && p-&gt;chan == chan)
      p-&gt;state = RUNNABLE;
}

<span class='comment'>// Wake up all processes sleeping on chan.</span>void
<a name='Fwakeup'><a class='func-ref' href='#Fwakeup'>wakeup</a></a>(void *chan)
{
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
  <a class='func-ref' href='#Fwakeup1'>wakeup1</a>(chan);
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
}

<span class='comment'>// Kill the process with the given pid.</span><span class='comment'>// Process won't <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a> until it returns</span><span class='comment'>// to user space (see <a class='func-ref' href='#Ftrap'>trap</a> in <a class='page-ref' href='#Itrap.c'><a class='func-ref' href='#Ftrap'>trap</a>.c</a>).</span>int
<a name='Fkill'><a class='func-ref' href='#Fkill'>kill</a></a>(int pid)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = <a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>; p &lt; &<a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>]; p++){
    <span class='reserved'>if</span>(p-&gt;pid == pid){
      p-&gt;killed = 1;
      <span class='comment'>// Wake process from <a class='func-ref' href='#Fsleep'>sleep</a> <span class='reserved'>if</span> necessary.</span>      <span class='reserved'>if</span>(p-&gt;state == SLEEPING)
        p-&gt;state = RUNNABLE;
      <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
      <span class='reserved'>return</span> 0;
    }
  }
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sptable'>ptable</a>.lock);
  <span class='reserved'>return</span> -1;
}

<span class='comment'>//PAGEBREAK: 36</span><span class='comment'>// Print a process listing to console.  For debugging.</span><span class='comment'>// Runs when user types ^P on console.</span><span class='comment'>// No lock to avoid wedging a stuck machine further.</span>void
<a name='Fprocdump'><a class='func-ref' href='#Fprocdump'>procdump</a></a>(void)
{
  <span class='reserved'>static</span> char *states[] = {
  [UNUSED]    "unused",
  [EMBRYO]    "embryo",
  [SLEEPING]  "<a class='func-ref' href='#Fsleep'>sleep</a> ",
  [RUNNABLE]  "runble",
  [RUNNING]   "<a class='str-ref' href='#Srun'>run</a>   ",
  [ZOMBIE]    "zombie"
  };
  int i;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproc'>proc</a> *p;
  char *state;
  uint pc[10];
  
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = <a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>; p &lt; &<a class='str-ref' href='#Sptable'>ptable</a>.<a class='str-ref' href='#Sproc'>proc</a>[<a class='define-ref' href='#ANPROC'>NPROC</a>]; p++){
    <span class='reserved'>if</span>(p-&gt;state == UNUSED)
      continue;
    <span class='reserved'>if</span>(p-&gt;state &gt;= 0 && p-&gt;state &lt; <a class='define-ref' href='#ANELEM'>NELEM</a>(states) && states[p-&gt;state])
      state = states[p-&gt;state];
    <span class='reserved'>else</span>
      state = "???";
    <a class='func-ref' href='#Fcprintf'>cprintf</a>("%d %s %s", p-&gt;pid, state, p-&gt;name);
    <span class='reserved'>if</span>(p-&gt;state == SLEEPING){
      <a class='func-ref' href='#Fgetcallerpcs'>getcallerpcs</a>((uint*)p-&gt;<a class='str-ref' href='#Scontext'>context</a>-&gt;ebp+2, pc);
      <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i=0; i&lt;10 && pc[i] != 0; i++)
        <a class='func-ref' href='#Fcprintf'>cprintf</a>(" %p", pc[i]);
    }
    <a class='func-ref' href='#Fcprintf'>cprintf</a>("\n");
  }
}





<hr/><a name='Iswtch.S'>###### <a class='page-ref' href='#Iswtch.S'><a class='func-ref' href='#Fswtch'>swtch</a>.S</a> ########</a>

# Context <span class='reserved'>switch</span>
#
#   void <a class='func-ref' href='#Fswtch'>swtch</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a> **old, <span class='reserved'>struct</span> <a class='str-ref' href='#Scontext'>context</a> *new);
# 
# Save current register <a class='str-ref' href='#Scontext'>context</a> in old
# and then load register <a class='str-ref' href='#Scontext'>context</a> from new.

.globl <a class='func-ref' href='#Fswtch'>swtch</a>
<a name='Fswtch'><a class='func-ref' href='#Fswtch'>swtch</a></a>:
  movl 4(%esp), %eax
  movl 8(%esp), %edx

  # Save old callee-save registers
  pushl %ebp
  pushl %ebx
  pushl %esi
  pushl %edi

  # Switch stacks
  movl %esp, (%eax)
  movl %edx, %esp

  # Load new callee-save registers
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret



<hr/><a name='Ikalloc.c'>###### <a class='page-ref' href='#Ikalloc.c'><a class='func-ref' href='#Fkalloc'>kalloc</a>.c</a> ########</a>

<span class='comment'>// Physical memory allocator, intended to allocate</span><span class='comment'>// memory <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> user processes, kernel stacks, page table pages,</span><span class='comment'>// and <a class='str-ref' href='#Spipe'>pipe</a> buffers. Allocates 4096-byte pages.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"

void <a class='func-ref' href='#Ffreerange'>freerange</a>(void *vstart, void *vend);
<span class='reserved'>extern</span> char end[]; <span class='comment'>// first address after kernel loaded from ELF <a class='str-ref' href='#Sfile'>file</a></span>
<a name='Srun'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Srun'>run</a> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Srun'>run</a> *next;
};

<a name='Skmem'></a><span class='reserved'>struct</span> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  int use_lock;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Srun'>run</a> *freelist;
} <a class='str-ref' href='#Skmem'>kmem</a>;

<span class='comment'>// Initialization happens in two phases.</span><span class='comment'>// 1. <a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a>() calls <a class='func-ref' href='#Fkinit1'>kinit1</a>() <span class='reserved'>while</span> still using entrypgdir to place just</span><span class='comment'>// the pages mapped by entrypgdir on free list.</span><span class='comment'>// 2. <a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a>() calls <a class='func-ref' href='#Fkinit2'>kinit2</a>() with the rest of the physical pages</span><span class='comment'>// after installing a full page table that maps them on all cores.</span>void
<a name='Fkinit1'><a class='func-ref' href='#Fkinit1'>kinit1</a></a>(void *vstart, void *vend)
{
  <a class='func-ref' href='#Finitlock'>initlock</a>(&<a class='str-ref' href='#Skmem'>kmem</a>.lock, "<a class='str-ref' href='#Skmem'>kmem</a>");
  <a class='str-ref' href='#Skmem'>kmem</a>.use_lock = 0;
  <a class='func-ref' href='#Ffreerange'>freerange</a>(vstart, vend);
}

void
<a name='Fkinit2'><a class='func-ref' href='#Fkinit2'>kinit2</a></a>(void *vstart, void *vend)
{
  <a class='func-ref' href='#Ffreerange'>freerange</a>(vstart, vend);
  <a class='str-ref' href='#Skmem'>kmem</a>.use_lock = 1;
}

void
<a name='Ffreerange'><a class='func-ref' href='#Ffreerange'>freerange</a></a>(void *vstart, void *vend)
{
  char *p;
  p = (char*)<a class='define-ref' href='#APGROUNDUP'>PGROUNDUP</a>((uint)vstart);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(; p + <a class='define-ref' href='#APGSIZE'>PGSIZE</a> &lt;= (char*)vend; p += <a class='define-ref' href='#APGSIZE'>PGSIZE</a>)
    <a class='func-ref' href='#Fkfree'>kfree</a>(p);
}

<span class='comment'>//PAGEBREAK: 21</span><span class='comment'>// Free the page of physical memory pointed at by v,</span><span class='comment'>// which normally should have been returned by a</span><span class='comment'>// call to <a class='func-ref' href='#Fkalloc'>kalloc</a>().  (The exception is when</span><span class='comment'>// initializing the allocator; see kinit above.)</span>void
<a name='Fkfree'><a class='func-ref' href='#Fkfree'>kfree</a></a>(char *v)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Srun'>run</a> *r;

  <span class='reserved'>if</span>((uint)v % <a class='define-ref' href='#APGSIZE'>PGSIZE</a> || v &lt; end || v2p(v) &gt;= <a class='define-ref' href='#APHYSTOP'>PHYSTOP</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fkfree'>kfree</a>");

  <span class='comment'>// Fill with junk to catch dangling refs.</span>  <a class='func-ref' href='#Fmemset'>memset</a>(v, 1, <a class='define-ref' href='#APGSIZE'>PGSIZE</a>);

  <span class='reserved'>if</span>(<a class='str-ref' href='#Skmem'>kmem</a>.use_lock)
    <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Skmem'>kmem</a>.lock);
  r = (<span class='reserved'>struct</span> <a class='str-ref' href='#Srun'>run</a>*)v;
  r-&gt;next = <a class='str-ref' href='#Skmem'>kmem</a>.freelist;
  <a class='str-ref' href='#Skmem'>kmem</a>.freelist = r;
  <span class='reserved'>if</span>(<a class='str-ref' href='#Skmem'>kmem</a>.use_lock)
    <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Skmem'>kmem</a>.lock);
}

<span class='comment'>// Allocate one 4096-byte page of physical memory.</span><span class='comment'>// Returns a pointer that the kernel can use.</span><span class='comment'>// Returns 0 <span class='reserved'>if</span> the memory cannot be allocated.</span>char*
<a name='Fkalloc'><a class='func-ref' href='#Fkalloc'>kalloc</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Srun'>run</a> *r;

  <span class='reserved'>if</span>(<a class='str-ref' href='#Skmem'>kmem</a>.use_lock)
    <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Skmem'>kmem</a>.lock);
  r = <a class='str-ref' href='#Skmem'>kmem</a>.freelist;
  <span class='reserved'>if</span>(r)
    <a class='str-ref' href='#Skmem'>kmem</a>.freelist = r-&gt;next;
  <span class='reserved'>if</span>(<a class='str-ref' href='#Skmem'>kmem</a>.use_lock)
    <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Skmem'>kmem</a>.lock);
  <span class='reserved'>return</span> (char*)r;
}




<hr/><a name='Itraps.h'>###### <a class='page-ref' href='#Itraps.h'>traps.h</a> ########</a>

<span class='comment'>// x86 <a class='func-ref' href='#Ftrap'>trap</a> and interrupt constants.</span>
<span class='comment'>// Processor-defined:</span><a name='AT_DIVIDE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_DIVIDE'>T_DIVIDE</a>         0      <span class='comment'>// divide error</span><a name='AT_DEBUG'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_DEBUG'>T_DEBUG</a>          1      <span class='comment'>// debug exception</span><a name='AT_NMI'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_NMI'>T_NMI</a>            2      <span class='comment'>// non-maskable interrupt</span><a name='AT_BRKPT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_BRKPT'>T_BRKPT</a>          3      <span class='comment'>// breakpoint</span><a name='AT_OFLOW'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_OFLOW'>T_OFLOW</a>          4      <span class='comment'>// overflow</span><a name='AT_BOUND'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_BOUND'>T_BOUND</a>          5      <span class='comment'>// bounds check</span><a name='AT_ILLOP'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_ILLOP'>T_ILLOP</a>          6      <span class='comment'>// illegal opcode</span><a name='AT_DEVICE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_DEVICE'>T_DEVICE</a>         7      <span class='comment'>// device not available</span><a name='AT_DBLFLT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_DBLFLT'>T_DBLFLT</a>         8      <span class='comment'>// double fault</span><span class='comment'>// <a name='AT_COPROC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_COPROC'>T_COPROC</a>      9      // reserved (not used since 486)</span><a name='AT_TSS'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_TSS'>T_TSS</a>           10      <span class='comment'>// invalid task <span class='reserved'>switch</span> segment</span><a name='AT_SEGNP'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_SEGNP'>T_SEGNP</a>         11      <span class='comment'>// segment not present</span><a name='AT_STACK'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_STACK'>T_STACK</a>         12      <span class='comment'>// stack exception</span><a name='AT_GPFLT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_GPFLT'>T_GPFLT</a>         13      <span class='comment'>// general protection fault</span><a name='AT_PGFLT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_PGFLT'>T_PGFLT</a>         14      <span class='comment'>// page fault</span><span class='comment'>// <a name='AT_RES'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_RES'>T_RES</a>        15      // reserved</span><a name='AT_FPERR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_FPERR'>T_FPERR</a>         16      <span class='comment'>// floating point error</span><a name='AT_ALIGN'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_ALIGN'>T_ALIGN</a>         17      <span class='comment'>// aligment check</span><a name='AT_MCHK'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_MCHK'>T_MCHK</a>          18      <span class='comment'>// machine check</span><a name='AT_SIMDERR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_SIMDERR'>T_SIMDERR</a>       19      <span class='comment'>// SIMD floating point error</span>
<span class='comment'>// These are arbitrarily chosen, but with care not to overlap</span><span class='comment'>// processor defined exceptions or interrupt vectors.</span><a name='AT_SYSCALL'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>       64      <span class='comment'>// system call</span><a name='AT_DEFAULT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_DEFAULT'>T_DEFAULT</a>      500      <span class='comment'>// catchall</span>
<a name='AT_IRQ0'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a>          32      <span class='comment'>// IRQ 0 corresponds to int T_IRQ</span>
<a name='AIRQ_TIMER'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIRQ_TIMER'>IRQ_TIMER</a>        0
<a name='AIRQ_KBD'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIRQ_KBD'>IRQ_KBD</a>          1
<a name='AIRQ_COM1'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIRQ_COM1'>IRQ_COM1</a>         4
<a name='AIRQ_IDE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIRQ_IDE'>IRQ_IDE</a>         14
<a name='AIRQ_ERROR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIRQ_ERROR'>IRQ_ERROR</a>       19
<a name='AIRQ_SPURIOUS'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIRQ_SPURIOUS'>IRQ_SPURIOUS</a>    31




<hr/><a name='Ivectors.pl'>###### <a class='page-ref' href='#Ivectors.pl'>vectors.pl</a> ########</a>

#!/usr/bin/perl -w

# Generate vectors.S, the <a class='func-ref' href='#Ftrap'>trap</a>/interrupt <a class='func-ref' href='#Fentry'>entry</a> points.
# There has to be one <a class='func-ref' href='#Fentry'>entry</a> point per interrupt number
# since otherwise there's no way <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> <a class='func-ref' href='#Ftrap'>trap</a>() to discover
# the interrupt number.

print "# generated by <a class='page-ref' href='#Ivectors.pl'>vectors.pl</a> - do not edit\n";
print "# handlers\n";
print ".globl <a class='func-ref' href='#Falltraps'>alltraps</a>\n";
<a name='Ffor'><a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a></a>(my $i = 0; $i &lt; 256; $i++){
    print ".globl vector$i\n";
    print "vector$i:\n";
    <span class='reserved'>if</span>(!($i == 8 || ($i &gt;= 10 && $i &lt;= 14) || $i == 17)){
        print "  pushl \$0\n";
    }
    print "  pushl \$$i\n";
    print "  jmp <a class='func-ref' href='#Falltraps'>alltraps</a>\n";
}

print "\n# vector table\n";
print ".data\n";
print ".globl vectors\n";
print "vectors:\n";
<a name='Ffor'><a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a></a>(my $i = 0; $i &lt; 256; $i++){
    print "  .long vector$i\n";
}

# sample output:
#   # handlers
#   .globl <a class='func-ref' href='#Falltraps'>alltraps</a>
#   .globl vector0
#   vector0:
#     pushl $0
#     pushl $0
#     jmp <a class='func-ref' href='#Falltraps'>alltraps</a>
#   ...
#   
#   # vector table
#   .data
#   .globl vectors
#   vectors:
#     .long vector0
#     .long vector1
#     .long vector2
#   ...




<hr/><a name='Itrapasm.S'>###### <a class='page-ref' href='#Itrapasm.S'>trapasm.S</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"

  # vectors.S sends all traps here.
.globl <a class='func-ref' href='#Falltraps'>alltraps</a>
<a name='Falltraps'><a class='func-ref' href='#Falltraps'>alltraps</a></a>:
  # Build <a class='func-ref' href='#Ftrap'>trap</a> frame.
  pushl %ds
  pushl %es
  pushl %fs
  pushl %gs
  pushal
  
  # Set up data and per-<a class='str-ref' href='#Scpu'>cpu</a> segments.
  movw $(<a class='define-ref' href='#ASEG_KDATA'>SEG_KDATA</a>&lt;&lt;3), %ax
  movw %ax, %ds
  movw %ax, %es
  movw $(<a class='define-ref' href='#ASEG_KCPU'>SEG_KCPU</a>&lt;&lt;3), %ax
  movw %ax, %fs
  movw %ax, %gs

  # Call <a class='func-ref' href='#Ftrap'>trap</a>(tf), where tf=%esp
  pushl %esp
  call <a class='func-ref' href='#Ftrap'>trap</a>
  addl $4, %esp

  # Return falls through to <a class='func-ref' href='#Ftrapret'>trapret</a>...
.globl <a class='func-ref' href='#Ftrapret'>trapret</a>
<a name='Ftrapret'><a class='func-ref' href='#Ftrapret'>trapret</a></a>:
  popal
  popl %gs
  popl %fs
  popl %es
  popl %ds
  addl $0x8, %esp  # trapno and errcode
  iret



<hr/><a name='Itrap.c'>###### <a class='page-ref' href='#Itrap.c'><a class='func-ref' href='#Ftrap'>trap</a>.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"

<span class='comment'>// Interrupt descriptor table (shared by all CPUs).</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sgatedesc'>gatedesc</a> idt[256];
<span class='reserved'>extern</span> uint vectors[];  <span class='comment'>// in vectors.S: array of 256 <a class='func-ref' href='#Fentry'>entry</a> pointers</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> tickslock;
uint ticks;

void
<a name='Ftvinit'><a class='func-ref' href='#Ftvinit'>tvinit</a></a>(void)
{
  int i;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; 256; i++)
    <a class='define-ref' href='#ASETGATE'>SETGATE</a>(idt[i], 0, <a class='define-ref' href='#ASEG_KCODE'>SEG_KCODE</a>&lt;&lt;3, vectors[i], 0);
  <a class='define-ref' href='#ASETGATE'>SETGATE</a>(idt[<a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>], 1, <a class='define-ref' href='#ASEG_KCODE'>SEG_KCODE</a>&lt;&lt;3, vectors[<a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>], <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>);
  
  <a class='func-ref' href='#Finitlock'>initlock</a>(&tickslock, "time");
}

void
<a name='Fidtinit'><a class='func-ref' href='#Fidtinit'>idtinit</a></a>(void)
{
  <a class='func-ref' href='#Flidt'>lidt</a>(idt, sizeof(idt));
}

<span class='comment'>//PAGEBREAK: 41</span>void
<a name='Ftrap'><a class='func-ref' href='#Ftrap'>trap</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Strapframe'>trapframe</a> *tf)
{
  <span class='reserved'>if</span>(tf-&gt;trapno == <a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>){
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;killed)
      <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
    <a class='str-ref' href='#Sproc'>proc</a>-&gt;tf = tf;
    <a class='func-ref' href='#Fsyscall'>syscall</a>();
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;killed)
      <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
    <span class='reserved'>return</span>;
  }

  <span class='reserved'>switch</span>(tf-&gt;trapno){
  <span class='reserved'>case</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_TIMER'>IRQ_TIMER</a>:
    <span class='reserved'>if</span>(<a class='str-ref' href='#Scpu'>cpu</a>-&gt;id == 0){
      <a class='func-ref' href='#Facquire'>acquire</a>(&tickslock);
      ticks++;
      <a class='func-ref' href='#Fwakeup'>wakeup</a>(&ticks);
      <a class='func-ref' href='#Frelease'>release</a>(&tickslock);
    }
    <a class='func-ref' href='#Flapiceoi'>lapiceoi</a>();
    <span class='reserved'>break</span>;
  <span class='reserved'>case</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_IDE'>IRQ_IDE</a>:
    <a class='func-ref' href='#Fideintr'>ideintr</a>();
    <a class='func-ref' href='#Flapiceoi'>lapiceoi</a>();
    <span class='reserved'>break</span>;
  <span class='reserved'>case</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_IDE'>IRQ_IDE</a>+1:
    <span class='comment'>// Bochs generates spurious IDE1 interrupts.</span>    <span class='reserved'>break</span>;
  <span class='reserved'>case</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_KBD'>IRQ_KBD</a>:
    <a class='func-ref' href='#Fkbdintr'>kbdintr</a>();
    <a class='func-ref' href='#Flapiceoi'>lapiceoi</a>();
    <span class='reserved'>break</span>;
  <span class='reserved'>case</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_COM1'>IRQ_COM1</a>:
    <a class='func-ref' href='#Fuartintr'>uartintr</a>();
    <a class='func-ref' href='#Flapiceoi'>lapiceoi</a>();
    <span class='reserved'>break</span>;
  <span class='reserved'>case</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + 7:
  <span class='reserved'>case</span> <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_SPURIOUS'>IRQ_SPURIOUS</a>:
    <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='str-ref' href='#Scpu'>cpu</a>%d: spurious interrupt at %x:%x\n",
            <a class='str-ref' href='#Scpu'>cpu</a>-&gt;id, tf-&gt;cs, tf-&gt;eip);
    <a class='func-ref' href='#Flapiceoi'>lapiceoi</a>();
    <span class='reserved'>break</span>;
   
  <span class='comment'>//PAGEBREAK: 13</span>  <span class='reserved'>default</span>:
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a> == 0 || (tf-&gt;cs&3) == 0){
      <span class='comment'>// In kernel, it must be our mistake.</span>      <a class='func-ref' href='#Fcprintf'>cprintf</a>("unexpected <a class='func-ref' href='#Ftrap'>trap</a> %d from <a class='str-ref' href='#Scpu'>cpu</a> %d eip %x (cr2=0x%x)\n",
              tf-&gt;trapno, <a class='str-ref' href='#Scpu'>cpu</a>-&gt;id, tf-&gt;eip, <a class='func-ref' href='#Frcr2'>rcr2</a>());
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Ftrap'>trap</a>");
    }
    <span class='comment'>// In user space, assume process misbehaved.</span>    <a class='func-ref' href='#Fcprintf'>cprintf</a>("pid %d %s: <a class='func-ref' href='#Ftrap'>trap</a> %d err %d on <a class='str-ref' href='#Scpu'>cpu</a> %d "
            "eip 0x%x addr 0x%x--<a class='func-ref' href='#Fkill'>kill</a> <a class='str-ref' href='#Sproc'>proc</a>\n",
            <a class='str-ref' href='#Sproc'>proc</a>-&gt;pid, <a class='str-ref' href='#Sproc'>proc</a>-&gt;name, tf-&gt;trapno, tf-&gt;err, <a class='str-ref' href='#Scpu'>cpu</a>-&gt;id, tf-&gt;eip, 
            <a class='func-ref' href='#Frcr2'>rcr2</a>());
    <a class='str-ref' href='#Sproc'>proc</a>-&gt;killed = 1;
  }

  <span class='comment'>// Force process <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a> <span class='reserved'>if</span> it has been killed and is in user space.</span>  <span class='comment'>// (If it is still executing in the kernel, let it keep running </span>  <span class='comment'>// until it gets to the regular system call <span class='reserved'>return</span>.)</span>  <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a> && <a class='str-ref' href='#Sproc'>proc</a>-&gt;killed && (tf-&gt;cs&3) == <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>)
    <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();

  <span class='comment'>// Force process to give up CPU on clock tick.</span>  <span class='comment'>// If interrupts were on <span class='reserved'>while</span> locks held, would need to check nlock.</span>  <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a> && <a class='str-ref' href='#Sproc'>proc</a>-&gt;state == RUNNING && tf-&gt;trapno == <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a>+<a class='define-ref' href='#AIRQ_TIMER'>IRQ_TIMER</a>)
    <a class='func-ref' href='#Fyield'>yield</a>();

  <span class='comment'>// Check <span class='reserved'>if</span> the process has been killed since we yielded</span>  <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a> && <a class='str-ref' href='#Sproc'>proc</a>-&gt;killed && (tf-&gt;cs&3) == <a class='define-ref' href='#ADPL_USER'>DPL_USER</a>)
    <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
}



<hr/><a name='Isyscall.h'>###### <a class='page-ref' href='#Isyscall.h'><a class='func-ref' href='#Fsyscall'>syscall</a>.h</a> ########</a>

<span class='comment'>// System call numbers</span><a name='ASYS_fork'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_fork'>SYS_fork</a>    1
<a name='ASYS_exit'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_exit'>SYS_exit</a>    2
<a name='ASYS_wait'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_wait'>SYS_wait</a>    3
<a name='ASYS_pipe'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_pipe'>SYS_pipe</a>    4
<a name='ASYS_read'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_read'>SYS_read</a>    5
<a name='ASYS_kill'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_kill'>SYS_kill</a>    6
<a name='ASYS_exec'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_exec'>SYS_exec</a>    7
<a name='ASYS_fstat'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_fstat'>SYS_fstat</a>   8
<a name='ASYS_chdir'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_chdir'>SYS_chdir</a>   9
<a name='ASYS_dup'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_dup'>SYS_dup</a>    10
<a name='ASYS_getpid'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_getpid'>SYS_getpid</a> 11
<a name='ASYS_sbrk'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_sbrk'>SYS_sbrk</a>   12
<a name='ASYS_sleep'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_sleep'>SYS_sleep</a>  13
<a name='ASYS_uptime'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_uptime'>SYS_uptime</a> 14
<a name='ASYS_open'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_open'>SYS_open</a>   15
<a name='ASYS_write'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_write'>SYS_write</a>  16
<a name='ASYS_mknod'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_mknod'>SYS_mknod</a>  17
<a name='ASYS_unlink'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_unlink'>SYS_unlink</a> 18
<a name='ASYS_link'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_link'>SYS_link</a>   19
<a name='ASYS_mkdir'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_mkdir'>SYS_mkdir</a>  20
<a name='ASYS_close'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYS_close'>SYS_close</a>  21



<hr/><a name='Isyscall.c'>###### <a class='page-ref' href='#Isyscall.c'><a class='func-ref' href='#Fsyscall'>syscall</a>.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Isyscall.h'><a class='func-ref' href='#Fsyscall'>syscall</a>.h</a>"

<span class='comment'>// User code makes a system call with INT <a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>.</span><span class='comment'>// System call number in %eax.</span><span class='comment'>// Arguments on the stack, from the user call to the <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a></span><span class='comment'>// library system call function. The saved user %esp points</span><span class='comment'>// to a saved program counter, and then the first argument.</span>
<span class='comment'>// Fetch the int at addr from the current process.</span>int
<a name='Ffetchint'><a class='func-ref' href='#Ffetchint'>fetchint</a></a>(uint addr, int *ip)
{
  <span class='reserved'>if</span>(addr &gt;= <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz || addr+4 &gt; <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz)
    <span class='reserved'>return</span> -1;
  *ip = *(int*)(addr);
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Fetch the nul-terminated string at addr from the current process.</span><span class='comment'>// Doesn't actually copy the string - just sets *pp to point at it.</span><span class='comment'>// Returns length of string, not including nul.</span>int
<a name='Ffetchstr'><a class='func-ref' href='#Ffetchstr'>fetchstr</a></a>(uint addr, char **pp)
{
  char *s, *ep;

  <span class='reserved'>if</span>(addr &gt;= <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz)
    <span class='reserved'>return</span> -1;
  *pp = (char*)addr;
  ep = (char*)<a class='str-ref' href='#Sproc'>proc</a>-&gt;sz;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(s = *pp; s &lt; ep; s++)
    <span class='reserved'>if</span>(*s == 0)
      <span class='reserved'>return</span> s - *pp;
  <span class='reserved'>return</span> -1;
}

<span class='comment'>// Fetch the nth 32-bit system call argument.</span>int
<a name='Fargint'><a class='func-ref' href='#Fargint'>argint</a></a>(int n, int *ip)
{
  <span class='reserved'>return</span> <a class='func-ref' href='#Ffetchint'>fetchint</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;tf-&gt;esp + 4 + 4*n, ip);
}

<span class='comment'>// Fetch the nth word-sized system call argument as a pointer</span><span class='comment'>// to a block of memory of size n bytes.  Check that the pointer</span><span class='comment'>// lies within the process address space.</span>int
<a name='Fargptr'><a class='func-ref' href='#Fargptr'>argptr</a></a>(int n, char **pp, int size)
{
  int i;
  
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargint'>argint</a>(n, &i) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>((uint)i &gt;= <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz || (uint)i+size &gt; <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz)
    <span class='reserved'>return</span> -1;
  *pp = (char*)i;
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Fetch the nth word-sized system call argument as a string pointer.</span><span class='comment'>// Check that the pointer is valid and the string is nul-terminated.</span><span class='comment'>// (There is no shared writable memory, so the string can't change</span><span class='comment'>// between this check and being used by the kernel.)</span>int
<a name='Fargstr'><a class='func-ref' href='#Fargstr'>argstr</a></a>(int n, char **pp)
{
  int addr;
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargint'>argint</a>(n, &addr) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> <a class='func-ref' href='#Ffetchstr'>fetchstr</a>(addr, pp);
}

<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_chdir'>sys_chdir</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_close'>sys_close</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_dup'>sys_dup</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_exec'>sys_exec</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_exit'>sys_exit</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_fork'>sys_fork</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_fstat'>sys_fstat</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_getpid'>sys_getpid</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_kill'>sys_kill</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_link'>sys_link</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_mkdir'>sys_mkdir</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_mknod'>sys_mknod</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_open'>sys_open</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_pipe'>sys_pipe</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_read'>sys_read</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_sbrk'>sys_sbrk</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_sleep'>sys_sleep</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_unlink'>sys_unlink</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_wait'>sys_wait</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_write'>sys_write</a>(void);
<span class='reserved'>extern</span> int <a class='func-ref' href='#Fsys_uptime'>sys_uptime</a>(void);

<span class='reserved'>static</span> int (*syscalls[])(void) = {
[<a class='define-ref' href='#ASYS_fork'>SYS_fork</a>]    <a class='func-ref' href='#Fsys_fork'>sys_fork</a>,
[<a class='define-ref' href='#ASYS_exit'>SYS_exit</a>]    <a class='func-ref' href='#Fsys_exit'>sys_exit</a>,
[<a class='define-ref' href='#ASYS_wait'>SYS_wait</a>]    <a class='func-ref' href='#Fsys_wait'>sys_wait</a>,
[<a class='define-ref' href='#ASYS_pipe'>SYS_pipe</a>]    <a class='func-ref' href='#Fsys_pipe'>sys_pipe</a>,
[<a class='define-ref' href='#ASYS_read'>SYS_read</a>]    <a class='func-ref' href='#Fsys_read'>sys_read</a>,
[<a class='define-ref' href='#ASYS_kill'>SYS_kill</a>]    <a class='func-ref' href='#Fsys_kill'>sys_kill</a>,
[<a class='define-ref' href='#ASYS_exec'>SYS_exec</a>]    <a class='func-ref' href='#Fsys_exec'>sys_exec</a>,
[<a class='define-ref' href='#ASYS_fstat'>SYS_fstat</a>]   <a class='func-ref' href='#Fsys_fstat'>sys_fstat</a>,
[<a class='define-ref' href='#ASYS_chdir'>SYS_chdir</a>]   <a class='func-ref' href='#Fsys_chdir'>sys_chdir</a>,
[<a class='define-ref' href='#ASYS_dup'>SYS_dup</a>]     <a class='func-ref' href='#Fsys_dup'>sys_dup</a>,
[<a class='define-ref' href='#ASYS_getpid'>SYS_getpid</a>]  <a class='func-ref' href='#Fsys_getpid'>sys_getpid</a>,
[<a class='define-ref' href='#ASYS_sbrk'>SYS_sbrk</a>]    <a class='func-ref' href='#Fsys_sbrk'>sys_sbrk</a>,
[<a class='define-ref' href='#ASYS_sleep'>SYS_sleep</a>]   <a class='func-ref' href='#Fsys_sleep'>sys_sleep</a>,
[<a class='define-ref' href='#ASYS_uptime'>SYS_uptime</a>]  <a class='func-ref' href='#Fsys_uptime'>sys_uptime</a>,
[<a class='define-ref' href='#ASYS_open'>SYS_open</a>]    <a class='func-ref' href='#Fsys_open'>sys_open</a>,
[<a class='define-ref' href='#ASYS_write'>SYS_write</a>]   <a class='func-ref' href='#Fsys_write'>sys_write</a>,
[<a class='define-ref' href='#ASYS_mknod'>SYS_mknod</a>]   <a class='func-ref' href='#Fsys_mknod'>sys_mknod</a>,
[<a class='define-ref' href='#ASYS_unlink'>SYS_unlink</a>]  <a class='func-ref' href='#Fsys_unlink'>sys_unlink</a>,
[<a class='define-ref' href='#ASYS_link'>SYS_link</a>]    <a class='func-ref' href='#Fsys_link'>sys_link</a>,
[<a class='define-ref' href='#ASYS_mkdir'>SYS_mkdir</a>]   <a class='func-ref' href='#Fsys_mkdir'>sys_mkdir</a>,
[<a class='define-ref' href='#ASYS_close'>SYS_close</a>]   <a class='func-ref' href='#Fsys_close'>sys_close</a>,
};

void
<a name='Fsyscall'><a class='func-ref' href='#Fsyscall'>syscall</a></a>(void)
{
  int num;

  num = <a class='str-ref' href='#Sproc'>proc</a>-&gt;tf-&gt;eax;
  <span class='reserved'>if</span>(num &gt; 0 && num &lt; <a class='define-ref' href='#ANELEM'>NELEM</a>(syscalls) && syscalls[num]) {
    <a class='str-ref' href='#Sproc'>proc</a>-&gt;tf-&gt;eax = syscalls[num]();
  } <span class='reserved'>else</span> {
    <a class='func-ref' href='#Fcprintf'>cprintf</a>("%d %s: unknown sys call %d\n",
            <a class='str-ref' href='#Sproc'>proc</a>-&gt;pid, <a class='str-ref' href='#Sproc'>proc</a>-&gt;name, num);
    <a class='str-ref' href='#Sproc'>proc</a>-&gt;tf-&gt;eax = -1;
  }
}



<hr/><a name='Isysproc.c'>###### <a class='page-ref' href='#Isysproc.c'>sysproc.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"

int
<a name='Fsys_fork'><a class='func-ref' href='#Fsys_fork'>sys_fork</a></a>(void)
{
  <span class='reserved'>return</span> <a class='func-ref' href='#Ffork'>fork</a>();
}

int
<a name='Fsys_exit'><a class='func-ref' href='#Fsys_exit'>sys_exit</a></a>(void)
{
  <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
  <span class='reserved'>return</span> 0;  <span class='comment'>// not reached</span>}

int
<a name='Fsys_wait'><a class='func-ref' href='#Fsys_wait'>sys_wait</a></a>(void)
{
  <span class='reserved'>return</span> <a class='func-ref' href='#Fwait'>wait</a>();
}

int
<a name='Fsys_kill'><a class='func-ref' href='#Fsys_kill'>sys_kill</a></a>(void)
{
  int pid;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargint'>argint</a>(0, &pid) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> <a class='func-ref' href='#Fkill'>kill</a>(pid);
}

int
<a name='Fsys_getpid'><a class='func-ref' href='#Fsys_getpid'>sys_getpid</a></a>(void)
{
  <span class='reserved'>return</span> <a class='str-ref' href='#Sproc'>proc</a>-&gt;pid;
}

int
<a name='Fsys_sbrk'><a class='func-ref' href='#Fsys_sbrk'>sys_sbrk</a></a>(void)
{
  int addr;
  int n;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargint'>argint</a>(0, &n) &lt; 0)
    <span class='reserved'>return</span> -1;
  addr = <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz;
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fgrowproc'>growproc</a>(n) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> addr;
}

int
<a name='Fsys_sleep'><a class='func-ref' href='#Fsys_sleep'>sys_sleep</a></a>(void)
{
  int n;
  uint ticks0;
  
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargint'>argint</a>(0, &n) &lt; 0)
    <span class='reserved'>return</span> -1;
  <a class='func-ref' href='#Facquire'>acquire</a>(&tickslock);
  ticks0 = ticks;
  <span class='reserved'>while</span>(ticks - ticks0 &lt; n){
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;killed){
      <a class='func-ref' href='#Frelease'>release</a>(&tickslock);
      <span class='reserved'>return</span> -1;
    }
    <a class='func-ref' href='#Fsleep'>sleep</a>(&ticks, &tickslock);
  }
  <a class='func-ref' href='#Frelease'>release</a>(&tickslock);
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// <span class='reserved'>return</span> how many clock tick interrupts have occurred</span><span class='comment'>// since <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>.</span>int
<a name='Fsys_uptime'><a class='func-ref' href='#Fsys_uptime'>sys_uptime</a></a>(void)
{
  uint xticks;
  
  <a class='func-ref' href='#Facquire'>acquire</a>(&tickslock);
  xticks = ticks;
  <a class='func-ref' href='#Frelease'>release</a>(&tickslock);
  <span class='reserved'>return</span> xticks;
}



<hr/><a name='Ibuf.h'>###### <a class='page-ref' href='#Ibuf.h'><a class='str-ref' href='#Sbuf'>buf</a>.h</a> ########</a>

<a name='Sbuf'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> {
  int <a class='define-ref' href='#Aflags'>flags</a>;
  uint dev;
  uint sector;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *prev; <span class='comment'>// LRU cache list</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *next;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *qnext; <span class='comment'>// disk queue</span>  uchar data[512];
};
<a name='AB_BUSY'></a><span class='hash'>#define</span> <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>  0x1  <span class='comment'>// buffer is locked by some process</span><a name='AB_VALID'></a><span class='hash'>#define</span> <a class='define-ref' href='#AB_VALID'>B_VALID</a> 0x2  <span class='comment'>// buffer has been read from disk</span><a name='AB_DIRTY'></a><span class='hash'>#define</span> <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a> 0x4  <span class='comment'>// buffer needs to be written to disk</span>



<hr/><a name='Ifcntl.h'>###### <a class='page-ref' href='#Ifcntl.h'>fcntl.h</a> ########</a>

<a name='AO_RDONLY'></a><span class='hash'>#define</span> <a class='define-ref' href='#AO_RDONLY'>O_RDONLY</a>  0x000
<a name='AO_WRONLY'></a><span class='hash'>#define</span> <a class='define-ref' href='#AO_WRONLY'>O_WRONLY</a>  0x001
<a name='AO_RDWR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AO_RDWR'>O_RDWR</a>    0x002
<a name='AO_CREATE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AO_CREATE'>O_CREATE</a>  0x200



<hr/><a name='Istat.h'>###### <a class='page-ref' href='#Istat.h'><a class='str-ref' href='#Sstat'>stat</a>.h</a> ########</a>

<a name='AT_DIR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_DIR'>T_DIR</a>  1   <span class='comment'>// Directory</span><a name='AT_FILE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_FILE'>T_FILE</a> 2   <span class='comment'>// File</span><a name='AT_DEV'></a><span class='hash'>#define</span> <a class='define-ref' href='#AT_DEV'>T_DEV</a>  3   <span class='comment'>// Device</span>
<a name='Sstat'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sstat'>stat</a> {
  short type;  <span class='comment'>// Type of <a class='str-ref' href='#Sfile'>file</a></span>  int dev;     <span class='comment'>// File system's disk device</span>  uint ino;    <span class='comment'>// Inode number</span>  short nlink; <span class='comment'>// Number of links to <a class='str-ref' href='#Sfile'>file</a></span>  uint size;   <span class='comment'>// Size of <a class='str-ref' href='#Sfile'>file</a> in bytes</span>};



<hr/><a name='Ifs.h'>###### <a class='page-ref' href='#Ifs.h'>fs.h</a> ########</a>

<span class='comment'>// On-disk <a class='str-ref' href='#Sfile'>file</a> system format. </span><span class='comment'>// Both the kernel and user programs use this header <a class='str-ref' href='#Sfile'>file</a>.</span>
<span class='comment'>// Block 0 is unused.</span><span class='comment'>// Block 1 is super block.</span><span class='comment'>// Blocks 2 through sb.ninodes/<a class='define-ref' href='#AIPB'>IPB</a> hold inodes.</span><span class='comment'>// Then free bitmap blocks <a class='func-ref' href='#Fholding'>holding</a> sb.size bits.</span><span class='comment'>// Then sb.nblocks data blocks.</span><span class='comment'>// Then sb.nlog <a class='str-ref' href='#Slog'>log</a> blocks.</span>
<a name='AROOTINO'></a><span class='hash'>#define</span> <a class='define-ref' href='#AROOTINO'>ROOTINO</a> 1  <span class='comment'>// root i-number</span><a name='ABSIZE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ABSIZE'>BSIZE</a> 512  <span class='comment'>// block size</span>
<span class='comment'>// File system super block</span><a name='Ssuperblock'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a> {
  uint size;         <span class='comment'>// Size of <a class='str-ref' href='#Sfile'>file</a> system image (blocks)</span>  uint nblocks;      <span class='comment'>// Number of data blocks</span>  uint ninodes;      <span class='comment'>// Number of inodes.</span>  uint nlog;         <span class='comment'>// Number of <a class='str-ref' href='#Slog'>log</a> blocks</span>};

<a name='ANDIRECT'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANDIRECT'>NDIRECT</a> 12
<a name='ANINDIRECT'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANINDIRECT'>NINDIRECT</a> (<a class='define-ref' href='#ABSIZE'>BSIZE</a> / sizeof(uint))
<a name='AMAXFILE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMAXFILE'>MAXFILE</a> (<a class='define-ref' href='#ANDIRECT'>NDIRECT</a> + <a class='define-ref' href='#ANINDIRECT'>NINDIRECT</a>)

<span class='comment'>// On-disk <a class='str-ref' href='#Sinode'>inode</a> structure</span><a name='Sdinode'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a> {
  short type;           <span class='comment'>// File type</span>  short major;          <span class='comment'>// Major device number (<a class='define-ref' href='#AT_DEV'>T_DEV</a> only)</span>  short minor;          <span class='comment'>// Minor device number (<a class='define-ref' href='#AT_DEV'>T_DEV</a> only)</span>  short nlink;          <span class='comment'>// Number of links to <a class='str-ref' href='#Sinode'>inode</a> in <a class='str-ref' href='#Sfile'>file</a> system</span>  uint size;            <span class='comment'>// Size of <a class='str-ref' href='#Sfile'>file</a> (bytes)</span>  uint addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>+1];   <span class='comment'>// Data block addresses</span>};

<span class='comment'>// Inodes per block.</span><a name='AIPB'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIPB'>IPB</a>           (<a class='define-ref' href='#ABSIZE'>BSIZE</a> / sizeof(<span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a>))

<span class='comment'>// Block containing <a class='str-ref' href='#Sinode'>inode</a> i</span><a name='AIBLOCK'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIBLOCK'>IBLOCK</a>(i)     ((i) / <a class='define-ref' href='#AIPB'>IPB</a> + 2)

<span class='comment'>// Bitmap bits per block</span><a name='ABPB'></a><span class='hash'>#define</span> <a class='define-ref' href='#ABPB'>BPB</a>           (<a class='define-ref' href='#ABSIZE'>BSIZE</a>*8)

<span class='comment'>// Block containing bit <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> block b</span><a name='ABBLOCK'></a><span class='hash'>#define</span> <a class='define-ref' href='#ABBLOCK'>BBLOCK</a>(b, ninodes) (b/<a class='define-ref' href='#ABPB'>BPB</a> + (ninodes)/<a class='define-ref' href='#AIPB'>IPB</a> + 3)

<span class='comment'>// Directory is a <a class='str-ref' href='#Sfile'>file</a> containing a sequence of <a class='str-ref' href='#Sdirent'>dirent</a> structures.</span><a name='ADIRSIZ'></a><span class='hash'>#define</span> <a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a> 14

<a name='Sdirent'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sdirent'>dirent</a> {
  ushort inum;
  char name[<a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>];
};




<hr/><a name='Ifile.h'>###### <a class='page-ref' href='#Ifile.h'><a class='str-ref' href='#Sfile'>file</a>.h</a> ########</a>

<a name='Sfile'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> {
  enum { FD_NONE, FD_PIPE, FD_INODE } type;
  int ref; <span class='comment'>// reference count</span>  char readable;
  char writable;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a> *<a class='str-ref' href='#Spipe'>pipe</a>;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip;
  uint off;
};


<span class='comment'>// in-memory copy of an <a class='str-ref' href='#Sinode'>inode</a></span><a name='Sinode'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> {
  uint dev;           <span class='comment'>// Device number</span>  uint inum;          <span class='comment'>// Inode number</span>  int ref;            <span class='comment'>// Reference count</span>  int <a class='define-ref' href='#Aflags'>flags</a>;          <span class='comment'>// <a class='define-ref' href='#AI_BUSY'>I_BUSY</a>, <a class='define-ref' href='#AI_VALID'>I_VALID</a></span>
  short type;         <span class='comment'>// copy of disk <a class='str-ref' href='#Sinode'>inode</a></span>  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>+1];
};
<a name='AI_BUSY'></a><span class='hash'>#define</span> <a class='define-ref' href='#AI_BUSY'>I_BUSY</a> 0x1
<a name='AI_VALID'></a><span class='hash'>#define</span> <a class='define-ref' href='#AI_VALID'>I_VALID</a> 0x2

<span class='comment'>// table mapping major device number to</span><span class='comment'>// device functions</span><a name='Sdevsw'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sdevsw'>devsw</a> {
  int (*read)(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, char*, int);
  int (*write)(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*, char*, int);
};

<span class='reserved'>extern</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sdevsw'>devsw</a> <a class='str-ref' href='#Sdevsw'>devsw</a>[];

<a name='ACONSOLE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACONSOLE'>CONSOLE</a> 1



<hr/><a name='Iide.c'>###### <a class='page-ref' href='#Iide.c'>ide.c</a> ########</a>

<span class='comment'>// Simple PIO-based (non-DMA) IDE driver code.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ibuf.h'><a class='str-ref' href='#Sbuf'>buf</a>.h</a>"

<a name='AIDE_BSY'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIDE_BSY'>IDE_BSY</a>       0x80
<a name='AIDE_DRDY'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIDE_DRDY'>IDE_DRDY</a>      0x40
<a name='AIDE_DF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIDE_DF'>IDE_DF</a>        0x20
<a name='AIDE_ERR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIDE_ERR'>IDE_ERR</a>       0x01

<a name='AIDE_CMD_READ'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIDE_CMD_READ'>IDE_CMD_READ</a>  0x20
<a name='AIDE_CMD_WRITE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIDE_CMD_WRITE'>IDE_CMD_WRITE</a> 0x30

<span class='comment'>// idequeue points to the <a class='str-ref' href='#Sbuf'>buf</a> now being read/written to the disk.</span><span class='comment'>// idequeue-&gt;qnext points to the next <a class='str-ref' href='#Sbuf'>buf</a> to be processed.</span><span class='comment'>// You must hold idelock <span class='reserved'>while</span> manipulating queue.</span>
<span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> idelock;
<span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *idequeue;

<span class='reserved'>static</span> int havedisk1;
<span class='reserved'>static</span> void <a class='func-ref' href='#Fidestart'>idestart</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*);

<span class='comment'>// Wait <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> IDE disk to become ready.</span><span class='reserved'>static</span> int
<a name='Fidewait'><a class='func-ref' href='#Fidewait'>idewait</a></a>(int checkerr)
{
  int r;

  <span class='reserved'>while</span>(((r = <a class='func-ref' href='#Finb'>inb</a>(0x1f7)) & (<a class='define-ref' href='#AIDE_BSY'>IDE_BSY</a>|<a class='define-ref' href='#AIDE_DRDY'>IDE_DRDY</a>)) != <a class='define-ref' href='#AIDE_DRDY'>IDE_DRDY</a>) 
    ;
  <span class='reserved'>if</span>(checkerr && (r & (<a class='define-ref' href='#AIDE_DF'>IDE_DF</a>|<a class='define-ref' href='#AIDE_ERR'>IDE_ERR</a>)) != 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> 0;
}

void
<a name='Fideinit'><a class='func-ref' href='#Fideinit'>ideinit</a></a>(void)
{
  int i;

  <a class='func-ref' href='#Finitlock'>initlock</a>(&idelock, "ide");
  <a class='func-ref' href='#Fpicenable'>picenable</a>(<a class='define-ref' href='#AIRQ_IDE'>IRQ_IDE</a>);
  <a class='func-ref' href='#Fioapicenable'>ioapicenable</a>(<a class='define-ref' href='#AIRQ_IDE'>IRQ_IDE</a>, ncpu - 1);
  <a class='func-ref' href='#Fidewait'>idewait</a>(0);
  
  <span class='comment'>// Check <span class='reserved'>if</span> disk 1 is present</span>  <a class='func-ref' href='#Foutb'>outb</a>(0x1f6, 0xe0 | (1&lt;&lt;4));
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i=0; i&lt;1000; i++){
    <span class='reserved'>if</span>(<a class='func-ref' href='#Finb'>inb</a>(0x1f7) != 0){
      havedisk1 = 1;
      <span class='reserved'>break</span>;
    }
  }
  
  <span class='comment'>// Switch back to disk 0.</span>  <a class='func-ref' href='#Foutb'>outb</a>(0x1f6, 0xe0 | (0&lt;&lt;4));
}

<span class='comment'>// Start the request <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> b.  Caller must hold idelock.</span><span class='reserved'>static</span> void
<a name='Fidestart'><a class='func-ref' href='#Fidestart'>idestart</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b)
{
  <span class='reserved'>if</span>(b == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fidestart'>idestart</a>");

  <a class='func-ref' href='#Fidewait'>idewait</a>(0);
  <a class='func-ref' href='#Foutb'>outb</a>(0x3f6, 0);  <span class='comment'>// generate interrupt</span>  <a class='func-ref' href='#Foutb'>outb</a>(0x1f2, 1);  <span class='comment'>// number of sectors</span>  <a class='func-ref' href='#Foutb'>outb</a>(0x1f3, b-&gt;sector & 0xff);
  <a class='func-ref' href='#Foutb'>outb</a>(0x1f4, (b-&gt;sector &gt;&gt; 8) & 0xff);
  <a class='func-ref' href='#Foutb'>outb</a>(0x1f5, (b-&gt;sector &gt;&gt; 16) & 0xff);
  <a class='func-ref' href='#Foutb'>outb</a>(0x1f6, 0xe0 | ((b-&gt;dev&1)&lt;&lt;4) | ((b-&gt;sector&gt;&gt;24)&0x0f));
  <span class='reserved'>if</span>(b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>){
    <a class='func-ref' href='#Foutb'>outb</a>(0x1f7, <a class='define-ref' href='#AIDE_CMD_WRITE'>IDE_CMD_WRITE</a>);
    <a class='func-ref' href='#Foutsl'>outsl</a>(0x1f0, b-&gt;data, 512/4);
  } <span class='reserved'>else</span> {
    <a class='func-ref' href='#Foutb'>outb</a>(0x1f7, <a class='define-ref' href='#AIDE_CMD_READ'>IDE_CMD_READ</a>);
  }
}

<span class='comment'>// Interrupt handler.</span>void
<a name='Fideintr'><a class='func-ref' href='#Fideintr'>ideintr</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b;

  <span class='comment'>// First queued buffer is the active request.</span>  <a class='func-ref' href='#Facquire'>acquire</a>(&idelock);
  <span class='reserved'>if</span>((b = idequeue) == 0){
    <a class='func-ref' href='#Frelease'>release</a>(&idelock);
    <span class='comment'>// <a class='func-ref' href='#Fcprintf'>cprintf</a>("spurious IDE interrupt\n");</span>    <span class='reserved'>return</span>;
  }
  idequeue = b-&gt;qnext;

  <span class='comment'>// Read data <span class='reserved'>if</span> needed.</span>  <span class='reserved'>if</span>(!(b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>) && <a class='func-ref' href='#Fidewait'>idewait</a>(1) &gt;= 0)
    <a class='func-ref' href='#Finsl'>insl</a>(0x1f0, b-&gt;data, 512/4);
  
  <span class='comment'>// Wake process waiting <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> this <a class='str-ref' href='#Sbuf'>buf</a>.</span>  b-&gt;<a class='define-ref' href='#Aflags'>flags</a> |= <a class='define-ref' href='#AB_VALID'>B_VALID</a>;
  b-&gt;<a class='define-ref' href='#Aflags'>flags</a> &= ~<a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>;
  <a class='func-ref' href='#Fwakeup'>wakeup</a>(b);
  
  <span class='comment'>// Start disk on next <a class='str-ref' href='#Sbuf'>buf</a> in queue.</span>  <span class='reserved'>if</span>(idequeue != 0)
    <a class='func-ref' href='#Fidestart'>idestart</a>(idequeue);

  <a class='func-ref' href='#Frelease'>release</a>(&idelock);
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Sync <a class='str-ref' href='#Sbuf'>buf</a> with disk. </span><span class='comment'>// If <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a> is set, write <a class='str-ref' href='#Sbuf'>buf</a> to disk, clear <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>, set <a class='define-ref' href='#AB_VALID'>B_VALID</a>.</span><span class='comment'>// Else <span class='reserved'>if</span> <a class='define-ref' href='#AB_VALID'>B_VALID</a> is not set, read <a class='str-ref' href='#Sbuf'>buf</a> from disk, set <a class='define-ref' href='#AB_VALID'>B_VALID</a>.</span>void
<a name='Fiderw'><a class='func-ref' href='#Fiderw'>iderw</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> **pp;

  <span class='reserved'>if</span>(!(b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fiderw'>iderw</a>: <a class='str-ref' href='#Sbuf'>buf</a> not busy");
  <span class='reserved'>if</span>((b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & (<a class='define-ref' href='#AB_VALID'>B_VALID</a>|<a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>)) == <a class='define-ref' href='#AB_VALID'>B_VALID</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fiderw'>iderw</a>: nothing to do");
  <span class='reserved'>if</span>(b-&gt;dev != 0 && !havedisk1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fiderw'>iderw</a>: ide disk 1 not present");

  <a class='func-ref' href='#Facquire'>acquire</a>(&idelock);  <span class='comment'>//DOC:<a class='func-ref' href='#Facquire'>acquire</a>-lock</span>
  <span class='comment'>// Append b to idequeue.</span>  b-&gt;qnext = 0;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(pp=&idequeue; *pp; pp=&(*pp)-&gt;qnext)  <span class='comment'>//DOC:insert-queue</span>    ;
  *pp = b;
  
  <span class='comment'>// Start disk <span class='reserved'>if</span> necessary.</span>  <span class='reserved'>if</span>(idequeue == b)
    <a class='func-ref' href='#Fidestart'>idestart</a>(b);
  
  <span class='comment'>// Wait <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> request to finish.</span>  <span class='reserved'>while</span>((b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & (<a class='define-ref' href='#AB_VALID'>B_VALID</a>|<a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>)) != <a class='define-ref' href='#AB_VALID'>B_VALID</a>){
    <a class='func-ref' href='#Fsleep'>sleep</a>(b, &idelock);
  }

  <a class='func-ref' href='#Frelease'>release</a>(&idelock);
}



<hr/><a name='Ibio.c'>###### <a class='page-ref' href='#Ibio.c'>bio.c</a> ########</a>

<span class='comment'>// Buffer cache.</span><span class='comment'>//</span><span class='comment'>// The buffer cache is a linked list of <a class='str-ref' href='#Sbuf'>buf</a> structures <a class='func-ref' href='#Fholding'>holding</a></span><span class='comment'>// cached copies of disk block contents.  Caching disk blocks</span><span class='comment'>// in memory reduces the number of disk reads and also provides</span><span class='comment'>// a synchronization point <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> disk blocks used by multiple processes.</span><span class='comment'>// </span><span class='comment'>// Interface:</span><span class='comment'>// * To get a buffer <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a particular disk block, call <a class='func-ref' href='#Fbread'>bread</a>.</span><span class='comment'>// * After changing buffer data, call <a class='func-ref' href='#Fbwrite'>bwrite</a> to write it to disk.</span><span class='comment'>// * When done with the buffer, call <a class='func-ref' href='#Fbrelse'>brelse</a>.</span><span class='comment'>// * Do not use the buffer after calling <a class='func-ref' href='#Fbrelse'>brelse</a>.</span><span class='comment'>// * Only one process at a time can use a buffer,</span><span class='comment'>//     so do not keep them longer than necessary.</span><span class='comment'>// </span><span class='comment'>// The implementation uses three state <a class='define-ref' href='#Aflags'>flags</a> internally:</span><span class='comment'>// * <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>: the block has been returned from <a class='func-ref' href='#Fbread'>bread</a></span><span class='comment'>//     and has not been passed back to <a class='func-ref' href='#Fbrelse'>brelse</a>.  </span><span class='comment'>// * <a class='define-ref' href='#AB_VALID'>B_VALID</a>: the buffer data has been read from the disk.</span><span class='comment'>// * <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>: the buffer data has been modified</span><span class='comment'>//     and needs to be written to disk.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ibuf.h'><a class='str-ref' href='#Sbuf'>buf</a>.h</a>"

<a name='Sbcache'></a><span class='reserved'>struct</span> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> <a class='str-ref' href='#Sbuf'>buf</a>[<a class='define-ref' href='#ANBUF'>NBUF</a>];

  <span class='comment'>// Linked list of all buffers, through prev/next.</span>  <span class='comment'>// head.next is most recently used.</span>  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> head;
} <a class='str-ref' href='#Sbcache'>bcache</a>;

void
<a name='Fbinit'><a class='func-ref' href='#Fbinit'>binit</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b;

  <a class='func-ref' href='#Finitlock'>initlock</a>(&<a class='str-ref' href='#Sbcache'>bcache</a>.lock, "<a class='str-ref' href='#Sbcache'>bcache</a>");

<span class='comment'>//PAGEBREAK!</span>  <span class='comment'>// Create linked list of buffers</span>  <a class='str-ref' href='#Sbcache'>bcache</a>.head.prev = &<a class='str-ref' href='#Sbcache'>bcache</a>.head;
  <a class='str-ref' href='#Sbcache'>bcache</a>.head.next = &<a class='str-ref' href='#Sbcache'>bcache</a>.head;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(b = <a class='str-ref' href='#Sbcache'>bcache</a>.<a class='str-ref' href='#Sbuf'>buf</a>; b &lt; <a class='str-ref' href='#Sbcache'>bcache</a>.<a class='str-ref' href='#Sbuf'>buf</a>+<a class='define-ref' href='#ANBUF'>NBUF</a>; b++){
    b-&gt;next = <a class='str-ref' href='#Sbcache'>bcache</a>.head.next;
    b-&gt;prev = &<a class='str-ref' href='#Sbcache'>bcache</a>.head;
    b-&gt;dev = -1;
    <a class='str-ref' href='#Sbcache'>bcache</a>.head.next-&gt;prev = b;
    <a class='str-ref' href='#Sbcache'>bcache</a>.head.next = b;
  }
}

<span class='comment'>// Look through buffer cache <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> sector on device dev.</span><span class='comment'>// If not <a class='func-ref' href='#Ffound'>found</a>, allocate fresh block.</span><span class='comment'>// In either <span class='reserved'>case</span>, <span class='reserved'>return</span> <a class='define-ref' href='#AB_BUSY'>B_BUSY</a> buffer.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*
<a name='Fbget'><a class='func-ref' href='#Fbget'>bget</a></a>(uint dev, uint sector)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sbcache'>bcache</a>.lock);

 loop:
  <span class='comment'>// Is the sector already cached?</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(b = <a class='str-ref' href='#Sbcache'>bcache</a>.head.next; b != &<a class='str-ref' href='#Sbcache'>bcache</a>.head; b = b-&gt;next){
    <span class='reserved'>if</span>(b-&gt;dev == dev && b-&gt;sector == sector){
      <span class='reserved'>if</span>(!(b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>)){
        b-&gt;<a class='define-ref' href='#Aflags'>flags</a> |= <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>;
        <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sbcache'>bcache</a>.lock);
        <span class='reserved'>return</span> b;
      }
      <a class='func-ref' href='#Fsleep'>sleep</a>(b, &<a class='str-ref' href='#Sbcache'>bcache</a>.lock);
      goto loop;
    }
  }

  <span class='comment'>// Not cached; recycle some non-busy and clean buffer.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(b = <a class='str-ref' href='#Sbcache'>bcache</a>.head.prev; b != &<a class='str-ref' href='#Sbcache'>bcache</a>.head; b = b-&gt;prev){
    <span class='reserved'>if</span>((b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>) == 0 && (b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>) == 0){
      b-&gt;dev = dev;
      b-&gt;sector = sector;
      b-&gt;<a class='define-ref' href='#Aflags'>flags</a> = <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>;
      <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sbcache'>bcache</a>.lock);
      <span class='reserved'>return</span> b;
    }
  }
  <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fbget'>bget</a>: no buffers");
}

<span class='comment'>// Return a <a class='define-ref' href='#AB_BUSY'>B_BUSY</a> <a class='str-ref' href='#Sbuf'>buf</a> with the contents of the indicated disk sector.</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a>*
<a name='Fbread'><a class='func-ref' href='#Fbread'>bread</a></a>(uint dev, uint sector)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b;

  b = <a class='func-ref' href='#Fbget'>bget</a>(dev, sector);
  <span class='reserved'>if</span>(!(b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_VALID'>B_VALID</a>))
    <a class='func-ref' href='#Fiderw'>iderw</a>(b);
  <span class='reserved'>return</span> b;
}

<span class='comment'>// Write b's contents to disk.  Must be <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>.</span>void
<a name='Fbwrite'><a class='func-ref' href='#Fbwrite'>bwrite</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b)
{
  <span class='reserved'>if</span>((b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>) == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fbwrite'>bwrite</a>");
  b-&gt;<a class='define-ref' href='#Aflags'>flags</a> |= <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>;
  <a class='func-ref' href='#Fiderw'>iderw</a>(b);
}

<span class='comment'>// Release a <a class='define-ref' href='#AB_BUSY'>B_BUSY</a> buffer.</span><span class='comment'>// Move to the head of the MRU list.</span>void
<a name='Fbrelse'><a class='func-ref' href='#Fbrelse'>brelse</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b)
{
  <span class='reserved'>if</span>((b-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AB_BUSY'>B_BUSY</a>) == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fbrelse'>brelse</a>");

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sbcache'>bcache</a>.lock);

  b-&gt;next-&gt;prev = b-&gt;prev;
  b-&gt;prev-&gt;next = b-&gt;next;
  b-&gt;next = <a class='str-ref' href='#Sbcache'>bcache</a>.head.next;
  b-&gt;prev = &<a class='str-ref' href='#Sbcache'>bcache</a>.head;
  <a class='str-ref' href='#Sbcache'>bcache</a>.head.next-&gt;prev = b;
  <a class='str-ref' href='#Sbcache'>bcache</a>.head.next = b;

  b-&gt;<a class='define-ref' href='#Aflags'>flags</a> &= ~<a class='define-ref' href='#AB_BUSY'>B_BUSY</a>;
  <a class='func-ref' href='#Fwakeup'>wakeup</a>(b);

  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sbcache'>bcache</a>.lock);
}




<hr/><a name='Ilog.c'>###### <a class='page-ref' href='#Ilog.c'><a class='str-ref' href='#Slog'>log</a>.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifs.h'>fs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ibuf.h'><a class='str-ref' href='#Sbuf'>buf</a>.h</a>"

<span class='comment'>// Simple logging. Each system call that might write the <a class='str-ref' href='#Sfile'>file</a> system</span><span class='comment'>// should be surrounded with <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>() and <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>() calls.</span><span class='comment'>//</span><span class='comment'>// The <a class='str-ref' href='#Slog'>log</a> holds at most one transaction at a time. Commit forces</span><span class='comment'>// the <a class='str-ref' href='#Slog'>log</a> (with commit record) to disk, then installs the affected</span><span class='comment'>// blocks to disk, then erases the <a class='str-ref' href='#Slog'>log</a>. <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>() ensures that</span><span class='comment'>// only one system call can be in a transaction; others must <a class='func-ref' href='#Fwait'>wait</a>.</span><span class='comment'>// </span><span class='comment'>// Allowing only one transaction at a time means that the <a class='str-ref' href='#Sfile'>file</a></span><span class='comment'>// system code doesn't have to worry about the possibility of</span><span class='comment'>// one transaction reading a block that another one has modified,</span><span class='comment'>// <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> example an i-node block.</span><span class='comment'>//</span><span class='comment'>// Read-only system calls don't need to use transactions, though</span><span class='comment'>// this means that they may observe uncommitted data. I-node and</span><span class='comment'>// buffer locks prevent read-only calls from seeing inconsistent data.</span><span class='comment'>//</span><span class='comment'>// The <a class='str-ref' href='#Slog'>log</a> is a physical re-do <a class='str-ref' href='#Slog'>log</a> containing disk blocks.</span><span class='comment'>// The on-disk <a class='str-ref' href='#Slog'>log</a> format:</span><span class='comment'>//   header block, containing sector #s <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> block A, B, <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>, ...</span><span class='comment'>//   block A</span><span class='comment'>//   block B</span><span class='comment'>//   block <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a></span><span class='comment'>//   ...</span><span class='comment'>// Log appends are synchronous.</span>
<span class='comment'>// Contents of the header block, used <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> both the on-disk header block</span><span class='comment'>// and to keep track in memory of logged sector #s before commit.</span><a name='Slogheader'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Slogheader'>logheader</a> {
  int n;   
  int sector[<a class='define-ref' href='#ALOGSIZE'>LOGSIZE</a>];
};

<a name='Slog'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Slog'>log</a> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  int <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>;
  int size;
  int busy; <span class='comment'>// a transaction is active</span>  int dev;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Slogheader'>logheader</a> lh;
};
<span class='reserved'>struct</span> <a class='str-ref' href='#Slog'>log</a> <a class='str-ref' href='#Slog'>log</a>;

<span class='reserved'>static</span> void <a class='func-ref' href='#Frecover_from_log'>recover_from_log</a>(void);

void
<a name='Finitlog'><a class='func-ref' href='#Finitlog'>initlog</a></a>(void)
{
  <span class='reserved'>if</span> (sizeof(<span class='reserved'>struct</span> <a class='str-ref' href='#Slogheader'>logheader</a>) &gt;= <a class='define-ref' href='#ABSIZE'>BSIZE</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Finitlog'>initlog</a>: too big <a class='str-ref' href='#Slogheader'>logheader</a>");

  <span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a> sb;
  <a class='func-ref' href='#Finitlock'>initlock</a>(&<a class='str-ref' href='#Slog'>log</a>.lock, "<a class='str-ref' href='#Slog'>log</a>");
  <a class='func-ref' href='#Freadsb'>readsb</a>(<a class='define-ref' href='#AROOTDEV'>ROOTDEV</a>, &sb);
  <a class='str-ref' href='#Slog'>log</a>.<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a> = sb.size - sb.nlog;
  <a class='str-ref' href='#Slog'>log</a>.size = sb.nlog;
  <a class='str-ref' href='#Slog'>log</a>.dev = <a class='define-ref' href='#AROOTDEV'>ROOTDEV</a>;
  <a class='func-ref' href='#Frecover_from_log'>recover_from_log</a>();
}

<span class='comment'>// Copy committed blocks from <a class='str-ref' href='#Slog'>log</a> to their home location</span><span class='reserved'>static</span> void 
<a name='Finstall_trans'><a class='func-ref' href='#Finstall_trans'>install_trans</a></a>(void)
{
  int tail;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> (tail = 0; tail &lt; <a class='str-ref' href='#Slog'>log</a>.lh.n; tail++) {
    <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *lbuf = <a class='func-ref' href='#Fbread'>bread</a>(<a class='str-ref' href='#Slog'>log</a>.dev, <a class='str-ref' href='#Slog'>log</a>.<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>+tail+1); <span class='comment'>// read <a class='str-ref' href='#Slog'>log</a> block</span>    <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *dbuf = <a class='func-ref' href='#Fbread'>bread</a>(<a class='str-ref' href='#Slog'>log</a>.dev, <a class='str-ref' href='#Slog'>log</a>.lh.sector[tail]); <span class='comment'>// read dst</span>    <a class='func-ref' href='#Fmemmove'>memmove</a>(dbuf-&gt;data, lbuf-&gt;data, <a class='define-ref' href='#ABSIZE'>BSIZE</a>);  <span class='comment'>// copy block to dst</span>    <a class='func-ref' href='#Fbwrite'>bwrite</a>(dbuf);  <span class='comment'>// write dst to disk</span>    <a class='func-ref' href='#Fbrelse'>brelse</a>(lbuf); 
    <a class='func-ref' href='#Fbrelse'>brelse</a>(dbuf);
  }
}

<span class='comment'>// Read the <a class='str-ref' href='#Slog'>log</a> header from disk into the in-memory <a class='str-ref' href='#Slog'>log</a> header</span><span class='reserved'>static</span> void
<a name='Fread_head'><a class='func-ref' href='#Fread_head'>read_head</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *<a class='str-ref' href='#Sbuf'>buf</a> = <a class='func-ref' href='#Fbread'>bread</a>(<a class='str-ref' href='#Slog'>log</a>.dev, <a class='str-ref' href='#Slog'>log</a>.<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>);
  <span class='reserved'>struct</span> <a class='str-ref' href='#Slogheader'>logheader</a> *lh = (<span class='reserved'>struct</span> <a class='str-ref' href='#Slogheader'>logheader</a> *) (<a class='str-ref' href='#Sbuf'>buf</a>-&gt;data);
  int i;
  <a class='str-ref' href='#Slog'>log</a>.lh.n = lh-&gt;n;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> (i = 0; i &lt; <a class='str-ref' href='#Slog'>log</a>.lh.n; i++) {
    <a class='str-ref' href='#Slog'>log</a>.lh.sector[i] = lh-&gt;sector[i];
  }
  <a class='func-ref' href='#Fbrelse'>brelse</a>(<a class='str-ref' href='#Sbuf'>buf</a>);
}

<span class='comment'>// Write in-memory <a class='str-ref' href='#Slog'>log</a> header to disk.</span><span class='comment'>// This is the true point at which the</span><span class='comment'>// current transaction commits.</span><span class='reserved'>static</span> void
<a name='Fwrite_head'><a class='func-ref' href='#Fwrite_head'>write_head</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *<a class='str-ref' href='#Sbuf'>buf</a> = <a class='func-ref' href='#Fbread'>bread</a>(<a class='str-ref' href='#Slog'>log</a>.dev, <a class='str-ref' href='#Slog'>log</a>.<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>);
  <span class='reserved'>struct</span> <a class='str-ref' href='#Slogheader'>logheader</a> *hb = (<span class='reserved'>struct</span> <a class='str-ref' href='#Slogheader'>logheader</a> *) (<a class='str-ref' href='#Sbuf'>buf</a>-&gt;data);
  int i;
  hb-&gt;n = <a class='str-ref' href='#Slog'>log</a>.lh.n;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> (i = 0; i &lt; <a class='str-ref' href='#Slog'>log</a>.lh.n; i++) {
    hb-&gt;sector[i] = <a class='str-ref' href='#Slog'>log</a>.lh.sector[i];
  }
  <a class='func-ref' href='#Fbwrite'>bwrite</a>(<a class='str-ref' href='#Sbuf'>buf</a>);
  <a class='func-ref' href='#Fbrelse'>brelse</a>(<a class='str-ref' href='#Sbuf'>buf</a>);
}

<span class='reserved'>static</span> void
<a name='Frecover_from_log'><a class='func-ref' href='#Frecover_from_log'>recover_from_log</a></a>(void)
{
  <a class='func-ref' href='#Fread_head'>read_head</a>();      
  <a class='func-ref' href='#Finstall_trans'>install_trans</a>(); <span class='comment'>// <span class='reserved'>if</span> committed, copy from <a class='str-ref' href='#Slog'>log</a> to disk</span>  <a class='str-ref' href='#Slog'>log</a>.lh.n = 0;
  <a class='func-ref' href='#Fwrite_head'>write_head</a>(); <span class='comment'>// clear the <a class='str-ref' href='#Slog'>log</a></span>}

void
<a name='Fbegin_trans'><a class='func-ref' href='#Fbegin_trans'>begin_trans</a></a>(void)
{
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Slog'>log</a>.lock);
  <span class='reserved'>while</span> (<a class='str-ref' href='#Slog'>log</a>.busy) {
    <a class='func-ref' href='#Fsleep'>sleep</a>(&<a class='str-ref' href='#Slog'>log</a>, &<a class='str-ref' href='#Slog'>log</a>.lock);
  }
  <a class='str-ref' href='#Slog'>log</a>.busy = 1;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Slog'>log</a>.lock);
}

void
<a name='Fcommit_trans'><a class='func-ref' href='#Fcommit_trans'>commit_trans</a></a>(void)
{
  <span class='reserved'>if</span> (<a class='str-ref' href='#Slog'>log</a>.lh.n &gt; 0) {
    <a class='func-ref' href='#Fwrite_head'>write_head</a>();    <span class='comment'>// Write header to disk -- the real commit</span>    <a class='func-ref' href='#Finstall_trans'>install_trans</a>(); <span class='comment'>// Now install writes to home locations</span>    <a class='str-ref' href='#Slog'>log</a>.lh.n = 0; 
    <a class='func-ref' href='#Fwrite_head'>write_head</a>();    <span class='comment'>// Erase the transaction from the <a class='str-ref' href='#Slog'>log</a></span>  }
  
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Slog'>log</a>.lock);
  <a class='str-ref' href='#Slog'>log</a>.busy = 0;
  <a class='func-ref' href='#Fwakeup'>wakeup</a>(&<a class='str-ref' href='#Slog'>log</a>);
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Slog'>log</a>.lock);
}

<span class='comment'>// Caller has modified b-&gt;data and is done with the buffer.</span><span class='comment'>// Append the block to the <a class='str-ref' href='#Slog'>log</a> and record the block number, </span><span class='comment'>// but don't write the <a class='str-ref' href='#Slog'>log</a> header (which would commit the write).</span><span class='comment'>// <a class='func-ref' href='#Flog_write'>log_write</a>() replaces <a class='func-ref' href='#Fbwrite'>bwrite</a>(); a typical use is:</span><span class='comment'>//   bp = <a class='func-ref' href='#Fbread'>bread</a>(...)</span><span class='comment'>//   modify bp-&gt;data[]</span><span class='comment'>//   <a class='func-ref' href='#Flog_write'>log_write</a>(bp)</span><span class='comment'>//   <a class='func-ref' href='#Fbrelse'>brelse</a>(bp)</span>void
<a name='Flog_write'><a class='func-ref' href='#Flog_write'>log_write</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *b)
{
  int i;

  <span class='reserved'>if</span> (<a class='str-ref' href='#Slog'>log</a>.lh.n &gt;= <a class='define-ref' href='#ALOGSIZE'>LOGSIZE</a> || <a class='str-ref' href='#Slog'>log</a>.lh.n &gt;= <a class='str-ref' href='#Slog'>log</a>.size - 1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("too big a transaction");
  <span class='reserved'>if</span> (!<a class='str-ref' href='#Slog'>log</a>.busy)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("write outside of trans");

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> (i = 0; i &lt; <a class='str-ref' href='#Slog'>log</a>.lh.n; i++) {
    <span class='reserved'>if</span> (<a class='str-ref' href='#Slog'>log</a>.lh.sector[i] == b-&gt;sector)   <span class='comment'>// <a class='str-ref' href='#Slog'>log</a> absorbtion?</span>      <span class='reserved'>break</span>;
  }
  <a class='str-ref' href='#Slog'>log</a>.lh.sector[i] = b-&gt;sector;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *lbuf = <a class='func-ref' href='#Fbread'>bread</a>(b-&gt;dev, <a class='str-ref' href='#Slog'>log</a>.<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>+i+1);
  <a class='func-ref' href='#Fmemmove'>memmove</a>(lbuf-&gt;data, b-&gt;data, <a class='define-ref' href='#ABSIZE'>BSIZE</a>);
  <a class='func-ref' href='#Fbwrite'>bwrite</a>(lbuf);
  <a class='func-ref' href='#Fbrelse'>brelse</a>(lbuf);
  <span class='reserved'>if</span> (i == <a class='str-ref' href='#Slog'>log</a>.lh.n)
    <a class='str-ref' href='#Slog'>log</a>.lh.n++;
  b-&gt;<a class='define-ref' href='#Aflags'>flags</a> |= <a class='define-ref' href='#AB_DIRTY'>B_DIRTY</a>; <span class='comment'>// XXX prevent eviction</span>}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Blank page.</span>



<hr/><a name='Ifs.c'>###### <a class='page-ref' href='#Ifs.c'>fs.c</a> ########</a>

<span class='comment'>// File system implementation.  Five layers:</span><span class='comment'>//   + Blocks: allocator <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> raw disk blocks.</span><span class='comment'>//   + Log: crash recovery <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> multi-step updates.</span><span class='comment'>//   + Files: <a class='str-ref' href='#Sinode'>inode</a> allocator, reading, writing, metadata.</span><span class='comment'>//   + Directories: <a class='str-ref' href='#Sinode'>inode</a> with special contents (list of other inodes!)</span><span class='comment'>//   + Names: paths like /usr/rtm/xv6/<a class='page-ref' href='#Ifs.c'>fs.c</a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> convenient naming.</span><span class='comment'>//</span><span class='comment'>// This <a class='str-ref' href='#Sfile'>file</a> contains the low-level <a class='str-ref' href='#Sfile'>file</a> system manipulation </span><span class='comment'>// routines.  The (higher-level) system call implementations</span><span class='comment'>// are in <a class='page-ref' href='#Isysfile.c'>sysfile.c</a>.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Istat.h'><a class='str-ref' href='#Sstat'>stat</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ibuf.h'><a class='str-ref' href='#Sbuf'>buf</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifs.h'>fs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifile.h'><a class='str-ref' href='#Sfile'>file</a>.h</a>"

<a name='Amin'></a><span class='hash'>#define</span> <a class='define-ref' href='#Amin'>min</a>(a, b) ((a) &lt; (b) ? (a) : (b))
<span class='reserved'>static</span> void <a class='func-ref' href='#Fitrunc'>itrunc</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*);

<span class='comment'>// Read the super block.</span>void
<a name='Freadsb'><a class='func-ref' href='#Freadsb'>readsb</a></a>(int dev, <span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a> *sb)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  
  bp = <a class='func-ref' href='#Fbread'>bread</a>(dev, 1);
  <a class='func-ref' href='#Fmemmove'>memmove</a>(sb, bp-&gt;data, sizeof(*sb));
  <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
}

<span class='comment'>// Zero a block.</span><span class='reserved'>static</span> void
<a name='Fbzero'><a class='func-ref' href='#Fbzero'>bzero</a></a>(int dev, int bno)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  
  bp = <a class='func-ref' href='#Fbread'>bread</a>(dev, bno);
  <a class='func-ref' href='#Fmemset'>memset</a>(bp-&gt;data, 0, <a class='define-ref' href='#ABSIZE'>BSIZE</a>);
  <a class='func-ref' href='#Flog_write'>log_write</a>(bp);
  <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
}

<span class='comment'>// Blocks. </span>
<span class='comment'>// Allocate a zeroed disk block.</span><span class='reserved'>static</span> uint
<a name='Fballoc'><a class='func-ref' href='#Fballoc'>balloc</a></a>(uint dev)
{
  int b, bi, m;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a> sb;

  bp = 0;
  <a class='func-ref' href='#Freadsb'>readsb</a>(dev, &sb);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(b = 0; b &lt; sb.size; b += <a class='define-ref' href='#ABPB'>BPB</a>){
    bp = <a class='func-ref' href='#Fbread'>bread</a>(dev, <a class='define-ref' href='#ABBLOCK'>BBLOCK</a>(b, sb.ninodes));
    <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(bi = 0; bi &lt; <a class='define-ref' href='#ABPB'>BPB</a> && b + bi &lt; sb.size; bi++){
      m = 1 &lt;&lt; (bi % 8);
      <span class='reserved'>if</span>((bp-&gt;data[bi/8] & m) == 0){  <span class='comment'>// Is block free?</span>        bp-&gt;data[bi/8] |= m;  <span class='comment'>// Mark block in use.</span>        <a class='func-ref' href='#Flog_write'>log_write</a>(bp);
        <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
        <a class='func-ref' href='#Fbzero'>bzero</a>(dev, b + bi);
        <span class='reserved'>return</span> b + bi;
      }
    }
    <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
  }
  <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fballoc'>balloc</a>: out of blocks");
}

<span class='comment'>// Free a disk block.</span><span class='reserved'>static</span> void
<a name='Fbfree'><a class='func-ref' href='#Fbfree'>bfree</a></a>(int dev, uint b)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a> sb;
  int bi, m;

  <a class='func-ref' href='#Freadsb'>readsb</a>(dev, &sb);
  bp = <a class='func-ref' href='#Fbread'>bread</a>(dev, <a class='define-ref' href='#ABBLOCK'>BBLOCK</a>(b, sb.ninodes));
  bi = b % <a class='define-ref' href='#ABPB'>BPB</a>;
  m = 1 &lt;&lt; (bi % 8);
  <span class='reserved'>if</span>((bp-&gt;data[bi/8] & m) == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("freeing free block");
  bp-&gt;data[bi/8] &= ~m;
  <a class='func-ref' href='#Flog_write'>log_write</a>(bp);
  <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
}

<span class='comment'>// Inodes.</span><span class='comment'>//</span><span class='comment'>// An <a class='str-ref' href='#Sinode'>inode</a> describes a single unnamed <a class='str-ref' href='#Sfile'>file</a>.</span><span class='comment'>// The <a class='str-ref' href='#Sinode'>inode</a> disk structure holds metadata: the <a class='str-ref' href='#Sfile'>file</a>'s type,</span><span class='comment'>// its size, the number of links referring to it, and the</span><span class='comment'>// list of blocks <a class='func-ref' href='#Fholding'>holding</a> the <a class='str-ref' href='#Sfile'>file</a>'s content.</span><span class='comment'>//</span><span class='comment'>// The inodes are laid out sequentially on disk immediately after</span><span class='comment'>// the <a class='str-ref' href='#Ssuperblock'>superblock</a>. Each <a class='str-ref' href='#Sinode'>inode</a> has a number, indicating its</span><span class='comment'>// position on the disk.</span><span class='comment'>//</span><span class='comment'>// The kernel keeps a cache of in-use inodes in memory</span><span class='comment'>// to provide a place <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> synchronizing access</span><span class='comment'>// to inodes used by multiple processes. The cached</span><span class='comment'>// inodes include book-keeping information that is</span><span class='comment'>// not stored on disk: ip-&gt;ref and ip-&gt;<a class='define-ref' href='#Aflags'>flags</a>.</span><span class='comment'>//</span><span class='comment'>// An <a class='str-ref' href='#Sinode'>inode</a> and its in-memory represtative go through a</span><span class='comment'>// sequence of states before they can be used by the</span><span class='comment'>// rest of the <a class='str-ref' href='#Sfile'>file</a> system code.</span><span class='comment'>//</span><span class='comment'>// * Allocation: an <a class='str-ref' href='#Sinode'>inode</a> is allocated <span class='reserved'>if</span> its type (on disk)</span><span class='comment'>//   is non-zero. <a class='func-ref' href='#Fialloc'>ialloc</a>() allocates, <a class='func-ref' href='#Fiput'>iput</a>() frees <span class='reserved'>if</span></span><span class='comment'>//   the link count has fallen to zero.</span><span class='comment'>//</span><span class='comment'>// * Referencing in cache: an <a class='func-ref' href='#Fentry'>entry</a> in the <a class='str-ref' href='#Sinode'>inode</a> cache</span><span class='comment'>//   is free <span class='reserved'>if</span> ip-&gt;ref is zero. Otherwise ip-&gt;ref tracks</span><span class='comment'>//   the number of in-memory pointers to the <a class='func-ref' href='#Fentry'>entry</a> (open</span><span class='comment'>//   files and current directories). <a class='func-ref' href='#Figet'>iget</a>() to find or</span><span class='comment'>//   <a class='func-ref' href='#Fcreate'>create</a> a cache <a class='func-ref' href='#Fentry'>entry</a> and increment its ref, <a class='func-ref' href='#Fiput'>iput</a>()</span><span class='comment'>//   to decrement ref.</span><span class='comment'>//</span><span class='comment'>// * Valid: the information (type, size, &c) in an <a class='str-ref' href='#Sinode'>inode</a></span><span class='comment'>//   cache <a class='func-ref' href='#Fentry'>entry</a> is only correct when the <a class='define-ref' href='#AI_VALID'>I_VALID</a> bit</span><span class='comment'>//   is set in ip-&gt;<a class='define-ref' href='#Aflags'>flags</a>. <a class='func-ref' href='#Filock'>ilock</a>() reads the <a class='str-ref' href='#Sinode'>inode</a> from</span><span class='comment'>//   the disk and sets <a class='define-ref' href='#AI_VALID'>I_VALID</a>, <span class='reserved'>while</span> <a class='func-ref' href='#Fiput'>iput</a>() clears</span><span class='comment'>//   <a class='define-ref' href='#AI_VALID'>I_VALID</a> <span class='reserved'>if</span> ip-&gt;ref has fallen to zero.</span><span class='comment'>//</span><span class='comment'>// * Locked: <a class='str-ref' href='#Sfile'>file</a> system code may only examine and modify</span><span class='comment'>//   the information in an <a class='str-ref' href='#Sinode'>inode</a> and its content <span class='reserved'>if</span> it</span><span class='comment'>//   has first locked the <a class='str-ref' href='#Sinode'>inode</a>. The <a class='define-ref' href='#AI_BUSY'>I_BUSY</a> flag indicates</span><span class='comment'>//   that the <a class='str-ref' href='#Sinode'>inode</a> is locked. <a class='func-ref' href='#Filock'>ilock</a>() sets <a class='define-ref' href='#AI_BUSY'>I_BUSY</a>,</span><span class='comment'>//   <span class='reserved'>while</span> <a class='func-ref' href='#Fiunlock'>iunlock</a> clears it.</span><span class='comment'>//</span><span class='comment'>// Thus a typical sequence is:</span><span class='comment'>//   ip = <a class='func-ref' href='#Figet'>iget</a>(dev, inum)</span><span class='comment'>//   <a class='func-ref' href='#Filock'>ilock</a>(ip)</span><span class='comment'>//   ... examine and modify ip-&gt;xxx ...</span><span class='comment'>//   <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip)</span><span class='comment'>//   <a class='func-ref' href='#Fiput'>iput</a>(ip)</span><span class='comment'>//</span><span class='comment'>// <a class='func-ref' href='#Filock'>ilock</a>() is separate from <a class='func-ref' href='#Figet'>iget</a>() so that system calls can</span><span class='comment'>// get a long-term reference to an <a class='str-ref' href='#Sinode'>inode</a> (as <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> an open <a class='str-ref' href='#Sfile'>file</a>)</span><span class='comment'>// and only lock it <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> short periods (e.g., in read()).</span><span class='comment'>// The separation also helps avoid deadlock and races during</span><span class='comment'>// pathname lookup. <a class='func-ref' href='#Figet'>iget</a>() increments ip-&gt;ref so that the <a class='str-ref' href='#Sinode'>inode</a></span><span class='comment'>// stays cached and pointers to it remain valid.</span><span class='comment'>//</span><span class='comment'>// Many internal <a class='str-ref' href='#Sfile'>file</a> system functions expect the caller to</span><span class='comment'>// have locked the inodes involved; this lets callers <a class='func-ref' href='#Fcreate'>create</a></span><span class='comment'>// multi-step atomic operations.</span>
<a name='Sicache'></a><span class='reserved'>struct</span> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> <a class='str-ref' href='#Sinode'>inode</a>[<a class='define-ref' href='#ANINODE'>NINODE</a>];
} <a class='str-ref' href='#Sicache'>icache</a>;

void
<a name='Fiinit'><a class='func-ref' href='#Fiinit'>iinit</a></a>(void)
{
  <a class='func-ref' href='#Finitlock'>initlock</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock, "<a class='str-ref' href='#Sicache'>icache</a>");
}

<span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>* <a class='func-ref' href='#Figet'>iget</a>(uint dev, uint inum);

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Allocate a new <a class='str-ref' href='#Sinode'>inode</a> with the given type on device dev.</span><span class='comment'>// A free <a class='str-ref' href='#Sinode'>inode</a> has a type of zero.</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Fialloc'><a class='func-ref' href='#Fialloc'>ialloc</a></a>(uint dev, short type)
{
  int inum;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a> *dip;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Ssuperblock'>superblock</a> sb;

  <a class='func-ref' href='#Freadsb'>readsb</a>(dev, &sb);

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(inum = 1; inum &lt; sb.ninodes; inum++){
    bp = <a class='func-ref' href='#Fbread'>bread</a>(dev, <a class='define-ref' href='#AIBLOCK'>IBLOCK</a>(inum));
    dip = (<span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a>*)bp-&gt;data + inum%<a class='define-ref' href='#AIPB'>IPB</a>;
    <span class='reserved'>if</span>(dip-&gt;type == 0){  <span class='comment'>// a free <a class='str-ref' href='#Sinode'>inode</a></span>      <a class='func-ref' href='#Fmemset'>memset</a>(dip, 0, sizeof(*dip));
      dip-&gt;type = type;
      <a class='func-ref' href='#Flog_write'>log_write</a>(bp);   <span class='comment'>// mark it allocated on the disk</span>      <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
      <span class='reserved'>return</span> <a class='func-ref' href='#Figet'>iget</a>(dev, inum);
    }
    <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
  }
  <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fialloc'>ialloc</a>: no inodes");
}

<span class='comment'>// Copy a modified in-memory <a class='str-ref' href='#Sinode'>inode</a> to disk.</span>void
<a name='Fiupdate'><a class='func-ref' href='#Fiupdate'>iupdate</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a> *dip;

  bp = <a class='func-ref' href='#Fbread'>bread</a>(ip-&gt;dev, <a class='define-ref' href='#AIBLOCK'>IBLOCK</a>(ip-&gt;inum));
  dip = (<span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a>*)bp-&gt;data + ip-&gt;inum%<a class='define-ref' href='#AIPB'>IPB</a>;
  dip-&gt;type = ip-&gt;type;
  dip-&gt;major = ip-&gt;major;
  dip-&gt;minor = ip-&gt;minor;
  dip-&gt;nlink = ip-&gt;nlink;
  dip-&gt;size = ip-&gt;size;
  <a class='func-ref' href='#Fmemmove'>memmove</a>(dip-&gt;addrs, ip-&gt;addrs, sizeof(ip-&gt;addrs));
  <a class='func-ref' href='#Flog_write'>log_write</a>(bp);
  <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
}

<span class='comment'>// Find the <a class='str-ref' href='#Sinode'>inode</a> with number inum on device dev</span><span class='comment'>// and <span class='reserved'>return</span> the in-memory copy. Does not lock</span><span class='comment'>// the <a class='str-ref' href='#Sinode'>inode</a> and does not read it from disk.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Figet'><a class='func-ref' href='#Figet'>iget</a></a>(uint dev, uint inum)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, *empty;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);

  <span class='comment'>// Is the <a class='str-ref' href='#Sinode'>inode</a> already cached?</span>  empty = 0;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(ip = &<a class='str-ref' href='#Sicache'>icache</a>.<a class='str-ref' href='#Sinode'>inode</a>[0]; ip &lt; &<a class='str-ref' href='#Sicache'>icache</a>.<a class='str-ref' href='#Sinode'>inode</a>[<a class='define-ref' href='#ANINODE'>NINODE</a>]; ip++){
    <span class='reserved'>if</span>(ip-&gt;ref &gt; 0 && ip-&gt;dev == dev && ip-&gt;inum == inum){
      ip-&gt;ref++;
      <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
      <span class='reserved'>return</span> ip;
    }
    <span class='reserved'>if</span>(empty == 0 && ip-&gt;ref == 0)    <span class='comment'>// Remember empty slot.</span>      empty = ip;
  }

  <span class='comment'>// Recycle an <a class='str-ref' href='#Sinode'>inode</a> cache <a class='func-ref' href='#Fentry'>entry</a>.</span>  <span class='reserved'>if</span>(empty == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Figet'>iget</a>: no inodes");

  ip = empty;
  ip-&gt;dev = dev;
  ip-&gt;inum = inum;
  ip-&gt;ref = 1;
  ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> = 0;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);

  <span class='reserved'>return</span> ip;
}

<span class='comment'>// Increment reference count <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> ip.</span><span class='comment'>// Returns ip to enable ip = <a class='func-ref' href='#Fidup'>idup</a>(ip1) idiom.</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Fidup'><a class='func-ref' href='#Fidup'>idup</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip)
{
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
  ip-&gt;ref++;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
  <span class='reserved'>return</span> ip;
}

<span class='comment'>// Lock the given <a class='str-ref' href='#Sinode'>inode</a>.</span><span class='comment'>// Reads the <a class='str-ref' href='#Sinode'>inode</a> from disk <span class='reserved'>if</span> necessary.</span>void
<a name='Filock'><a class='func-ref' href='#Filock'>ilock</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a> *dip;

  <span class='reserved'>if</span>(ip == 0 || ip-&gt;ref &lt; 1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Filock'>ilock</a>");

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
  <span class='reserved'>while</span>(ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AI_BUSY'>I_BUSY</a>)
    <a class='func-ref' href='#Fsleep'>sleep</a>(ip, &<a class='str-ref' href='#Sicache'>icache</a>.lock);
  ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> |= <a class='define-ref' href='#AI_BUSY'>I_BUSY</a>;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);

  <span class='reserved'>if</span>(!(ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AI_VALID'>I_VALID</a>)){
    bp = <a class='func-ref' href='#Fbread'>bread</a>(ip-&gt;dev, <a class='define-ref' href='#AIBLOCK'>IBLOCK</a>(ip-&gt;inum));
    dip = (<span class='reserved'>struct</span> <a class='str-ref' href='#Sdinode'>dinode</a>*)bp-&gt;data + ip-&gt;inum%<a class='define-ref' href='#AIPB'>IPB</a>;
    ip-&gt;type = dip-&gt;type;
    ip-&gt;major = dip-&gt;major;
    ip-&gt;minor = dip-&gt;minor;
    ip-&gt;nlink = dip-&gt;nlink;
    ip-&gt;size = dip-&gt;size;
    <a class='func-ref' href='#Fmemmove'>memmove</a>(ip-&gt;addrs, dip-&gt;addrs, sizeof(ip-&gt;addrs));
    <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
    ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> |= <a class='define-ref' href='#AI_VALID'>I_VALID</a>;
    <span class='reserved'>if</span>(ip-&gt;type == 0)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Filock'>ilock</a>: no type");
  }
}

<span class='comment'>// Unlock the given <a class='str-ref' href='#Sinode'>inode</a>.</span>void
<a name='Fiunlock'><a class='func-ref' href='#Fiunlock'>iunlock</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip)
{
  <span class='reserved'>if</span>(ip == 0 || !(ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AI_BUSY'>I_BUSY</a>) || ip-&gt;ref &lt; 1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fiunlock'>iunlock</a>");

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
  ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> &= ~<a class='define-ref' href='#AI_BUSY'>I_BUSY</a>;
  <a class='func-ref' href='#Fwakeup'>wakeup</a>(ip);
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
}

<span class='comment'>// Drop a reference to an in-memory <a class='str-ref' href='#Sinode'>inode</a>.</span><span class='comment'>// If that was the last reference, the <a class='str-ref' href='#Sinode'>inode</a> cache <a class='func-ref' href='#Fentry'>entry</a> can</span><span class='comment'>// be recycled.</span><span class='comment'>// If that was the last reference and the <a class='str-ref' href='#Sinode'>inode</a> has no links</span><span class='comment'>// to it, free the <a class='str-ref' href='#Sinode'>inode</a> (and its content) on disk.</span>void
<a name='Fiput'><a class='func-ref' href='#Fiput'>iput</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip)
{
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
  <span class='reserved'>if</span>(ip-&gt;ref == 1 && (ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AI_VALID'>I_VALID</a>) && ip-&gt;nlink == 0){
    <span class='comment'>// <a class='str-ref' href='#Sinode'>inode</a> has no links: truncate and free <a class='str-ref' href='#Sinode'>inode</a>.</span>    <span class='reserved'>if</span>(ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AI_BUSY'>I_BUSY</a>)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fiput'>iput</a> busy");
    ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> |= <a class='define-ref' href='#AI_BUSY'>I_BUSY</a>;
    <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
    <a class='func-ref' href='#Fitrunc'>itrunc</a>(ip);
    ip-&gt;type = 0;
    <a class='func-ref' href='#Fiupdate'>iupdate</a>(ip);
    <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
    ip-&gt;<a class='define-ref' href='#Aflags'>flags</a> = 0;
    <a class='func-ref' href='#Fwakeup'>wakeup</a>(ip);
  }
  ip-&gt;ref--;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sicache'>icache</a>.lock);
}

<span class='comment'>// Common idiom: unlock, then put.</span>void
<a name='Fiunlockput'><a class='func-ref' href='#Fiunlockput'>iunlockput</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip)
{
  <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip);
  <a class='func-ref' href='#Fiput'>iput</a>(ip);
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Inode content</span><span class='comment'>//</span><span class='comment'>// The content (data) associated with each <a class='str-ref' href='#Sinode'>inode</a> is stored</span><span class='comment'>// in blocks on the disk. The first <a class='define-ref' href='#ANDIRECT'>NDIRECT</a> block numbers</span><span class='comment'>// are listed in ip-&gt;addrs[].  The next <a class='define-ref' href='#ANINDIRECT'>NINDIRECT</a> blocks are </span><span class='comment'>// listed in block ip-&gt;addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>].</span>
<span class='comment'>// Return the disk block address of the nth block in <a class='str-ref' href='#Sinode'>inode</a> ip.</span><span class='comment'>// If there is no such block, <a class='func-ref' href='#Fbmap'>bmap</a> allocates one.</span><span class='reserved'>static</span> uint
<a name='Fbmap'><a class='func-ref' href='#Fbmap'>bmap</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, uint bn)
{
  uint addr, *a;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;

  <span class='reserved'>if</span>(bn &lt; <a class='define-ref' href='#ANDIRECT'>NDIRECT</a>){
    <span class='reserved'>if</span>((addr = ip-&gt;addrs[bn]) == 0)
      ip-&gt;addrs[bn] = addr = <a class='func-ref' href='#Fballoc'>balloc</a>(ip-&gt;dev);
    <span class='reserved'>return</span> addr;
  }
  bn -= <a class='define-ref' href='#ANDIRECT'>NDIRECT</a>;

  <span class='reserved'>if</span>(bn &lt; <a class='define-ref' href='#ANINDIRECT'>NINDIRECT</a>){
    <span class='comment'>// Load indirect block, allocating <span class='reserved'>if</span> necessary.</span>    <span class='reserved'>if</span>((addr = ip-&gt;addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>]) == 0)
      ip-&gt;addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>] = addr = <a class='func-ref' href='#Fballoc'>balloc</a>(ip-&gt;dev);
    bp = <a class='func-ref' href='#Fbread'>bread</a>(ip-&gt;dev, addr);
    a = (uint*)bp-&gt;data;
    <span class='reserved'>if</span>((addr = a[bn]) == 0){
      a[bn] = addr = <a class='func-ref' href='#Fballoc'>balloc</a>(ip-&gt;dev);
      <a class='func-ref' href='#Flog_write'>log_write</a>(bp);
    }
    <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
    <span class='reserved'>return</span> addr;
  }

  <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fbmap'>bmap</a>: out of range");
}

<span class='comment'>// Truncate <a class='str-ref' href='#Sinode'>inode</a> (discard contents).</span><span class='comment'>// Only called when the <a class='str-ref' href='#Sinode'>inode</a> has no links</span><span class='comment'>// to it (no directory entries referring to it)</span><span class='comment'>// and has no in-memory reference to it (is</span><span class='comment'>// not an open <a class='str-ref' href='#Sfile'>file</a> or current directory).</span><span class='reserved'>static</span> void
<a name='Fitrunc'><a class='func-ref' href='#Fitrunc'>itrunc</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip)
{
  int i, j;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;
  uint *a;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; <a class='define-ref' href='#ANDIRECT'>NDIRECT</a>; i++){
    <span class='reserved'>if</span>(ip-&gt;addrs[i]){
      <a class='func-ref' href='#Fbfree'>bfree</a>(ip-&gt;dev, ip-&gt;addrs[i]);
      ip-&gt;addrs[i] = 0;
    }
  }
  
  <span class='reserved'>if</span>(ip-&gt;addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>]){
    bp = <a class='func-ref' href='#Fbread'>bread</a>(ip-&gt;dev, ip-&gt;addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>]);
    a = (uint*)bp-&gt;data;
    <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(j = 0; j &lt; <a class='define-ref' href='#ANINDIRECT'>NINDIRECT</a>; j++){
      <span class='reserved'>if</span>(a[j])
        <a class='func-ref' href='#Fbfree'>bfree</a>(ip-&gt;dev, a[j]);
    }
    <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
    <a class='func-ref' href='#Fbfree'>bfree</a>(ip-&gt;dev, ip-&gt;addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>]);
    ip-&gt;addrs[<a class='define-ref' href='#ANDIRECT'>NDIRECT</a>] = 0;
  }

  ip-&gt;size = 0;
  <a class='func-ref' href='#Fiupdate'>iupdate</a>(ip);
}

<span class='comment'>// Copy <a class='str-ref' href='#Sstat'>stat</a> information from <a class='str-ref' href='#Sinode'>inode</a>.</span>void
<a name='Fstati'><a class='func-ref' href='#Fstati'>stati</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, <span class='reserved'>struct</span> <a class='str-ref' href='#Sstat'>stat</a> *st)
{
  st-&gt;dev = ip-&gt;dev;
  st-&gt;ino = ip-&gt;inum;
  st-&gt;type = ip-&gt;type;
  st-&gt;nlink = ip-&gt;nlink;
  st-&gt;size = ip-&gt;size;
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Read data from <a class='str-ref' href='#Sinode'>inode</a>.</span>int
<a name='Freadi'><a class='func-ref' href='#Freadi'>readi</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, char *dst, uint off, uint n)
{
  uint tot, m;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;

  <span class='reserved'>if</span>(ip-&gt;type == <a class='define-ref' href='#AT_DEV'>T_DEV</a>){
    <span class='reserved'>if</span>(ip-&gt;major &lt; 0 || ip-&gt;major &gt;= <a class='define-ref' href='#ANDEV'>NDEV</a> || !<a class='str-ref' href='#Sdevsw'>devsw</a>[ip-&gt;major].read)
      <span class='reserved'>return</span> -1;
    <span class='reserved'>return</span> <a class='str-ref' href='#Sdevsw'>devsw</a>[ip-&gt;major].read(ip, dst, n);
  }

  <span class='reserved'>if</span>(off &gt; ip-&gt;size || off + n &lt; off)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(off + n &gt; ip-&gt;size)
    n = ip-&gt;size - off;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(tot=0; tot&lt;n; tot+=m, off+=m, dst+=m){
    bp = <a class='func-ref' href='#Fbread'>bread</a>(ip-&gt;dev, <a class='func-ref' href='#Fbmap'>bmap</a>(ip, off/<a class='define-ref' href='#ABSIZE'>BSIZE</a>));
    m = <a class='define-ref' href='#Amin'>min</a>(n - tot, <a class='define-ref' href='#ABSIZE'>BSIZE</a> - off%<a class='define-ref' href='#ABSIZE'>BSIZE</a>);
    <a class='func-ref' href='#Fmemmove'>memmove</a>(dst, bp-&gt;data + off%<a class='define-ref' href='#ABSIZE'>BSIZE</a>, m);
    <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
  }
  <span class='reserved'>return</span> n;
}

<span class='comment'>// PAGEBREAK!</span><span class='comment'>// Write data to <a class='str-ref' href='#Sinode'>inode</a>.</span>int
<a name='Fwritei'><a class='func-ref' href='#Fwritei'>writei</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, char *src, uint off, uint n)
{
  uint tot, m;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sbuf'>buf</a> *bp;

  <span class='reserved'>if</span>(ip-&gt;type == <a class='define-ref' href='#AT_DEV'>T_DEV</a>){
    <span class='reserved'>if</span>(ip-&gt;major &lt; 0 || ip-&gt;major &gt;= <a class='define-ref' href='#ANDEV'>NDEV</a> || !<a class='str-ref' href='#Sdevsw'>devsw</a>[ip-&gt;major].write)
      <span class='reserved'>return</span> -1;
    <span class='reserved'>return</span> <a class='str-ref' href='#Sdevsw'>devsw</a>[ip-&gt;major].write(ip, src, n);
  }

  <span class='reserved'>if</span>(off &gt; ip-&gt;size || off + n &lt; off)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(off + n &gt; <a class='define-ref' href='#AMAXFILE'>MAXFILE</a>*<a class='define-ref' href='#ABSIZE'>BSIZE</a>)
    <span class='reserved'>return</span> -1;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(tot=0; tot&lt;n; tot+=m, off+=m, src+=m){
    bp = <a class='func-ref' href='#Fbread'>bread</a>(ip-&gt;dev, <a class='func-ref' href='#Fbmap'>bmap</a>(ip, off/<a class='define-ref' href='#ABSIZE'>BSIZE</a>));
    m = <a class='define-ref' href='#Amin'>min</a>(n - tot, <a class='define-ref' href='#ABSIZE'>BSIZE</a> - off%<a class='define-ref' href='#ABSIZE'>BSIZE</a>);
    <a class='func-ref' href='#Fmemmove'>memmove</a>(bp-&gt;data + off%<a class='define-ref' href='#ABSIZE'>BSIZE</a>, src, m);
    <a class='func-ref' href='#Flog_write'>log_write</a>(bp);
    <a class='func-ref' href='#Fbrelse'>brelse</a>(bp);
  }

  <span class='reserved'>if</span>(n &gt; 0 && off &gt; ip-&gt;size){
    ip-&gt;size = off;
    <a class='func-ref' href='#Fiupdate'>iupdate</a>(ip);
  }
  <span class='reserved'>return</span> n;
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Directories</span>
int
<a name='Fnamecmp'><a class='func-ref' href='#Fnamecmp'>namecmp</a></a>(const char *s, const char *t)
{
  <span class='reserved'>return</span> <a class='func-ref' href='#Fstrncmp'>strncmp</a>(s, t, <a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>);
}

<span class='comment'>// Look <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a directory <a class='func-ref' href='#Fentry'>entry</a> in a directory.</span><span class='comment'>// If <a class='func-ref' href='#Ffound'>found</a>, set *poff to byte offset of <a class='func-ref' href='#Fentry'>entry</a>.</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Fdirlookup'><a class='func-ref' href='#Fdirlookup'>dirlookup</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *dp, char *name, uint *poff)
{
  uint off, inum;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sdirent'>dirent</a> de;

  <span class='reserved'>if</span>(dp-&gt;type != <a class='define-ref' href='#AT_DIR'>T_DIR</a>)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fdirlookup'>dirlookup</a> not DIR");

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(off = 0; off &lt; dp-&gt;size; off += sizeof(de)){
    <span class='reserved'>if</span>(<a class='func-ref' href='#Freadi'>readi</a>(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fdirlink'>dirlink</a> read");
    <span class='reserved'>if</span>(de.inum == 0)
      continue;
    <span class='reserved'>if</span>(<a class='func-ref' href='#Fnamecmp'>namecmp</a>(name, de.name) == 0){
      <span class='comment'>// <a class='func-ref' href='#Fentry'>entry</a> matches path element</span>      <span class='reserved'>if</span>(poff)
        *poff = off;
      inum = de.inum;
      <span class='reserved'>return</span> <a class='func-ref' href='#Figet'>iget</a>(dp-&gt;dev, inum);
    }
  }

  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Write a new directory <a class='func-ref' href='#Fentry'>entry</a> (name, inum) into the directory dp.</span>int
<a name='Fdirlink'><a class='func-ref' href='#Fdirlink'>dirlink</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *dp, char *name, uint inum)
{
  int off;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sdirent'>dirent</a> de;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip;

  <span class='comment'>// Check that name is not present.</span>  <span class='reserved'>if</span>((ip = <a class='func-ref' href='#Fdirlookup'>dirlookup</a>(dp, name, 0)) != 0){
    <a class='func-ref' href='#Fiput'>iput</a>(ip);
    <span class='reserved'>return</span> -1;
  }

  <span class='comment'>// Look <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> an empty <a class='str-ref' href='#Sdirent'>dirent</a>.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(off = 0; off &lt; dp-&gt;size; off += sizeof(de)){
    <span class='reserved'>if</span>(<a class='func-ref' href='#Freadi'>readi</a>(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fdirlink'>dirlink</a> read");
    <span class='reserved'>if</span>(de.inum == 0)
      <span class='reserved'>break</span>;
  }

  <a class='func-ref' href='#Fstrncpy'>strncpy</a>(de.name, name, <a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>);
  de.inum = inum;
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fwritei'>writei</a>(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fdirlink'>dirlink</a>");
  
  <span class='reserved'>return</span> 0;
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Paths</span>
<span class='comment'>// Copy the next path element from path into name.</span><span class='comment'>// Return a pointer to the element following the copied one.</span><span class='comment'>// The returned path has no leading slashes,</span><span class='comment'>// so the caller can check *path=='\0' to see <span class='reserved'>if</span> the name is the last one.</span><span class='comment'>// If no name to remove, <span class='reserved'>return</span> 0.</span><span class='comment'>//</span><span class='comment'>// Examples:</span><span class='comment'>//   <a class='func-ref' href='#Fskipelem'>skipelem</a>("a/bb/c", name) = "bb/c", setting name = "a"</span><span class='comment'>//   <a class='func-ref' href='#Fskipelem'>skipelem</a>("///a//bb", name) = "bb", setting name = "a"</span><span class='comment'>//   <a class='func-ref' href='#Fskipelem'>skipelem</a>("a", name) = "", setting name = "a"</span><span class='comment'>//   <a class='func-ref' href='#Fskipelem'>skipelem</a>("", name) = <a class='func-ref' href='#Fskipelem'>skipelem</a>("////", name) = 0</span><span class='comment'>//</span><span class='reserved'>static</span> char*
<a name='Fskipelem'><a class='func-ref' href='#Fskipelem'>skipelem</a></a>(char *path, char *name)
{
  char *s;
  int len;

  <span class='reserved'>while</span>(*path == '/')
    path++;
  <span class='reserved'>if</span>(*path == 0)
    <span class='reserved'>return</span> 0;
  s = path;
  <span class='reserved'>while</span>(*path != '/' && *path != 0)
    path++;
  len = path - s;
  <span class='reserved'>if</span>(len &gt;= <a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>)
    <a class='func-ref' href='#Fmemmove'>memmove</a>(name, s, <a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>);
  <span class='reserved'>else</span> {
    <a class='func-ref' href='#Fmemmove'>memmove</a>(name, s, len);
    name[len] = 0;
  }
  <span class='reserved'>while</span>(*path == '/')
    path++;
  <span class='reserved'>return</span> path;
}

<span class='comment'>// Look up and <span class='reserved'>return</span> the <a class='str-ref' href='#Sinode'>inode</a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a path name.</span><span class='comment'>// If parent != 0, <span class='reserved'>return</span> the <a class='str-ref' href='#Sinode'>inode</a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the parent and copy the final</span><span class='comment'>// path element into name, which must have room <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> <a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a> bytes.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Fnamex'><a class='func-ref' href='#Fnamex'>namex</a></a>(char *path, int <a class='func-ref' href='#Fnameiparent'>nameiparent</a>, char *name)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, *next;

  <span class='reserved'>if</span>(*path == '/')
    ip = <a class='func-ref' href='#Figet'>iget</a>(<a class='define-ref' href='#AROOTDEV'>ROOTDEV</a>, <a class='define-ref' href='#AROOTINO'>ROOTINO</a>);
  <span class='reserved'>else</span>
    ip = <a class='func-ref' href='#Fidup'>idup</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;cwd);

  <span class='reserved'>while</span>((path = <a class='func-ref' href='#Fskipelem'>skipelem</a>(path, name)) != 0){
    <a class='func-ref' href='#Filock'>ilock</a>(ip);
    <span class='reserved'>if</span>(ip-&gt;type != <a class='define-ref' href='#AT_DIR'>T_DIR</a>){
      <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
      <span class='reserved'>return</span> 0;
    }
    <span class='reserved'>if</span>(<a class='func-ref' href='#Fnameiparent'>nameiparent</a> && *path == '\0'){
      <span class='comment'>// Stop one level early.</span>      <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip);
      <span class='reserved'>return</span> ip;
    }
    <span class='reserved'>if</span>((next = <a class='func-ref' href='#Fdirlookup'>dirlookup</a>(ip, name, 0)) == 0){
      <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
      <span class='reserved'>return</span> 0;
    }
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
    ip = next;
  }
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fnameiparent'>nameiparent</a>){
    <a class='func-ref' href='#Fiput'>iput</a>(ip);
    <span class='reserved'>return</span> 0;
  }
  <span class='reserved'>return</span> ip;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Fnamei'><a class='func-ref' href='#Fnamei'>namei</a></a>(char *path)
{
  char name[<a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>];
  <span class='reserved'>return</span> <a class='func-ref' href='#Fnamex'>namex</a>(path, 0, name);
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Fnameiparent'><a class='func-ref' href='#Fnameiparent'>nameiparent</a></a>(char *path, char *name)
{
  <span class='reserved'>return</span> <a class='func-ref' href='#Fnamex'>namex</a>(path, 1, name);
}



<hr/><a name='Ifile.c'>###### <a class='page-ref' href='#Ifile.c'><a class='str-ref' href='#Sfile'>file</a>.c</a> ########</a>

<span class='comment'>//</span><span class='comment'>// File descriptors</span><span class='comment'>//</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifs.h'>fs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifile.h'><a class='str-ref' href='#Sfile'>file</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"

<span class='reserved'>struct</span> <a class='str-ref' href='#Sdevsw'>devsw</a> <a class='str-ref' href='#Sdevsw'>devsw</a>[<a class='define-ref' href='#ANDEV'>NDEV</a>];
<a name='Sftable'></a><span class='reserved'>struct</span> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> <a class='str-ref' href='#Sfile'>file</a>[<a class='define-ref' href='#ANFILE'>NFILE</a>];
} <a class='str-ref' href='#Sftable'>ftable</a>;

void
<a name='Ffileinit'><a class='func-ref' href='#Ffileinit'>fileinit</a></a>(void)
{
  <a class='func-ref' href='#Finitlock'>initlock</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock, "<a class='str-ref' href='#Sftable'>ftable</a>");
}

<span class='comment'>// Allocate a <a class='str-ref' href='#Sfile'>file</a> structure.</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*
<a name='Ffilealloc'><a class='func-ref' href='#Ffilealloc'>filealloc</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(f = <a class='str-ref' href='#Sftable'>ftable</a>.<a class='str-ref' href='#Sfile'>file</a>; f &lt; <a class='str-ref' href='#Sftable'>ftable</a>.<a class='str-ref' href='#Sfile'>file</a> + <a class='define-ref' href='#ANFILE'>NFILE</a>; f++){
    <span class='reserved'>if</span>(f-&gt;ref == 0){
      f-&gt;ref = 1;
      <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
      <span class='reserved'>return</span> f;
    }
  }
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Increment ref count <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> <a class='str-ref' href='#Sfile'>file</a> f.</span><span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>*
<a name='Ffiledup'><a class='func-ref' href='#Ffiledup'>filedup</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f)
{
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
  <span class='reserved'>if</span>(f-&gt;ref &lt; 1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Ffiledup'>filedup</a>");
  f-&gt;ref++;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
  <span class='reserved'>return</span> f;
}

<span class='comment'>// Close <a class='str-ref' href='#Sfile'>file</a> f.  (Decrement ref count, close when reaches 0.)</span>void
<a name='Ffileclose'><a class='func-ref' href='#Ffileclose'>fileclose</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> ff;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
  <span class='reserved'>if</span>(f-&gt;ref &lt; 1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Ffileclose'>fileclose</a>");
  <span class='reserved'>if</span>(--f-&gt;ref &gt; 0){
    <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
    <span class='reserved'>return</span>;
  }
  ff = *f;
  f-&gt;ref = 0;
  f-&gt;type = FD_NONE;
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sftable'>ftable</a>.lock);
  
  <span class='reserved'>if</span>(ff.type == FD_PIPE)
    <a class='func-ref' href='#Fpipeclose'>pipeclose</a>(ff.<a class='str-ref' href='#Spipe'>pipe</a>, ff.writable);
  <span class='reserved'>else</span> <span class='reserved'>if</span>(ff.type == FD_INODE){
    <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();
    <a class='func-ref' href='#Fiput'>iput</a>(ff.ip);
    <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
  }
}

<span class='comment'>// Get metadata about <a class='str-ref' href='#Sfile'>file</a> f.</span>int
<a name='Ffilestat'><a class='func-ref' href='#Ffilestat'>filestat</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f, <span class='reserved'>struct</span> <a class='str-ref' href='#Sstat'>stat</a> *st)
{
  <span class='reserved'>if</span>(f-&gt;type == FD_INODE){
    <a class='func-ref' href='#Filock'>ilock</a>(f-&gt;ip);
    <a class='func-ref' href='#Fstati'>stati</a>(f-&gt;ip, st);
    <a class='func-ref' href='#Fiunlock'>iunlock</a>(f-&gt;ip);
    <span class='reserved'>return</span> 0;
  }
  <span class='reserved'>return</span> -1;
}

<span class='comment'>// Read from <a class='str-ref' href='#Sfile'>file</a> f.</span>int
<a name='Ffileread'><a class='func-ref' href='#Ffileread'>fileread</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f, char *addr, int n)
{
  int r;

  <span class='reserved'>if</span>(f-&gt;readable == 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(f-&gt;type == FD_PIPE)
    <span class='reserved'>return</span> <a class='func-ref' href='#Fpiperead'>piperead</a>(f-&gt;<a class='str-ref' href='#Spipe'>pipe</a>, addr, n);
  <span class='reserved'>if</span>(f-&gt;type == FD_INODE){
    <a class='func-ref' href='#Filock'>ilock</a>(f-&gt;ip);
    <span class='reserved'>if</span>((r = <a class='func-ref' href='#Freadi'>readi</a>(f-&gt;ip, addr, f-&gt;off, n)) &gt; 0)
      f-&gt;off += r;
    <a class='func-ref' href='#Fiunlock'>iunlock</a>(f-&gt;ip);
    <span class='reserved'>return</span> r;
  }
  <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Ffileread'>fileread</a>");
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Write to <a class='str-ref' href='#Sfile'>file</a> f.</span>int
<a name='Ffilewrite'><a class='func-ref' href='#Ffilewrite'>filewrite</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f, char *addr, int n)
{
  int r;

  <span class='reserved'>if</span>(f-&gt;writable == 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(f-&gt;type == FD_PIPE)
    <span class='reserved'>return</span> <a class='func-ref' href='#Fpipewrite'>pipewrite</a>(f-&gt;<a class='str-ref' href='#Spipe'>pipe</a>, addr, n);
  <span class='reserved'>if</span>(f-&gt;type == FD_INODE){
    <span class='comment'>// write a few blocks at a time to avoid exceeding</span>    <span class='comment'>// the maximum <a class='str-ref' href='#Slog'>log</a> transaction size, including</span>    <span class='comment'>// i-node, indirect block, allocation blocks,</span>    <span class='comment'>// and 2 blocks of slop <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> non-aligned writes.</span>    <span class='comment'>// this really belongs lower down, since <a class='func-ref' href='#Fwritei'>writei</a>()</span>    <span class='comment'>// might be writing a device like the console.</span>    int max = ((<a class='define-ref' href='#ALOGSIZE'>LOGSIZE</a>-1-1-2) / 2) * 512;
    int i = 0;
    <span class='reserved'>while</span>(i &lt; n){
      int n1 = n - i;
      <span class='reserved'>if</span>(n1 &gt; max)
        n1 = max;

      <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();
      <a class='func-ref' href='#Filock'>ilock</a>(f-&gt;ip);
      <span class='reserved'>if</span> ((r = <a class='func-ref' href='#Fwritei'>writei</a>(f-&gt;ip, addr + i, f-&gt;off, n1)) &gt; 0)
        f-&gt;off += r;
      <a class='func-ref' href='#Fiunlock'>iunlock</a>(f-&gt;ip);
      <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();

      <span class='reserved'>if</span>(r &lt; 0)
        <span class='reserved'>break</span>;
      <span class='reserved'>if</span>(r != n1)
        <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("short <a class='func-ref' href='#Ffilewrite'>filewrite</a>");
      i += r;
    }
    <span class='reserved'>return</span> i == n ? n : -1;
  }
  <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Ffilewrite'>filewrite</a>");
}




<hr/><a name='Isysfile.c'>###### <a class='page-ref' href='#Isysfile.c'>sysfile.c</a> ########</a>

<span class='comment'>//</span><span class='comment'>// File-system system calls.</span><span class='comment'>// Mostly argument checking, since we don't trust</span><span class='comment'>// user code, and calls into <a class='page-ref' href='#Ifile.c'><a class='str-ref' href='#Sfile'>file</a>.c</a> and <a class='page-ref' href='#Ifs.c'>fs.c</a>.</span><span class='comment'>//</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Istat.h'><a class='str-ref' href='#Sstat'>stat</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifs.h'>fs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifile.h'><a class='str-ref' href='#Sfile'>file</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifcntl.h'>fcntl.h</a>"

<span class='comment'>// Fetch the nth word-sized system call argument as a <a class='str-ref' href='#Sfile'>file</a> descriptor</span><span class='comment'>// and <span class='reserved'>return</span> both the descriptor and the corresponding <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a>.</span><span class='reserved'>static</span> int
<a name='Fargfd'><a class='func-ref' href='#Fargfd'>argfd</a></a>(int n, int *pfd, <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> **pf)
{
  int fd;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargint'>argint</a>(n, &fd) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(fd &lt; 0 || fd &gt;= <a class='define-ref' href='#ANOFILE'>NOFILE</a> || (f=<a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd]) == 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(pfd)
    *pfd = fd;
  <span class='reserved'>if</span>(pf)
    *pf = f;
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Allocate a <a class='str-ref' href='#Sfile'>file</a> descriptor <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the given <a class='str-ref' href='#Sfile'>file</a>.</span><span class='comment'>// Takes over <a class='str-ref' href='#Sfile'>file</a> reference from caller on success.</span><span class='reserved'>static</span> int
<a name='Ffdalloc'><a class='func-ref' href='#Ffdalloc'>fdalloc</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f)
{
  int fd;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(fd = 0; fd &lt; <a class='define-ref' href='#ANOFILE'>NOFILE</a>; fd++){
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd] == 0){
      <a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd] = f;
      <span class='reserved'>return</span> fd;
    }
  }
  <span class='reserved'>return</span> -1;
}

int
<a name='Fsys_dup'><a class='func-ref' href='#Fsys_dup'>sys_dup</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;
  int fd;
  
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargfd'>argfd</a>(0, 0, &f) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>((fd=<a class='func-ref' href='#Ffdalloc'>fdalloc</a>(f)) &lt; 0)
    <span class='reserved'>return</span> -1;
  <a class='func-ref' href='#Ffiledup'>filedup</a>(f);
  <span class='reserved'>return</span> fd;
}

int
<a name='Fsys_read'><a class='func-ref' href='#Fsys_read'>sys_read</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;
  int n;
  char *p;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargfd'>argfd</a>(0, 0, &f) &lt; 0 || <a class='func-ref' href='#Fargint'>argint</a>(2, &n) &lt; 0 || <a class='func-ref' href='#Fargptr'>argptr</a>(1, &p, n) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> <a class='func-ref' href='#Ffileread'>fileread</a>(f, p, n);
}

int
<a name='Fsys_write'><a class='func-ref' href='#Fsys_write'>sys_write</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;
  int n;
  char *p;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargfd'>argfd</a>(0, 0, &f) &lt; 0 || <a class='func-ref' href='#Fargint'>argint</a>(2, &n) &lt; 0 || <a class='func-ref' href='#Fargptr'>argptr</a>(1, &p, n) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> <a class='func-ref' href='#Ffilewrite'>filewrite</a>(f, p, n);
}

int
<a name='Fsys_close'><a class='func-ref' href='#Fsys_close'>sys_close</a></a>(void)
{
  int fd;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;
  
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargfd'>argfd</a>(0, &fd, &f) &lt; 0)
    <span class='reserved'>return</span> -1;
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd] = 0;
  <a class='func-ref' href='#Ffileclose'>fileclose</a>(f);
  <span class='reserved'>return</span> 0;
}

int
<a name='Fsys_fstat'><a class='func-ref' href='#Fsys_fstat'>sys_fstat</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sstat'>stat</a> *st;
  
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargfd'>argfd</a>(0, 0, &f) &lt; 0 || <a class='func-ref' href='#Fargptr'>argptr</a>(1, (void*)&st, sizeof(*st)) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> <a class='func-ref' href='#Ffilestat'>filestat</a>(f, st);
}

<span class='comment'>// Create the path new as a link to the same <a class='str-ref' href='#Sinode'>inode</a> as old.</span>int
<a name='Fsys_link'><a class='func-ref' href='#Fsys_link'>sys_link</a></a>(void)
{
  char name[<a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>], *new, *old;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *dp, *ip;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargstr'>argstr</a>(0, &old) &lt; 0 || <a class='func-ref' href='#Fargstr'>argstr</a>(1, &new) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>((ip = <a class='func-ref' href='#Fnamei'>namei</a>(old)) == 0)
    <span class='reserved'>return</span> -1;

  <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();

  <a class='func-ref' href='#Filock'>ilock</a>(ip);
  <span class='reserved'>if</span>(ip-&gt;type == <a class='define-ref' href='#AT_DIR'>T_DIR</a>){
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
    <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
    <span class='reserved'>return</span> -1;
  }

  ip-&gt;nlink++;
  <a class='func-ref' href='#Fiupdate'>iupdate</a>(ip);
  <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip);

  <span class='reserved'>if</span>((dp = <a class='func-ref' href='#Fnameiparent'>nameiparent</a>(new, name)) == 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  <a class='func-ref' href='#Filock'>ilock</a>(dp);
  <span class='reserved'>if</span>(dp-&gt;dev != ip-&gt;dev || <a class='func-ref' href='#Fdirlink'>dirlink</a>(dp, name, ip-&gt;inum) &lt; 0){
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(dp);
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  }
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(dp);
  <a class='func-ref' href='#Fiput'>iput</a>(ip);

  <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();

  <span class='reserved'>return</span> 0;

<a name='Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a></a>:
  <a class='func-ref' href='#Filock'>ilock</a>(ip);
  ip-&gt;nlink--;
  <a class='func-ref' href='#Fiupdate'>iupdate</a>(ip);
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
  <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
  <span class='reserved'>return</span> -1;
}

<span class='comment'>// Is the directory dp empty except <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> "." and ".." ?</span><span class='reserved'>static</span> int
<a name='Fisdirempty'><a class='func-ref' href='#Fisdirempty'>isdirempty</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *dp)
{
  int off;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sdirent'>dirent</a> de;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(off=2*sizeof(de); off&lt;dp-&gt;size; off+=sizeof(de)){
    <span class='reserved'>if</span>(<a class='func-ref' href='#Freadi'>readi</a>(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fisdirempty'>isdirempty</a>: <a class='func-ref' href='#Freadi'>readi</a>");
    <span class='reserved'>if</span>(de.inum != 0)
      <span class='reserved'>return</span> 0;
  }
  <span class='reserved'>return</span> 1;
}

<span class='comment'>//PAGEBREAK!</span>int
<a name='Fsys_unlink'><a class='func-ref' href='#Fsys_unlink'>sys_unlink</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, *dp;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sdirent'>dirent</a> de;
  char name[<a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>], *path;
  uint off;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargstr'>argstr</a>(0, &path) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>((dp = <a class='func-ref' href='#Fnameiparent'>nameiparent</a>(path, name)) == 0)
    <span class='reserved'>return</span> -1;

  <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();

  <a class='func-ref' href='#Filock'>ilock</a>(dp);

  <span class='comment'>// Cannot unlink "." or "..".</span>  <span class='reserved'>if</span>(<a class='func-ref' href='#Fnamecmp'>namecmp</a>(name, ".") == 0 || <a class='func-ref' href='#Fnamecmp'>namecmp</a>(name, "..") == 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;

  <span class='reserved'>if</span>((ip = <a class='func-ref' href='#Fdirlookup'>dirlookup</a>(dp, name, &off)) == 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  <a class='func-ref' href='#Filock'>ilock</a>(ip);

  <span class='reserved'>if</span>(ip-&gt;nlink &lt; 1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("unlink: nlink &lt; 1");
  <span class='reserved'>if</span>(ip-&gt;type == <a class='define-ref' href='#AT_DIR'>T_DIR</a> && !<a class='func-ref' href='#Fisdirempty'>isdirempty</a>(ip)){
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  }

  <a class='func-ref' href='#Fmemset'>memset</a>(&de, 0, sizeof(de));
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fwritei'>writei</a>(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("unlink: <a class='func-ref' href='#Fwritei'>writei</a>");
  <span class='reserved'>if</span>(ip-&gt;type == <a class='define-ref' href='#AT_DIR'>T_DIR</a>){
    dp-&gt;nlink--;
    <a class='func-ref' href='#Fiupdate'>iupdate</a>(dp);
  }
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(dp);

  ip-&gt;nlink--;
  <a class='func-ref' href='#Fiupdate'>iupdate</a>(ip);
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);

  <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();

  <span class='reserved'>return</span> 0;

<a name='Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a></a>:
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(dp);
  <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
  <span class='reserved'>return</span> -1;
}

<span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a>*
<a name='Fcreate'><a class='func-ref' href='#Fcreate'>create</a></a>(char *path, short type, short major, short minor)
{
  uint off;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, *dp;
  char name[<a class='define-ref' href='#ADIRSIZ'>DIRSIZ</a>];

  <span class='reserved'>if</span>((dp = <a class='func-ref' href='#Fnameiparent'>nameiparent</a>(path, name)) == 0)
    <span class='reserved'>return</span> 0;
  <a class='func-ref' href='#Filock'>ilock</a>(dp);

  <span class='reserved'>if</span>((ip = <a class='func-ref' href='#Fdirlookup'>dirlookup</a>(dp, name, &off)) != 0){
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(dp);
    <a class='func-ref' href='#Filock'>ilock</a>(ip);
    <span class='reserved'>if</span>(type == <a class='define-ref' href='#AT_FILE'>T_FILE</a> && ip-&gt;type == <a class='define-ref' href='#AT_FILE'>T_FILE</a>)
      <span class='reserved'>return</span> ip;
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
    <span class='reserved'>return</span> 0;
  }

  <span class='reserved'>if</span>((ip = <a class='func-ref' href='#Fialloc'>ialloc</a>(dp-&gt;dev, type)) == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fcreate'>create</a>: <a class='func-ref' href='#Fialloc'>ialloc</a>");

  <a class='func-ref' href='#Filock'>ilock</a>(ip);
  ip-&gt;major = major;
  ip-&gt;minor = minor;
  ip-&gt;nlink = 1;
  <a class='func-ref' href='#Fiupdate'>iupdate</a>(ip);

  <span class='reserved'>if</span>(type == <a class='define-ref' href='#AT_DIR'>T_DIR</a>){  <span class='comment'>// Create . and .. entries.</span>    dp-&gt;nlink++;  <span class='comment'>// <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> ".."</span>    <a class='func-ref' href='#Fiupdate'>iupdate</a>(dp);
    <span class='comment'>// No ip-&gt;nlink++ <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> ".": avoid cyclic ref count.</span>    <span class='reserved'>if</span>(<a class='func-ref' href='#Fdirlink'>dirlink</a>(ip, ".", ip-&gt;inum) &lt; 0 || <a class='func-ref' href='#Fdirlink'>dirlink</a>(ip, "..", dp-&gt;inum) &lt; 0)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fcreate'>create</a> dots");
  }

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fdirlink'>dirlink</a>(dp, name, ip-&gt;inum) &lt; 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fcreate'>create</a>: <a class='func-ref' href='#Fdirlink'>dirlink</a>");

  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(dp);

  <span class='reserved'>return</span> ip;
}

int
<a name='Fsys_open'><a class='func-ref' href='#Fsys_open'>sys_open</a></a>(void)
{
  char *path;
  int fd, omode;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *f;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargstr'>argstr</a>(0, &path) &lt; 0 || <a class='func-ref' href='#Fargint'>argint</a>(1, &omode) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(omode & <a class='define-ref' href='#AO_CREATE'>O_CREATE</a>){
    <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();
    ip = <a class='func-ref' href='#Fcreate'>create</a>(path, <a class='define-ref' href='#AT_FILE'>T_FILE</a>, 0, 0);
    <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
    <span class='reserved'>if</span>(ip == 0)
      <span class='reserved'>return</span> -1;
  } <span class='reserved'>else</span> {
    <span class='reserved'>if</span>((ip = <a class='func-ref' href='#Fnamei'>namei</a>(path)) == 0)
      <span class='reserved'>return</span> -1;
    <a class='func-ref' href='#Filock'>ilock</a>(ip);
    <span class='reserved'>if</span>(ip-&gt;type == <a class='define-ref' href='#AT_DIR'>T_DIR</a> && omode != <a class='define-ref' href='#AO_RDONLY'>O_RDONLY</a>){
      <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
      <span class='reserved'>return</span> -1;
    }
  }

  <span class='reserved'>if</span>((f = <a class='func-ref' href='#Ffilealloc'>filealloc</a>()) == 0 || (fd = <a class='func-ref' href='#Ffdalloc'>fdalloc</a>(f)) &lt; 0){
    <span class='reserved'>if</span>(f)
      <a class='func-ref' href='#Ffileclose'>fileclose</a>(f);
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
    <span class='reserved'>return</span> -1;
  }
  <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip);

  f-&gt;type = FD_INODE;
  f-&gt;ip = ip;
  f-&gt;off = 0;
  f-&gt;readable = !(omode & <a class='define-ref' href='#AO_WRONLY'>O_WRONLY</a>);
  f-&gt;writable = (omode & <a class='define-ref' href='#AO_WRONLY'>O_WRONLY</a>) || (omode & <a class='define-ref' href='#AO_RDWR'>O_RDWR</a>);
  <span class='reserved'>return</span> fd;
}

int
<a name='Fsys_mkdir'><a class='func-ref' href='#Fsys_mkdir'>sys_mkdir</a></a>(void)
{
  char *path;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip;

  <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargstr'>argstr</a>(0, &path) &lt; 0 || (ip = <a class='func-ref' href='#Fcreate'>create</a>(path, <a class='define-ref' href='#AT_DIR'>T_DIR</a>, 0, 0)) == 0){
    <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
    <span class='reserved'>return</span> -1;
  }
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
  <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
  <span class='reserved'>return</span> 0;
}

int
<a name='Fsys_mknod'><a class='func-ref' href='#Fsys_mknod'>sys_mknod</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip;
  char *path;
  int len;
  int major, minor;
  
  <a class='func-ref' href='#Fbegin_trans'>begin_trans</a>();
  <span class='reserved'>if</span>((len=<a class='func-ref' href='#Fargstr'>argstr</a>(0, &path)) &lt; 0 ||
     <a class='func-ref' href='#Fargint'>argint</a>(1, &major) &lt; 0 ||
     <a class='func-ref' href='#Fargint'>argint</a>(2, &minor) &lt; 0 ||
     (ip = <a class='func-ref' href='#Fcreate'>create</a>(path, <a class='define-ref' href='#AT_DEV'>T_DEV</a>, major, minor)) == 0){
    <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
    <span class='reserved'>return</span> -1;
  }
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
  <a class='func-ref' href='#Fcommit_trans'>commit_trans</a>();
  <span class='reserved'>return</span> 0;
}

int
<a name='Fsys_chdir'><a class='func-ref' href='#Fsys_chdir'>sys_chdir</a></a>(void)
{
  char *path;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargstr'>argstr</a>(0, &path) &lt; 0 || (ip = <a class='func-ref' href='#Fnamei'>namei</a>(path)) == 0)
    <span class='reserved'>return</span> -1;
  <a class='func-ref' href='#Filock'>ilock</a>(ip);
  <span class='reserved'>if</span>(ip-&gt;type != <a class='define-ref' href='#AT_DIR'>T_DIR</a>){
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
    <span class='reserved'>return</span> -1;
  }
  <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip);
  <a class='func-ref' href='#Fiput'>iput</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;cwd);
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;cwd = ip;
  <span class='reserved'>return</span> 0;
}

int
<a name='Fsys_exec'><a class='func-ref' href='#Fsys_exec'>sys_exec</a></a>(void)
{
  char *path, *<a class='func-ref' href='#Fargv'>argv</a>[<a class='define-ref' href='#AMAXARG'>MAXARG</a>];
  int i;
  uint uargv, uarg;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargstr'>argstr</a>(0, &path) &lt; 0 || <a class='func-ref' href='#Fargint'>argint</a>(1, (int*)&uargv) &lt; 0){
    <span class='reserved'>return</span> -1;
  }
  <a class='func-ref' href='#Fmemset'>memset</a>(<a class='func-ref' href='#Fargv'>argv</a>, 0, sizeof(<a class='func-ref' href='#Fargv'>argv</a>));
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i=0;; i++){
    <span class='reserved'>if</span>(i &gt;= <a class='define-ref' href='#ANELEM'>NELEM</a>(<a class='func-ref' href='#Fargv'>argv</a>))
      <span class='reserved'>return</span> -1;
    <span class='reserved'>if</span>(<a class='func-ref' href='#Ffetchint'>fetchint</a>(uargv+4*i, (int*)&uarg) &lt; 0)
      <span class='reserved'>return</span> -1;
    <span class='reserved'>if</span>(uarg == 0){
      <a class='func-ref' href='#Fargv'>argv</a>[i] = 0;
      <span class='reserved'>break</span>;
    }
    <span class='reserved'>if</span>(<a class='func-ref' href='#Ffetchstr'>fetchstr</a>(uarg, &<a class='func-ref' href='#Fargv'>argv</a>[i]) &lt; 0)
      <span class='reserved'>return</span> -1;
  }
  <span class='reserved'>return</span> <a class='func-ref' href='#Fexec'>exec</a>(path, <a class='func-ref' href='#Fargv'>argv</a>);
}

int
<a name='Fsys_pipe'><a class='func-ref' href='#Fsys_pipe'>sys_pipe</a></a>(void)
{
  int *fd;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> *rf, *wf;
  int fd0, fd1;

  <span class='reserved'>if</span>(<a class='func-ref' href='#Fargptr'>argptr</a>(0, (void*)&fd, 2*sizeof(fd[0])) &lt; 0)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fpipealloc'>pipealloc</a>(&rf, &wf) &lt; 0)
    <span class='reserved'>return</span> -1;
  fd0 = -1;
  <span class='reserved'>if</span>((fd0 = <a class='func-ref' href='#Ffdalloc'>fdalloc</a>(rf)) &lt; 0 || (fd1 = <a class='func-ref' href='#Ffdalloc'>fdalloc</a>(wf)) &lt; 0){
    <span class='reserved'>if</span>(fd0 &gt;= 0)
      <a class='str-ref' href='#Sproc'>proc</a>-&gt;ofile[fd0] = 0;
    <a class='func-ref' href='#Ffileclose'>fileclose</a>(rf);
    <a class='func-ref' href='#Ffileclose'>fileclose</a>(wf);
    <span class='reserved'>return</span> -1;
  }
  fd[0] = fd0;
  fd[1] = fd1;
  <span class='reserved'>return</span> 0;
}



<hr/><a name='Iexec.c'>###### <a class='page-ref' href='#Iexec.c'><a class='func-ref' href='#Fexec'>exec</a>.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ielf.h'>elf.h</a>"

int
<a name='Fexec'><a class='func-ref' href='#Fexec'>exec</a></a>(char *path, char **<a class='func-ref' href='#Fargv'>argv</a>)
{
  char *s, *last;
  int i, off;
  uint argc, sz, sp, ustack[3+<a class='define-ref' href='#AMAXARG'>MAXARG</a>+1];
  <span class='reserved'>struct</span> <a class='str-ref' href='#Selfhdr'>elfhdr</a> elf;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproghdr'>proghdr</a> ph;
  pde_t *pgdir, *oldpgdir;

  <span class='reserved'>if</span>((ip = <a class='func-ref' href='#Fnamei'>namei</a>(path)) == 0)
    <span class='reserved'>return</span> -1;
  <a class='func-ref' href='#Filock'>ilock</a>(ip);
  pgdir = 0;

  <span class='comment'>// Check ELF header</span>  <span class='reserved'>if</span>(<a class='func-ref' href='#Freadi'>readi</a>(ip, (char*)&elf, 0, sizeof(elf)) &lt; sizeof(elf))
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  <span class='reserved'>if</span>(elf.<a class='define-ref' href='#Amagic'>magic</a> != <a class='define-ref' href='#AELF_MAGIC'>ELF_MAGIC</a>)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;

  <span class='reserved'>if</span>((pgdir = <a class='func-ref' href='#Fsetupkvm'>setupkvm</a>()) == 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;

  <span class='comment'>// Load program into memory.</span>  sz = 0;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i=0, off=elf.phoff; i&lt;elf.phnum; i++, off+=sizeof(ph)){
    <span class='reserved'>if</span>(<a class='func-ref' href='#Freadi'>readi</a>(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
    <span class='reserved'>if</span>(ph.type != <a class='define-ref' href='#AELF_PROG_LOAD'>ELF_PROG_LOAD</a>)
      continue;
    <span class='reserved'>if</span>(ph.memsz &lt; ph.filesz)
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
    <span class='reserved'>if</span>((sz = <a class='func-ref' href='#Fallocuvm'>allocuvm</a>(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
    <span class='reserved'>if</span>(<a class='func-ref' href='#Floaduvm'>loaduvm</a>(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) &lt; 0)
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  }
  <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
  ip = 0;

  <span class='comment'>// Allocate two pages at the next page boundary.</span>  <span class='comment'>// Make the first inaccessible.  Use the second as the user stack.</span>  sz = <a class='define-ref' href='#APGROUNDUP'>PGROUNDUP</a>(sz);
  <span class='reserved'>if</span>((sz = <a class='func-ref' href='#Fallocuvm'>allocuvm</a>(pgdir, sz, sz + 2*<a class='define-ref' href='#APGSIZE'>PGSIZE</a>)) == 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  <a class='func-ref' href='#Fclearpteu'>clearpteu</a>(pgdir, (char*)(sz - 2*<a class='define-ref' href='#APGSIZE'>PGSIZE</a>));
  sp = sz;

  <span class='comment'>// Push argument strings, prepare rest of stack in ustack.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(argc = 0; <a class='func-ref' href='#Fargv'>argv</a>[argc]; argc++) {
    <span class='reserved'>if</span>(argc &gt;= <a class='define-ref' href='#AMAXARG'>MAXARG</a>)
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
    sp = (sp - (<a class='func-ref' href='#Fstrlen'>strlen</a>(<a class='func-ref' href='#Fargv'>argv</a>[argc]) + 1)) & ~3;
    <span class='reserved'>if</span>(<a class='func-ref' href='#Fcopyout'>copyout</a>(pgdir, sp, <a class='func-ref' href='#Fargv'>argv</a>[argc], <a class='func-ref' href='#Fstrlen'>strlen</a>(<a class='func-ref' href='#Fargv'>argv</a>[argc]) + 1) &lt; 0)
      goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
    ustack[3+argc] = sp;
  }
  ustack[3+argc] = 0;

  ustack[0] = 0xffffffff;  <span class='comment'>// fake <span class='reserved'>return</span> PC</span>  ustack[1] = argc;
  ustack[2] = sp - (argc+1)*4;  <span class='comment'>// <a class='func-ref' href='#Fargv'>argv</a> pointer</span>
  sp -= (3+argc+1) * 4;
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fcopyout'>copyout</a>(pgdir, sp, ustack, (3+argc+1)*4) &lt; 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;

  <span class='comment'>// Save program name <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> debugging.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(last=s=path; *s; s++)
    <span class='reserved'>if</span>(*s == '/')
      last = s+1;
  <a class='func-ref' href='#Fsafestrcpy'>safestrcpy</a>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;name, last, sizeof(<a class='str-ref' href='#Sproc'>proc</a>-&gt;name));

  <span class='comment'>// Commit to the user image.</span>  oldpgdir = <a class='str-ref' href='#Sproc'>proc</a>-&gt;pgdir;
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;pgdir = pgdir;
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;sz = sz;
  <a class='str-ref' href='#Sproc'>proc</a>-&gt;tf-&gt;eip = elf.<a class='func-ref' href='#Fentry'>entry</a>;  <span class='comment'>// <a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a></span>  <a class='str-ref' href='#Sproc'>proc</a>-&gt;tf-&gt;esp = sp;
  <a class='func-ref' href='#Fswitchuvm'>switchuvm</a>(<a class='str-ref' href='#Sproc'>proc</a>);
  <a class='func-ref' href='#Ffreevm'>freevm</a>(oldpgdir);
  <span class='reserved'>return</span> 0;

 <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>:
  <span class='reserved'>if</span>(pgdir)
    <a class='func-ref' href='#Ffreevm'>freevm</a>(pgdir);
  <span class='reserved'>if</span>(ip)
    <a class='func-ref' href='#Fiunlockput'>iunlockput</a>(ip);
  <span class='reserved'>return</span> -1;
}



<hr/><a name='Ipipe.c'>###### <a class='page-ref' href='#Ipipe.c'><a class='str-ref' href='#Spipe'>pipe</a>.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifs.h'>fs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifile.h'><a class='str-ref' href='#Sfile'>file</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"

<a name='APIPESIZE'></a><span class='hash'>#define</span> <a class='define-ref' href='#APIPESIZE'>PIPESIZE</a> 512

<a name='Spipe'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  char data[<a class='define-ref' href='#APIPESIZE'>PIPESIZE</a>];
  uint nread;     <span class='comment'>// number of bytes read</span>  uint nwrite;    <span class='comment'>// number of bytes written</span>  int readopen;   <span class='comment'>// read fd is still open</span>  int writeopen;  <span class='comment'>// write fd is still open</span>};

int
<a name='Fpipealloc'><a class='func-ref' href='#Fpipealloc'>pipealloc</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> **f0, <span class='reserved'>struct</span> <a class='str-ref' href='#Sfile'>file</a> **f1)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a> *p;

  p = 0;
  *f0 = *f1 = 0;
  <span class='reserved'>if</span>((*f0 = <a class='func-ref' href='#Ffilealloc'>filealloc</a>()) == 0 || (*f1 = <a class='func-ref' href='#Ffilealloc'>filealloc</a>()) == 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  <span class='reserved'>if</span>((p = (<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a>*)<a class='func-ref' href='#Fkalloc'>kalloc</a>()) == 0)
    goto <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>;
  p-&gt;readopen = 1;
  p-&gt;writeopen = 1;
  p-&gt;nwrite = 0;
  p-&gt;nread = 0;
  <a class='func-ref' href='#Finitlock'>initlock</a>(&p-&gt;lock, "<a class='str-ref' href='#Spipe'>pipe</a>");
  (*f0)-&gt;type = FD_PIPE;
  (*f0)-&gt;readable = 1;
  (*f0)-&gt;writable = 0;
  (*f0)-&gt;<a class='str-ref' href='#Spipe'>pipe</a> = p;
  (*f1)-&gt;type = FD_PIPE;
  (*f1)-&gt;readable = 0;
  (*f1)-&gt;writable = 1;
  (*f1)-&gt;<a class='str-ref' href='#Spipe'>pipe</a> = p;
  <span class='reserved'>return</span> 0;

<span class='comment'>//PAGEBREAK: 20</span> <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a>:
  <span class='reserved'>if</span>(p)
    <a class='func-ref' href='#Fkfree'>kfree</a>((char*)p);
  <span class='reserved'>if</span>(*f0)
    <a class='func-ref' href='#Ffileclose'>fileclose</a>(*f0);
  <span class='reserved'>if</span>(*f1)
    <a class='func-ref' href='#Ffileclose'>fileclose</a>(*f1);
  <span class='reserved'>return</span> -1;
}

void
<a name='Fpipeclose'><a class='func-ref' href='#Fpipeclose'>pipeclose</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a> *p, int writable)
{
  <a class='func-ref' href='#Facquire'>acquire</a>(&p-&gt;lock);
  <span class='reserved'>if</span>(writable){
    p-&gt;writeopen = 0;
    <a class='func-ref' href='#Fwakeup'>wakeup</a>(&p-&gt;nread);
  } <span class='reserved'>else</span> {
    p-&gt;readopen = 0;
    <a class='func-ref' href='#Fwakeup'>wakeup</a>(&p-&gt;nwrite);
  }
  <span class='reserved'>if</span>(p-&gt;readopen == 0 && p-&gt;writeopen == 0){
    <a class='func-ref' href='#Frelease'>release</a>(&p-&gt;lock);
    <a class='func-ref' href='#Fkfree'>kfree</a>((char*)p);
  } <span class='reserved'>else</span>
    <a class='func-ref' href='#Frelease'>release</a>(&p-&gt;lock);
}

<span class='comment'>//PAGEBREAK: 40</span>int
<a name='Fpipewrite'><a class='func-ref' href='#Fpipewrite'>pipewrite</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a> *p, char *addr, int n)
{
  int i;

  <a class='func-ref' href='#Facquire'>acquire</a>(&p-&gt;lock);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; n; i++){
    <span class='reserved'>while</span>(p-&gt;nwrite == p-&gt;nread + <a class='define-ref' href='#APIPESIZE'>PIPESIZE</a>){  <span class='comment'>//DOC: <a class='func-ref' href='#Fpipewrite'>pipewrite</a>-full</span>      <span class='reserved'>if</span>(p-&gt;readopen == 0 || <a class='str-ref' href='#Sproc'>proc</a>-&gt;killed){
        <a class='func-ref' href='#Frelease'>release</a>(&p-&gt;lock);
        <span class='reserved'>return</span> -1;
      }
      <a class='func-ref' href='#Fwakeup'>wakeup</a>(&p-&gt;nread);
      <a class='func-ref' href='#Fsleep'>sleep</a>(&p-&gt;nwrite, &p-&gt;lock);  <span class='comment'>//DOC: <a class='func-ref' href='#Fpipewrite'>pipewrite</a>-<a class='func-ref' href='#Fsleep'>sleep</a></span>    }
    p-&gt;data[p-&gt;nwrite++ % <a class='define-ref' href='#APIPESIZE'>PIPESIZE</a>] = addr[i];
  }
  <a class='func-ref' href='#Fwakeup'>wakeup</a>(&p-&gt;nread);  <span class='comment'>//DOC: <a class='func-ref' href='#Fpipewrite'>pipewrite</a>-<a class='func-ref' href='#Fwakeup1'>wakeup1</a></span>  <a class='func-ref' href='#Frelease'>release</a>(&p-&gt;lock);
  <span class='reserved'>return</span> n;
}

int
<a name='Fpiperead'><a class='func-ref' href='#Fpiperead'>piperead</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Spipe'>pipe</a> *p, char *addr, int n)
{
  int i;

  <a class='func-ref' href='#Facquire'>acquire</a>(&p-&gt;lock);
  <span class='reserved'>while</span>(p-&gt;nread == p-&gt;nwrite && p-&gt;writeopen){  <span class='comment'>//DOC: <a class='str-ref' href='#Spipe'>pipe</a>-empty</span>    <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;killed){
      <a class='func-ref' href='#Frelease'>release</a>(&p-&gt;lock);
      <span class='reserved'>return</span> -1;
    }
    <a class='func-ref' href='#Fsleep'>sleep</a>(&p-&gt;nread, &p-&gt;lock); <span class='comment'>//DOC: <a class='func-ref' href='#Fpiperead'>piperead</a>-<a class='func-ref' href='#Fsleep'>sleep</a></span>  }
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; n; i++){  <span class='comment'>//DOC: <a class='func-ref' href='#Fpiperead'>piperead</a>-copy</span>    <span class='reserved'>if</span>(p-&gt;nread == p-&gt;nwrite)
      <span class='reserved'>break</span>;
    addr[i] = p-&gt;data[p-&gt;nread++ % <a class='define-ref' href='#APIPESIZE'>PIPESIZE</a>];
  }
  <a class='func-ref' href='#Fwakeup'>wakeup</a>(&p-&gt;nwrite);  <span class='comment'>//DOC: <a class='func-ref' href='#Fpiperead'>piperead</a>-<a class='func-ref' href='#Fwakeup'>wakeup</a></span>  <a class='func-ref' href='#Frelease'>release</a>(&p-&gt;lock);
  <span class='reserved'>return</span> i;
}



<hr/><a name='Istring.c'>###### <a class='page-ref' href='#Istring.c'>string.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"

void*
<a name='Fmemset'><a class='func-ref' href='#Fmemset'>memset</a></a>(void *dst, int c, uint n)
{
  <span class='reserved'>if</span> ((int)dst%4 == 0 && n%4 == 0){
    c &= 0xFF;
    <a class='func-ref' href='#Fstosl'>stosl</a>(dst, (c&lt;&lt;24)|(c&lt;&lt;16)|(c&lt;&lt;8)|c, n/4);
  } <span class='reserved'>else</span>
    <a class='func-ref' href='#Fstosb'>stosb</a>(dst, c, n);
  <span class='reserved'>return</span> dst;
}

int
<a name='Fmemcmp'><a class='func-ref' href='#Fmemcmp'>memcmp</a></a>(const void *v1, const void *v2, uint n)
{
  const uchar *s1, *s2;
  
  s1 = v1;
  s2 = v2;
  <span class='reserved'>while</span>(n-- &gt; 0){
    <span class='reserved'>if</span>(*s1 != *s2)
      <span class='reserved'>return</span> *s1 - *s2;
    s1++, s2++;
  }

  <span class='reserved'>return</span> 0;
}

void*
<a name='Fmemmove'><a class='func-ref' href='#Fmemmove'>memmove</a></a>(void *dst, const void *src, uint n)
{
  const char *s;
  char *d;

  s = src;
  d = dst;
  <span class='reserved'>if</span>(s &lt; d && s + n &gt; d){
    s += n;
    d += n;
    <span class='reserved'>while</span>(n-- &gt; 0)
      *--d = *--s;
  } <span class='reserved'>else</span>
    <span class='reserved'>while</span>(n-- &gt; 0)
      *d++ = *s++;

  <span class='reserved'>return</span> dst;
}

<span class='comment'>// <a class='func-ref' href='#Fmemcpy'>memcpy</a> exists to placate GCC.  Use <a class='func-ref' href='#Fmemmove'>memmove</a>.</span>void*
<a name='Fmemcpy'><a class='func-ref' href='#Fmemcpy'>memcpy</a></a>(void *dst, const void *src, uint n)
{
  <span class='reserved'>return</span> <a class='func-ref' href='#Fmemmove'>memmove</a>(dst, src, n);
}

int
<a name='Fstrncmp'><a class='func-ref' href='#Fstrncmp'>strncmp</a></a>(const char *p, const char *q, uint n)
{
  <span class='reserved'>while</span>(n &gt; 0 && *p && *p == *q)
    n--, p++, q++;
  <span class='reserved'>if</span>(n == 0)
    <span class='reserved'>return</span> 0;
  <span class='reserved'>return</span> (uchar)*p - (uchar)*q;
}

char*
<a name='Fstrncpy'><a class='func-ref' href='#Fstrncpy'>strncpy</a></a>(char *s, const char *t, int n)
{
  char *os;
  
  os = s;
  <span class='reserved'>while</span>(n-- &gt; 0 && (*s++ = *t++) != 0)
    ;
  <span class='reserved'>while</span>(n-- &gt; 0)
    *s++ = 0;
  <span class='reserved'>return</span> os;
}

<span class='comment'>// Like <a class='func-ref' href='#Fstrncpy'>strncpy</a> but guaranteed to NUL-terminate.</span>char*
<a name='Fsafestrcpy'><a class='func-ref' href='#Fsafestrcpy'>safestrcpy</a></a>(char *s, const char *t, int n)
{
  char *os;
  
  os = s;
  <span class='reserved'>if</span>(n &lt;= 0)
    <span class='reserved'>return</span> os;
  <span class='reserved'>while</span>(--n &gt; 0 && (*s++ = *t++) != 0)
    ;
  *s = 0;
  <span class='reserved'>return</span> os;
}

int
<a name='Fstrlen'><a class='func-ref' href='#Fstrlen'>strlen</a></a>(const char *s)
{
  int n;

  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(n = 0; s[n]; n++)
    ;
  <span class='reserved'>return</span> n;
}




<hr/><a name='Imp.h'>###### <a class='page-ref' href='#Imp.h'><a class='str-ref' href='#Smp'>mp</a>.h</a> ########</a>

<span class='comment'>// See MultiProcessor Specification Version 1.[14]</span>
<a name='Smp'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a> {             <span class='comment'>// floating pointer</span>  uchar signature[4];           <span class='comment'>// "_MP_"</span>  void *physaddr;               <span class='comment'>// phys addr of MP config table</span>  uchar length;                 <span class='comment'>// 1</span>  uchar specrev;                <span class='comment'>// [14]</span>  uchar checksum;               <span class='comment'>// all bytes must add up to 0</span>  uchar type;                   <span class='comment'>// MP system config type</span>  uchar imcrp;
  uchar reserved[3];
};

<a name='Smpconf'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Smpconf'>mpconf</a> {         <span class='comment'>// configuration table header</span>  uchar signature[4];           <span class='comment'>// "PCMP"</span>  ushort length;                <span class='comment'>// total table length</span>  uchar version;                <span class='comment'>// [14]</span>  uchar checksum;               <span class='comment'>// all bytes must add up to 0</span>  uchar product[20];            <span class='comment'>// product id</span>  uint *oemtable;               <span class='comment'>// OEM table pointer</span>  ushort oemlength;             <span class='comment'>// OEM table length</span>  ushort <a class='func-ref' href='#Fentry'>entry</a>;                 <span class='comment'>// <a class='func-ref' href='#Fentry'>entry</a> count</span>  uint *lapicaddr;              <span class='comment'>// address of local APIC</span>  ushort xlength;               <span class='comment'>// extended table length</span>  uchar xchecksum;              <span class='comment'>// extended table checksum</span>  uchar reserved;
};

<a name='Smpproc'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Smpproc'>mpproc</a> {         <span class='comment'>// processor table <a class='func-ref' href='#Fentry'>entry</a></span>  uchar type;                   <span class='comment'>// <a class='func-ref' href='#Fentry'>entry</a> type (0)</span>  uchar apicid;                 <span class='comment'>// local APIC id</span>  uchar version;                <span class='comment'>// local APIC verison</span>  uchar <a class='define-ref' href='#Aflags'>flags</a>;                  <span class='comment'>// CPU <a class='define-ref' href='#Aflags'>flags</a></span>    <a name='AMPBOOT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMPBOOT'>MPBOOT</a> 0x02           <span class='comment'>// This <a class='str-ref' href='#Sproc'>proc</a> is the bootstrap processor.</span>  uchar signature[4];           <span class='comment'>// CPU signature</span>  uint feature;                 <span class='comment'>// feature <a class='define-ref' href='#Aflags'>flags</a> from CPUID instruction</span>  uchar reserved[8];
};

<a name='Smpioapic'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Smpioapic'>mpioapic</a> {       <span class='comment'>// I/O APIC table <a class='func-ref' href='#Fentry'>entry</a></span>  uchar type;                   <span class='comment'>// <a class='func-ref' href='#Fentry'>entry</a> type (2)</span>  uchar apicno;                 <span class='comment'>// I/O APIC id</span>  uchar version;                <span class='comment'>// I/O APIC version</span>  uchar <a class='define-ref' href='#Aflags'>flags</a>;                  <span class='comment'>// I/O APIC <a class='define-ref' href='#Aflags'>flags</a></span>  uint *addr;                  <span class='comment'>// I/O APIC address</span>};

<span class='comment'>// Table <a class='func-ref' href='#Fentry'>entry</a> types</span><a name='AMPPROC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMPPROC'>MPPROC</a>    0x00  <span class='comment'>// One per processor</span><a name='AMPBUS'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMPBUS'>MPBUS</a>     0x01  <span class='comment'>// One per bus</span><a name='AMPIOAPIC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMPIOAPIC'>MPIOAPIC</a>  0x02  <span class='comment'>// One per I/O APIC</span><a name='AMPIOINTR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMPIOINTR'>MPIOINTR</a>  0x03  <span class='comment'>// One per bus interrupt source</span><a name='AMPLINTR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMPLINTR'>MPLINTR</a>   0x04  <span class='comment'>// One per system interrupt source</span>



<hr/><a name='Imp.c'>###### <a class='page-ref' href='#Imp.c'><a class='str-ref' href='#Smp'>mp</a>.c</a> ########</a>

<span class='comment'>// Multiprocessor support</span><span class='comment'>// Search memory <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> MP description structures.</span><span class='comment'>// http://developer.intel.com/design/pentium/datashts/24201606.pdf</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imp.h'><a class='str-ref' href='#Smp'>mp</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"

<span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> cpus[<a class='define-ref' href='#ANCPU'>NCPU</a>];
<span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Scpu'>cpu</a> *bcpu;
int ismp;
int ncpu;
uchar ioapicid;

int
<a name='Fmpbcpu'><a class='func-ref' href='#Fmpbcpu'>mpbcpu</a></a>(void)
{
  <span class='reserved'>return</span> bcpu-cpus;
}

<span class='reserved'>static</span> uchar
<a name='Fsum'><a class='func-ref' href='#Fsum'>sum</a></a>(uchar *addr, int len)
{
  int i, <a class='func-ref' href='#Fsum'>sum</a>;
  
  <a class='func-ref' href='#Fsum'>sum</a> = 0;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i=0; i&lt;len; i++)
    <a class='func-ref' href='#Fsum'>sum</a> += addr[i];
  <span class='reserved'>return</span> <a class='func-ref' href='#Fsum'>sum</a>;
}

<span class='comment'>// Look <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> an MP structure in the len bytes at addr.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a>*
<a name='Fmpsearch1'><a class='func-ref' href='#Fmpsearch1'>mpsearch1</a></a>(uint a, int len)
{
  uchar *e, *p, *addr;

  addr = p2v(a);
  e = addr+len;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p = addr; p &lt; e; p += sizeof(<span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a>))
    <span class='reserved'>if</span>(<a class='func-ref' href='#Fmemcmp'>memcmp</a>(p, "_MP_", 4) == 0 && <a class='func-ref' href='#Fsum'>sum</a>(p, sizeof(<span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a>)) == 0)
      <span class='reserved'>return</span> (<span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a>*)p;
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Search <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> the MP Floating Pointer Structure, which according to the</span><span class='comment'>// spec is in one of the following three locations:</span><span class='comment'>// 1) in the first KB of the EBDA;</span><span class='comment'>// 2) in the last KB of system base memory;</span><span class='comment'>// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a>*
<a name='Fmpsearch'><a class='func-ref' href='#Fmpsearch'>mpsearch</a></a>(void)
{
  uchar *bda;
  uint p;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a> *<a class='str-ref' href='#Smp'>mp</a>;

  bda = (uchar *) <a class='define-ref' href='#AP2V'>P2V</a>(0x400);
  <span class='reserved'>if</span>((p = ((bda[0x0F]&lt;&lt;8)| bda[0x0E]) &lt;&lt; 4)){
    <span class='reserved'>if</span>((<a class='str-ref' href='#Smp'>mp</a> = <a class='func-ref' href='#Fmpsearch1'>mpsearch1</a>(p, 1024)))
      <span class='reserved'>return</span> <a class='str-ref' href='#Smp'>mp</a>;
  } <span class='reserved'>else</span> {
    p = ((bda[0x14]&lt;&lt;8)|bda[0x13])*1024;
    <span class='reserved'>if</span>((<a class='str-ref' href='#Smp'>mp</a> = <a class='func-ref' href='#Fmpsearch1'>mpsearch1</a>(p-1024, 1024)))
      <span class='reserved'>return</span> <a class='str-ref' href='#Smp'>mp</a>;
  }
  <span class='reserved'>return</span> <a class='func-ref' href='#Fmpsearch1'>mpsearch1</a>(0xF0000, 0x10000);
}

<span class='comment'>// Search <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> an MP configuration table.  For now,</span><span class='comment'>// don't accept the <span class='reserved'>default</span> configurations (physaddr == 0).</span><span class='comment'>// Check <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> correct signature, calculate the checksum and,</span><span class='comment'>// <span class='reserved'>if</span> correct, check the version.</span><span class='comment'>// To do: check extended table checksum.</span><span class='reserved'>static</span> <span class='reserved'>struct</span> <a class='str-ref' href='#Smpconf'>mpconf</a>*
<a name='Fmpconfig'><a class='func-ref' href='#Fmpconfig'>mpconfig</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a> **pmp)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Smpconf'>mpconf</a> *conf;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a> *<a class='str-ref' href='#Smp'>mp</a>;

  <span class='reserved'>if</span>((<a class='str-ref' href='#Smp'>mp</a> = <a class='func-ref' href='#Fmpsearch'>mpsearch</a>()) == 0 || <a class='str-ref' href='#Smp'>mp</a>-&gt;physaddr == 0)
    <span class='reserved'>return</span> 0;
  conf = (<span class='reserved'>struct</span> <a class='str-ref' href='#Smpconf'>mpconf</a>*) p2v((uint) <a class='str-ref' href='#Smp'>mp</a>-&gt;physaddr);
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fmemcmp'>memcmp</a>(conf, "PCMP", 4) != 0)
    <span class='reserved'>return</span> 0;
  <span class='reserved'>if</span>(conf-&gt;version != 1 && conf-&gt;version != 4)
    <span class='reserved'>return</span> 0;
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fsum'>sum</a>((uchar*)conf, conf-&gt;length) != 0)
    <span class='reserved'>return</span> 0;
  *pmp = <a class='str-ref' href='#Smp'>mp</a>;
  <span class='reserved'>return</span> conf;
}

void
<a name='Fmpinit'><a class='func-ref' href='#Fmpinit'>mpinit</a></a>(void)
{
  uchar *p, *e;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Smp'>mp</a> *<a class='str-ref' href='#Smp'>mp</a>;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Smpconf'>mpconf</a> *conf;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Smpproc'>mpproc</a> *<a class='str-ref' href='#Sproc'>proc</a>;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Smpioapic'>mpioapic</a> *<a class='str-ref' href='#Sioapic'>ioapic</a>;

  bcpu = &cpus[0];
  <span class='reserved'>if</span>((conf = <a class='func-ref' href='#Fmpconfig'>mpconfig</a>(&<a class='str-ref' href='#Smp'>mp</a>)) == 0)
    <span class='reserved'>return</span>;
  ismp = 1;
  lapic = (uint*)conf-&gt;lapicaddr;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p=(uchar*)(conf+1), e=(uchar*)conf+conf-&gt;length; p&lt;e; ){
    <span class='reserved'>switch</span>(*p){
    <span class='reserved'>case</span> <a class='define-ref' href='#AMPPROC'>MPPROC</a>:
      <a class='str-ref' href='#Sproc'>proc</a> = (<span class='reserved'>struct</span> <a class='str-ref' href='#Smpproc'>mpproc</a>*)p;
      <span class='reserved'>if</span>(ncpu != <a class='str-ref' href='#Sproc'>proc</a>-&gt;apicid){
        <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='func-ref' href='#Fmpinit'>mpinit</a>: ncpu=%d apicid=%d\n", ncpu, <a class='str-ref' href='#Sproc'>proc</a>-&gt;apicid);
        ismp = 0;
      }
      <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;<a class='define-ref' href='#Aflags'>flags</a> & <a class='define-ref' href='#AMPBOOT'>MPBOOT</a>)
        bcpu = &cpus[ncpu];
      cpus[ncpu].id = ncpu;
      ncpu++;
      p += sizeof(<span class='reserved'>struct</span> <a class='str-ref' href='#Smpproc'>mpproc</a>);
      continue;
    <span class='reserved'>case</span> <a class='define-ref' href='#AMPIOAPIC'>MPIOAPIC</a>:
      <a class='str-ref' href='#Sioapic'>ioapic</a> = (<span class='reserved'>struct</span> <a class='str-ref' href='#Smpioapic'>mpioapic</a>*)p;
      ioapicid = <a class='str-ref' href='#Sioapic'>ioapic</a>-&gt;apicno;
      p += sizeof(<span class='reserved'>struct</span> <a class='str-ref' href='#Smpioapic'>mpioapic</a>);
      continue;
    <span class='reserved'>case</span> <a class='define-ref' href='#AMPBUS'>MPBUS</a>:
    <span class='reserved'>case</span> <a class='define-ref' href='#AMPIOINTR'>MPIOINTR</a>:
    <span class='reserved'>case</span> <a class='define-ref' href='#AMPLINTR'>MPLINTR</a>:
      p += 8;
      continue;
    <span class='reserved'>default</span>:
      <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='func-ref' href='#Fmpinit'>mpinit</a>: unknown config type %x\n", *p);
      ismp = 0;
    }
  }
  <span class='reserved'>if</span>(!ismp){
    <span class='comment'>// Didn't like what we <a class='func-ref' href='#Ffound'>found</a>; fall back to no MP.</span>    ncpu = 1;
    lapic = 0;
    ioapicid = 0;
    <span class='reserved'>return</span>;
  }

  <span class='reserved'>if</span>(<a class='str-ref' href='#Smp'>mp</a>-&gt;imcrp){
    <span class='comment'>// Bochs doesn't support IMCR, so this doesn't <a class='str-ref' href='#Srun'>run</a> on Bochs.</span>    <span class='comment'>// But it would on real hardware.</span>    <a class='func-ref' href='#Foutb'>outb</a>(0x22, 0x70);   <span class='comment'>// Select IMCR</span>    <a class='func-ref' href='#Foutb'>outb</a>(0x23, <a class='func-ref' href='#Finb'>inb</a>(0x23) | 1);  <span class='comment'>// Mask external interrupts.</span>  }
}



<hr/><a name='Ilapic.c'>###### <a class='page-ref' href='#Ilapic.c'>lapic.c</a> ########</a>

<span class='comment'>// The local APIC manages internal (non-I/O) interrupts.</span><span class='comment'>// See Chapter 8 & Appendix <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a> of Intel processor manual volume 3.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"

<span class='comment'>// Local APIC registers, divided by 4 <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> use as uint[] indices.</span><a name='AID'></a><span class='hash'>#define</span> <a class='define-ref' href='#AID'>ID</a>      (0x0020/4)   <span class='comment'>// <a class='define-ref' href='#AID'>ID</a></span><a name='AVER'></a><span class='hash'>#define</span> <a class='define-ref' href='#AVER'>VER</a>     (0x0030/4)   <span class='comment'>// Version</span><a name='ATPR'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATPR'>TPR</a>     (0x0080/4)   <span class='comment'>// Task Priority</span><a name='AEOI'></a><span class='hash'>#define</span> <a class='define-ref' href='#AEOI'>EOI</a>     (0x00B0/4)   <span class='comment'>// <a class='define-ref' href='#AEOI'>EOI</a></span><a name='ASVR'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASVR'>SVR</a>     (0x00F0/4)   <span class='comment'>// Spurious Interrupt Vector</span>  <a name='AENABLE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AENABLE'>ENABLE</a>     0x00000100   <span class='comment'>// Unit Enable</span><a name='AESR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AESR'>ESR</a>     (0x0280/4)   <span class='comment'>// Error Status</span><a name='AICRLO'></a><span class='hash'>#define</span> <a class='define-ref' href='#AICRLO'>ICRLO</a>   (0x0300/4)   <span class='comment'>// Interrupt Command</span>  <a name='AINIT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AINIT'>INIT</a>       0x00000500   <span class='comment'>// <a class='define-ref' href='#AINIT'>INIT</a>/RESET</span>  <a name='ASTARTUP'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASTARTUP'>STARTUP</a>    0x00000600   <span class='comment'>// Startup IPI</span>  <a name='ADELIVS'></a><span class='hash'>#define</span> <a class='define-ref' href='#ADELIVS'>DELIVS</a>     0x00001000   <span class='comment'>// Delivery status</span>  <a name='AASSERT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AASSERT'>ASSERT</a>     0x00004000   <span class='comment'>// Assert interrupt (vs deassert)</span>  <a name='ADEASSERT'></a><span class='hash'>#define</span> <a class='define-ref' href='#ADEASSERT'>DEASSERT</a>   0x00000000
  <a name='ALEVEL'></a><span class='hash'>#define</span> <a class='define-ref' href='#ALEVEL'>LEVEL</a>      0x00008000   <span class='comment'>// Level triggered</span>  <a name='ABCAST'></a><span class='hash'>#define</span> <a class='define-ref' href='#ABCAST'>BCAST</a>      0x00080000   <span class='comment'>// Send to all APICs, including self.</span>  <a name='ABUSY'></a><span class='hash'>#define</span> <a class='define-ref' href='#ABUSY'>BUSY</a>       0x00001000
  <a name='AFIXED'></a><span class='hash'>#define</span> <a class='define-ref' href='#AFIXED'>FIXED</a>      0x00000000
<a name='AICRHI'></a><span class='hash'>#define</span> <a class='define-ref' href='#AICRHI'>ICRHI</a>   (0x0310/4)   <span class='comment'>// Interrupt Command [63:32]</span><a name='ATIMER'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATIMER'>TIMER</a>   (0x0320/4)   <span class='comment'>// Local Vector Table 0 (<a class='define-ref' href='#ATIMER'>TIMER</a>)</span>  <a name='AX1'></a><span class='hash'>#define</span> <a class='define-ref' href='#AX1'>X1</a>         0x0000000B   <span class='comment'>// divide counts by 1</span>  <a name='APERIODIC'></a><span class='hash'>#define</span> <a class='define-ref' href='#APERIODIC'>PERIODIC</a>   0x00020000   <span class='comment'>// Periodic</span><a name='APCINT'></a><span class='hash'>#define</span> <a class='define-ref' href='#APCINT'>PCINT</a>   (0x0340/4)   <span class='comment'>// Performance Counter LVT</span><a name='ALINT0'></a><span class='hash'>#define</span> <a class='define-ref' href='#ALINT0'>LINT0</a>   (0x0350/4)   <span class='comment'>// Local Vector Table 1 (<a class='define-ref' href='#ALINT0'>LINT0</a>)</span><a name='ALINT1'></a><span class='hash'>#define</span> <a class='define-ref' href='#ALINT1'>LINT1</a>   (0x0360/4)   <span class='comment'>// Local Vector Table 2 (<a class='define-ref' href='#ALINT1'>LINT1</a>)</span><a name='AERROR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AERROR'>ERROR</a>   (0x0370/4)   <span class='comment'>// Local Vector Table 3 (<a class='define-ref' href='#AERROR'>ERROR</a>)</span>  <a name='AMASKED'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMASKED'>MASKED</a>     0x00010000   <span class='comment'>// Interrupt masked</span><a name='ATICR'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATICR'>TICR</a>    (0x0380/4)   <span class='comment'>// Timer Initial Count</span><a name='ATCCR'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATCCR'>TCCR</a>    (0x0390/4)   <span class='comment'>// Timer Current Count</span><a name='ATDCR'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATDCR'>TDCR</a>    (0x03E0/4)   <span class='comment'>// Timer Divide Configuration</span>
volatile uint *lapic;  <span class='comment'>// Initialized in <a class='page-ref' href='#Imp.c'><a class='str-ref' href='#Smp'>mp</a>.c</a></span>
<span class='reserved'>static</span> void
<a name='Flapicw'><a class='func-ref' href='#Flapicw'>lapicw</a></a>(int index, int value)
{
  lapic[index] = value;
  lapic[<a class='define-ref' href='#AID'>ID</a>];  <span class='comment'>// <a class='func-ref' href='#Fwait'>wait</a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> write to finish, by reading</span>}
<span class='comment'>//PAGEBREAK!</span>
void
<a name='Flapicinit'><a class='func-ref' href='#Flapicinit'>lapicinit</a></a>(void)
{
  <span class='reserved'>if</span>(!lapic) 
    <span class='reserved'>return</span>;

  <span class='comment'>// Enable local APIC; set spurious interrupt vector.</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#ASVR'>SVR</a>, <a class='define-ref' href='#AENABLE'>ENABLE</a> | (<a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_SPURIOUS'>IRQ_SPURIOUS</a>));

  <span class='comment'>// The timer repeatedly counts down at bus frequency</span>  <span class='comment'>// from lapic[<a class='define-ref' href='#ATICR'>TICR</a>] and then issues an interrupt.  </span>  <span class='comment'>// If xv6 cared more about precise timekeeping,</span>  <span class='comment'>// <a class='define-ref' href='#ATICR'>TICR</a> would be calibrated using an external time source.</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#ATDCR'>TDCR</a>, <a class='define-ref' href='#AX1'>X1</a>);
  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#ATIMER'>TIMER</a>, <a class='define-ref' href='#APERIODIC'>PERIODIC</a> | (<a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_TIMER'>IRQ_TIMER</a>));
  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#ATICR'>TICR</a>, 10000000); 

  <span class='comment'>// Disable logical interrupt lines.</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#ALINT0'>LINT0</a>, <a class='define-ref' href='#AMASKED'>MASKED</a>);
  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#ALINT1'>LINT1</a>, <a class='define-ref' href='#AMASKED'>MASKED</a>);

  <span class='comment'>// Disable performance counter overflow interrupts</span>  <span class='comment'>// on machines that provide that interrupt <a class='func-ref' href='#Fentry'>entry</a>.</span>  <span class='reserved'>if</span>(((lapic[<a class='define-ref' href='#AVER'>VER</a>]&gt;&gt;16) & 0xFF) &gt;= 4)
    <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#APCINT'>PCINT</a>, <a class='define-ref' href='#AMASKED'>MASKED</a>);

  <span class='comment'>// Map error interrupt to <a class='define-ref' href='#AIRQ_ERROR'>IRQ_ERROR</a>.</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AERROR'>ERROR</a>, <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + <a class='define-ref' href='#AIRQ_ERROR'>IRQ_ERROR</a>);

  <span class='comment'>// Clear error status register (requires back-to-back writes).</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AESR'>ESR</a>, 0);
  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AESR'>ESR</a>, 0);

  <span class='comment'>// Ack any outstanding interrupts.</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AEOI'>EOI</a>, 0);

  <span class='comment'>// Send an Init Level De-Assert to synchronise arbitration <a class='define-ref' href='#AID'>ID</a>'s.</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AICRHI'>ICRHI</a>, 0);
  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AICRLO'>ICRLO</a>, <a class='define-ref' href='#ABCAST'>BCAST</a> | <a class='define-ref' href='#AINIT'>INIT</a> | <a class='define-ref' href='#ALEVEL'>LEVEL</a>);
  <span class='reserved'>while</span>(lapic[<a class='define-ref' href='#AICRLO'>ICRLO</a>] & <a class='define-ref' href='#ADELIVS'>DELIVS</a>)
    ;

  <span class='comment'>// Enable interrupts on the APIC (but not on the processor).</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#ATPR'>TPR</a>, 0);
}

int
<a name='Fcpunum'><a class='func-ref' href='#Fcpunum'>cpunum</a></a>(void)
{
  <span class='comment'>// Cannot call <a class='str-ref' href='#Scpu'>cpu</a> when interrupts are enabled:</span>  <span class='comment'>// result not guaranteed to last long enough to be used!</span>  <span class='comment'>// Would prefer to <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a> but even printing is chancy here:</span>  <span class='comment'>// almost everything, including <a class='func-ref' href='#Fcprintf'>cprintf</a> and <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>, calls <a class='str-ref' href='#Scpu'>cpu</a>,</span>  <span class='comment'>// often indirectly through <a class='func-ref' href='#Facquire'>acquire</a> and <a class='func-ref' href='#Frelease'>release</a>.</span>  <span class='reserved'>if</span>(<a class='func-ref' href='#Freadeflags'>readeflags</a>()&<a class='define-ref' href='#AFL_IF'>FL_IF</a>){
    <span class='reserved'>static</span> int n;
    <span class='reserved'>if</span>(n++ == 0)
      <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='str-ref' href='#Scpu'>cpu</a> called from %x with interrupts enabled\n",
        __builtin_return_address(0));
  }

  <span class='reserved'>if</span>(lapic)
    <span class='reserved'>return</span> lapic[<a class='define-ref' href='#AID'>ID</a>]&gt;&gt;24;
  <span class='reserved'>return</span> 0;
}

<span class='comment'>// Acknowledge interrupt.</span>void
<a name='Flapiceoi'><a class='func-ref' href='#Flapiceoi'>lapiceoi</a></a>(void)
{
  <span class='reserved'>if</span>(lapic)
    <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AEOI'>EOI</a>, 0);
}

<span class='comment'>// Spin <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> a given number of microseconds.</span><span class='comment'>// On real hardware would want to tune this dynamically.</span>void
<a name='Fmicrodelay'><a class='func-ref' href='#Fmicrodelay'>microdelay</a></a>(int us)
{
}

<a name='AIO_RTC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIO_RTC'>IO_RTC</a>  0x70

<span class='comment'>// Start additional processor running <a class='func-ref' href='#Fentry'>entry</a> code at addr.</span><span class='comment'>// See Appendix B of MultiProcessor Specification.</span>void
<a name='Flapicstartap'><a class='func-ref' href='#Flapicstartap'>lapicstartap</a></a>(uchar apicid, uint addr)
{
  int i;
  ushort *wrv;
  
  <span class='comment'>// "The BSP must initialize CMOS shutdown code to 0AH</span>  <span class='comment'>// and the warm reset vector (DWORD based at 40:67) to point at</span>  <span class='comment'>// the AP startup code prior to the [universal startup algorithm]."</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_RTC'>IO_RTC</a>, 0xF);  <span class='comment'>// offset 0xF is shutdown code</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_RTC'>IO_RTC</a>+1, 0x0A);
  wrv = (ushort*)<a class='define-ref' href='#AP2V'>P2V</a>((0x40&lt;&lt;4 | 0x67));  <span class='comment'>// Warm reset vector</span>  wrv[0] = 0;
  wrv[1] = addr &gt;&gt; 4;

  <span class='comment'>// "Universal startup algorithm."</span>  <span class='comment'>// Send <a class='define-ref' href='#AINIT'>INIT</a> (level-triggered) interrupt to reset other CPU.</span>  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AICRHI'>ICRHI</a>, apicid&lt;&lt;24);
  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AICRLO'>ICRLO</a>, <a class='define-ref' href='#AINIT'>INIT</a> | <a class='define-ref' href='#ALEVEL'>LEVEL</a> | <a class='define-ref' href='#AASSERT'>ASSERT</a>);
  <a class='func-ref' href='#Fmicrodelay'>microdelay</a>(200);
  <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AICRLO'>ICRLO</a>, <a class='define-ref' href='#AINIT'>INIT</a> | <a class='define-ref' href='#ALEVEL'>LEVEL</a>);
  <a class='func-ref' href='#Fmicrodelay'>microdelay</a>(100);    <span class='comment'>// should be 10ms, but too slow in Bochs!</span>  
  <span class='comment'>// Send startup IPI (twice!) to enter code.</span>  <span class='comment'>// Regular hardware is supposed to only accept a <a class='define-ref' href='#ASTARTUP'>STARTUP</a></span>  <span class='comment'>// when it is in the halted state due to an <a class='define-ref' href='#AINIT'>INIT</a>.  So the second</span>  <span class='comment'>// should be ignored, but it is part of the official Intel algorithm.</span>  <span class='comment'>// Bochs complains about the second one.  Too <a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'><a class='func-ref' href='#Fbad'>bad</a></a></a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> Bochs.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; 2; i++){
    <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AICRHI'>ICRHI</a>, apicid&lt;&lt;24);
    <a class='func-ref' href='#Flapicw'>lapicw</a>(<a class='define-ref' href='#AICRLO'>ICRLO</a>, <a class='define-ref' href='#ASTARTUP'>STARTUP</a> | (addr&gt;&gt;12));
    <a class='func-ref' href='#Fmicrodelay'>microdelay</a>(200);
  }
}





<hr/><a name='Iioapic.c'>###### <a class='page-ref' href='#Iioapic.c'><a class='str-ref' href='#Sioapic'>ioapic</a>.c</a> ########</a>

<span class='comment'>// The I/O APIC manages hardware interrupts <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> an SMP system.</span><span class='comment'>// http://www.intel.com/design/chipsets/datashts/29056601.pdf</span><span class='comment'>// See also <a class='page-ref' href='#Ipicirq.c'>picirq.c</a>.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"

<a name='AIOAPIC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIOAPIC'>IOAPIC</a>  0xFEC00000   <span class='comment'>// Default physical address of IO APIC</span>
<a name='AREG_ID'></a><span class='hash'>#define</span> <a class='define-ref' href='#AREG_ID'>REG_ID</a>     0x00  <span class='comment'>// Register index: <a class='define-ref' href='#AID'>ID</a></span><a name='AREG_VER'></a><span class='hash'>#define</span> <a class='define-ref' href='#AREG_VER'>REG_VER</a>    0x01  <span class='comment'>// Register index: version</span><a name='AREG_TABLE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AREG_TABLE'>REG_TABLE</a>  0x10  <span class='comment'>// Redirection table base</span>
<span class='comment'>// The redirection table starts at <a class='define-ref' href='#AREG_TABLE'>REG_TABLE</a> and uses</span><span class='comment'>// two registers to configure each interrupt.  </span><span class='comment'>// The first (low) register in a pair contains configuration bits.</span><span class='comment'>// The second (high) register contains a bitmask telling which</span><span class='comment'>// CPUs can serve that interrupt.</span><a name='AINT_DISABLED'></a><span class='hash'>#define</span> <a class='define-ref' href='#AINT_DISABLED'>INT_DISABLED</a>   0x00010000  <span class='comment'>// Interrupt disabled</span><a name='AINT_LEVEL'></a><span class='hash'>#define</span> <a class='define-ref' href='#AINT_LEVEL'>INT_LEVEL</a>      0x00008000  <span class='comment'>// Level-triggered (vs edge-)</span><a name='AINT_ACTIVELOW'></a><span class='hash'>#define</span> <a class='define-ref' href='#AINT_ACTIVELOW'>INT_ACTIVELOW</a>  0x00002000  <span class='comment'>// Active low (vs high)</span><a name='AINT_LOGICAL'></a><span class='hash'>#define</span> <a class='define-ref' href='#AINT_LOGICAL'>INT_LOGICAL</a>    0x00000800  <span class='comment'>// Destination is CPU id (vs APIC <a class='define-ref' href='#AID'>ID</a>)</span>
volatile <span class='reserved'>struct</span> <a class='str-ref' href='#Sioapic'>ioapic</a> *<a class='str-ref' href='#Sioapic'>ioapic</a>;

<span class='comment'>// IO APIC MMIO structure: write reg, then read or write data.</span><a name='Sioapic'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Sioapic'>ioapic</a> {
  uint reg;
  uint pad[3];
  uint data;
};

<span class='reserved'>static</span> uint
<a name='Fioapicread'><a class='func-ref' href='#Fioapicread'>ioapicread</a></a>(int reg)
{
  <a class='str-ref' href='#Sioapic'>ioapic</a>-&gt;reg = reg;
  <span class='reserved'>return</span> <a class='str-ref' href='#Sioapic'>ioapic</a>-&gt;data;
}

<span class='reserved'>static</span> void
<a name='Fioapicwrite'><a class='func-ref' href='#Fioapicwrite'>ioapicwrite</a></a>(int reg, uint data)
{
  <a class='str-ref' href='#Sioapic'>ioapic</a>-&gt;reg = reg;
  <a class='str-ref' href='#Sioapic'>ioapic</a>-&gt;data = data;
}

void
<a name='Fioapicinit'><a class='func-ref' href='#Fioapicinit'>ioapicinit</a></a>(void)
{
  int i, id, maxintr;

  <span class='reserved'>if</span>(!ismp)
    <span class='reserved'>return</span>;

  <a class='str-ref' href='#Sioapic'>ioapic</a> = (volatile <span class='reserved'>struct</span> <a class='str-ref' href='#Sioapic'>ioapic</a>*)<a class='define-ref' href='#AIOAPIC'>IOAPIC</a>;
  maxintr = (<a class='func-ref' href='#Fioapicread'>ioapicread</a>(<a class='define-ref' href='#AREG_VER'>REG_VER</a>) &gt;&gt; 16) & 0xFF;
  id = <a class='func-ref' href='#Fioapicread'>ioapicread</a>(<a class='define-ref' href='#AREG_ID'>REG_ID</a>) &gt;&gt; 24;
  <span class='reserved'>if</span>(id != ioapicid)
    <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='func-ref' href='#Fioapicinit'>ioapicinit</a>: id isn't equal to ioapicid; not a MP\n");

  <span class='comment'>// Mark all interrupts edge-triggered, active high, disabled,</span>  <span class='comment'>// and not routed to any CPUs.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt;= maxintr; i++){
    <a class='func-ref' href='#Fioapicwrite'>ioapicwrite</a>(<a class='define-ref' href='#AREG_TABLE'>REG_TABLE</a>+2*i, <a class='define-ref' href='#AINT_DISABLED'>INT_DISABLED</a> | (<a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + i));
    <a class='func-ref' href='#Fioapicwrite'>ioapicwrite</a>(<a class='define-ref' href='#AREG_TABLE'>REG_TABLE</a>+2*i+1, 0);
  }
}

void
<a name='Fioapicenable'><a class='func-ref' href='#Fioapicenable'>ioapicenable</a></a>(int irq, int <a class='func-ref' href='#Fcpunum'>cpunum</a>)
{
  <span class='reserved'>if</span>(!ismp)
    <span class='reserved'>return</span>;

  <span class='comment'>// Mark interrupt edge-triggered, active high,</span>  <span class='comment'>// enabled, and routed to the given <a class='func-ref' href='#Fcpunum'>cpunum</a>,</span>  <span class='comment'>// which happens to be that <a class='str-ref' href='#Scpu'>cpu</a>'s APIC <a class='define-ref' href='#AID'>ID</a>.</span>  <a class='func-ref' href='#Fioapicwrite'>ioapicwrite</a>(<a class='define-ref' href='#AREG_TABLE'>REG_TABLE</a>+2*irq, <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + irq);
  <a class='func-ref' href='#Fioapicwrite'>ioapicwrite</a>(<a class='define-ref' href='#AREG_TABLE'>REG_TABLE</a>+2*irq+1, <a class='func-ref' href='#Fcpunum'>cpunum</a> &lt;&lt; 24);
}



<hr/><a name='Ipicirq.c'>###### <a class='page-ref' href='#Ipicirq.c'>picirq.c</a> ########</a>

<span class='comment'>// Intel 8259A programmable interrupt controllers.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"

<span class='comment'>// I/O Addresses of the two programmable interrupt controllers</span><a name='AIO_PIC1'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>         0x20    <span class='comment'>// Master (IRQs 0-7)</span><a name='AIO_PIC2'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>         0xA0    <span class='comment'>// Slave (IRQs 8-15)</span>
<a name='AIRQ_SLAVE'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIRQ_SLAVE'>IRQ_SLAVE</a>       2       <span class='comment'>// IRQ at which slave connects to master</span>
<span class='comment'>// Current IRQ mask.</span><span class='comment'>// Initial IRQ mask has interrupt 2 enabled (<a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> slave 8259A).</span><span class='reserved'>static</span> ushort irqmask = 0xFFFF & ~(1&lt;&lt;<a class='define-ref' href='#AIRQ_SLAVE'>IRQ_SLAVE</a>);

<span class='reserved'>static</span> void
<a name='Fpicsetmask'><a class='func-ref' href='#Fpicsetmask'>picsetmask</a></a>(ushort mask)
{
  irqmask = mask;
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>+1, mask);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>+1, mask &gt;&gt; 8);
}

void
<a name='Fpicenable'><a class='func-ref' href='#Fpicenable'>picenable</a></a>(int irq)
{
  <a class='func-ref' href='#Fpicsetmask'>picsetmask</a>(irqmask & ~(1&lt;&lt;irq));
}

<span class='comment'>// Initialize the 8259A interrupt controllers.</span>void
<a name='Fpicinit'><a class='func-ref' href='#Fpicinit'>picinit</a></a>(void)
{
  <span class='comment'>// mask all interrupts</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>+1, 0xFF);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>+1, 0xFF);

  <span class='comment'>// Set up master (8259A-1)</span>
  <span class='comment'>// ICW1:  0001g0hi</span>  <span class='comment'>//    g:  0 = edge triggering, 1 = level triggering</span>  <span class='comment'>//    h:  0 = cascaded PICs, 1 = master only</span>  <span class='comment'>//    i:  0 = no ICW4, 1 = ICW4 required</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>, 0x11);

  <span class='comment'>// ICW2:  Vector offset</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>+1, <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a>);

  <span class='comment'>// ICW3:  (master PIC) bit mask of IR lines connected to slaves</span>  <span class='comment'>//        (slave PIC) 3-bit # of slave's connection to master</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>+1, 1&lt;&lt;<a class='define-ref' href='#AIRQ_SLAVE'>IRQ_SLAVE</a>);

  <span class='comment'>// ICW4:  000nbmap</span>  <span class='comment'>//    n:  1 = special fully nested mode</span>  <span class='comment'>//    b:  1 = buffered mode</span>  <span class='comment'>//    m:  0 = slave PIC, 1 = master PIC</span>  <span class='comment'>//      (ignored when b is 0, as the master/slave role</span>  <span class='comment'>//      can be hardwired).</span>  <span class='comment'>//    a:  1 = Automatic <a class='define-ref' href='#AEOI'>EOI</a> mode</span>  <span class='comment'>//    p:  0 = MCS-80/85 mode, 1 = intel x86 mode</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>+1, 0x3);

  <span class='comment'>// Set up slave (8259A-2)</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>, 0x11);                  <span class='comment'>// ICW1</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>+1, <a class='define-ref' href='#AT_IRQ0'>T_IRQ0</a> + 8);      <span class='comment'>// ICW2</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>+1, <a class='define-ref' href='#AIRQ_SLAVE'>IRQ_SLAVE</a>);           <span class='comment'>// ICW3</span>  <span class='comment'>// NB Automatic <a class='define-ref' href='#AEOI'>EOI</a> mode doesn't tend to work on the slave.</span>  <span class='comment'>// Linux source code says it's "to be investigated".</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>+1, 0x3);                 <span class='comment'>// ICW4</span>
  <span class='comment'>// OCW3:  0ef01prs</span>  <span class='comment'>//   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask</span>  <span class='comment'>//    p:  0 = no polling, 1 = polling mode</span>  <span class='comment'>//   rs:  0x = NOP, 10 = read IRR, 11 = read ISR</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>, 0x68);             <span class='comment'>// clear specific mask</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC1'>IO_PIC1</a>, 0x0a);             <span class='comment'>// read IRR by <span class='reserved'>default</span></span>
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>, 0x68);             <span class='comment'>// OCW3</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_PIC2'>IO_PIC2</a>, 0x0a);             <span class='comment'>// OCW3</span>
  <span class='reserved'>if</span>(irqmask != 0xFFFF)
    <a class='func-ref' href='#Fpicsetmask'>picsetmask</a>(irqmask);
}



<hr/><a name='Ikbd.h'>###### <a class='page-ref' href='#Ikbd.h'>kbd.h</a> ########</a>

<span class='comment'>// PC keyboard interface constants</span>
<a name='AKBSTATP'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKBSTATP'>KBSTATP</a>         0x64    <span class='comment'>// kbd controller status port(I)</span><a name='AKBS_DIB'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKBS_DIB'>KBS_DIB</a>         0x01    <span class='comment'>// kbd data in buffer</span><a name='AKBDATAP'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKBDATAP'>KBDATAP</a>         0x60    <span class='comment'>// kbd data port(I)</span>
<a name='ANO'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANO'>NO</a>              0

<a name='ASHIFT'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASHIFT'>SHIFT</a>           (1&lt;&lt;0)
<a name='ACTL'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACTL'>CTL</a>             (1&lt;&lt;1)
<a name='AALT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AALT'>ALT</a>             (1&lt;&lt;2)

<a name='ACAPSLOCK'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACAPSLOCK'>CAPSLOCK</a>        (1&lt;&lt;3)
<a name='ANUMLOCK'></a><span class='hash'>#define</span> <a class='define-ref' href='#ANUMLOCK'>NUMLOCK</a>         (1&lt;&lt;4)
<a name='ASCROLLLOCK'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASCROLLLOCK'>SCROLLLOCK</a>      (1&lt;&lt;5)

<a name='AE0ESC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AE0ESC'>E0ESC</a>           (1&lt;&lt;6)

<span class='comment'>// Special keycodes</span><a name='AKEY_HOME'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_HOME'>KEY_HOME</a>        0xE0
<a name='AKEY_END'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_END'>KEY_END</a>         0xE1
<a name='AKEY_UP'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_UP'>KEY_UP</a>          0xE2
<a name='AKEY_DN'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_DN'>KEY_DN</a>          0xE3
<a name='AKEY_LF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_LF'>KEY_LF</a>          0xE4
<a name='AKEY_RT'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_RT'>KEY_RT</a>          0xE5
<a name='AKEY_PGUP'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_PGUP'>KEY_PGUP</a>        0xE6
<a name='AKEY_PGDN'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_PGDN'>KEY_PGDN</a>        0xE7
<a name='AKEY_INS'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_INS'>KEY_INS</a>         0xE8
<a name='AKEY_DEL'></a><span class='hash'>#define</span> <a class='define-ref' href='#AKEY_DEL'>KEY_DEL</a>         0xE9

<span class='comment'>// <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('A') == Control-A</span><a name='AC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>(x) (x - '@')

<span class='reserved'>static</span> uchar shiftcode[256] =
{
  [0x1D] <a class='define-ref' href='#ACTL'>CTL</a>,
  [0x2A] <a class='define-ref' href='#ASHIFT'>SHIFT</a>,
  [0x36] <a class='define-ref' href='#ASHIFT'>SHIFT</a>,
  [0x38] <a class='define-ref' href='#AALT'>ALT</a>,
  [0x9D] <a class='define-ref' href='#ACTL'>CTL</a>,
  [0xB8] <a class='define-ref' href='#AALT'>ALT</a>
};

<span class='reserved'>static</span> uchar togglecode[256] =
{
  [0x3A] <a class='define-ref' href='#ACAPSLOCK'>CAPSLOCK</a>,
  [0x45] <a class='define-ref' href='#ANUMLOCK'>NUMLOCK</a>,
  [0x46] <a class='define-ref' href='#ASCROLLLOCK'>SCROLLLOCK</a>
};

<span class='reserved'>static</span> uchar normalmap[256] =
{
  <a class='define-ref' href='#ANO'>NO</a>,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  <span class='comment'>// 0x00</span>  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
  'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  <span class='comment'>// 0x10</span>  'o',  'p',  '[',  ']',  '\n', <a class='define-ref' href='#ANO'>NO</a>,   'a',  's',
  'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  <span class='comment'>// 0x20</span>  '\'', '`',  <a class='define-ref' href='#ANO'>NO</a>,   '\\', 'z',  'x',  'c',  'v',
  'b',  'n',  'm',  ',',  '.',  '/',  <a class='define-ref' href='#ANO'>NO</a>,   '*',  <span class='comment'>// 0x30</span>  <a class='define-ref' href='#ANO'>NO</a>,   ' ',  <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,
  <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   '7',  <span class='comment'>// 0x40</span>  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
  '2',  '3',  '0',  '.',  <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <span class='comment'>// 0x50</span>  [0x9C] '\n',      <span class='comment'>// KP_Enter</span>  [0xB5] '/',       <span class='comment'>// KP_Div</span>  [0xC8] <a class='define-ref' href='#AKEY_UP'>KEY_UP</a>,    [0xD0] <a class='define-ref' href='#AKEY_DN'>KEY_DN</a>,
  [0xC9] <a class='define-ref' href='#AKEY_PGUP'>KEY_PGUP</a>,  [0xD1] <a class='define-ref' href='#AKEY_PGDN'>KEY_PGDN</a>,
  [0xCB] <a class='define-ref' href='#AKEY_LF'>KEY_LF</a>,    [0xCD] <a class='define-ref' href='#AKEY_RT'>KEY_RT</a>,
  [0x97] <a class='define-ref' href='#AKEY_HOME'>KEY_HOME</a>,  [0xCF] <a class='define-ref' href='#AKEY_END'>KEY_END</a>,
  [0xD2] <a class='define-ref' href='#AKEY_INS'>KEY_INS</a>,   [0xD3] <a class='define-ref' href='#AKEY_DEL'>KEY_DEL</a>
};

<span class='reserved'>static</span> uchar shiftmap[256] =
{
  <a class='define-ref' href='#ANO'>NO</a>,   033,  '!',  '@',  '#',  '$',  '%',  '^',  <span class='comment'>// 0x00</span>  '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
  'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  <span class='comment'>// 0x10</span>  'O',  'P',  '{',  '}',  '\n', <a class='define-ref' href='#ANO'>NO</a>,   'A',  'S',
  'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  <span class='comment'>// 0x20</span>  '"',  '~',  <a class='define-ref' href='#ANO'>NO</a>,   '|',  'Z',  'X',  '<a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>',  'V',
  'B',  'N',  'M',  '&lt;',  '&gt;',  '?',  <a class='define-ref' href='#ANO'>NO</a>,   '*',  <span class='comment'>// 0x30</span>  <a class='define-ref' href='#ANO'>NO</a>,   ' ',  <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,
  <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   '7',  <span class='comment'>// 0x40</span>  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
  '2',  '3',  '0',  '.',  <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <a class='define-ref' href='#ANO'>NO</a>,   <span class='comment'>// 0x50</span>  [0x9C] '\n',      <span class='comment'>// KP_Enter</span>  [0xB5] '/',       <span class='comment'>// KP_Div</span>  [0xC8] <a class='define-ref' href='#AKEY_UP'>KEY_UP</a>,    [0xD0] <a class='define-ref' href='#AKEY_DN'>KEY_DN</a>,
  [0xC9] <a class='define-ref' href='#AKEY_PGUP'>KEY_PGUP</a>,  [0xD1] <a class='define-ref' href='#AKEY_PGDN'>KEY_PGDN</a>,
  [0xCB] <a class='define-ref' href='#AKEY_LF'>KEY_LF</a>,    [0xCD] <a class='define-ref' href='#AKEY_RT'>KEY_RT</a>,
  [0x97] <a class='define-ref' href='#AKEY_HOME'>KEY_HOME</a>,  [0xCF] <a class='define-ref' href='#AKEY_END'>KEY_END</a>,
  [0xD2] <a class='define-ref' href='#AKEY_INS'>KEY_INS</a>,   [0xD3] <a class='define-ref' href='#AKEY_DEL'>KEY_DEL</a>
};

<span class='reserved'>static</span> uchar ctlmap[256] =
{
  <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,
  <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,
  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('Q'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('W'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('E'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('R'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('T'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('Y'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('U'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('I'),
  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('O'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('P'),  <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      '\r',    <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('A'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('S'),
  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('D'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('F'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('G'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('H'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('J'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('K'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('L'),  <a class='define-ref' href='#ANO'>NO</a>,
  <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('\\'), <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('Z'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('X'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('<a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('V'),
  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('B'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('N'),  <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('M'),  <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('/'),  <a class='define-ref' href='#ANO'>NO</a>,      <a class='define-ref' href='#ANO'>NO</a>,
  [0x9C] '\r',      <span class='comment'>// KP_Enter</span>  [0xB5] <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('/'),    <span class='comment'>// KP_Div</span>  [0xC8] <a class='define-ref' href='#AKEY_UP'>KEY_UP</a>,    [0xD0] <a class='define-ref' href='#AKEY_DN'>KEY_DN</a>,
  [0xC9] <a class='define-ref' href='#AKEY_PGUP'>KEY_PGUP</a>,  [0xD1] <a class='define-ref' href='#AKEY_PGDN'>KEY_PGDN</a>,
  [0xCB] <a class='define-ref' href='#AKEY_LF'>KEY_LF</a>,    [0xCD] <a class='define-ref' href='#AKEY_RT'>KEY_RT</a>,
  [0x97] <a class='define-ref' href='#AKEY_HOME'>KEY_HOME</a>,  [0xCF] <a class='define-ref' href='#AKEY_END'>KEY_END</a>,
  [0xD2] <a class='define-ref' href='#AKEY_INS'>KEY_INS</a>,   [0xD3] <a class='define-ref' href='#AKEY_DEL'>KEY_DEL</a>
};




<hr/><a name='Ikbd.c'>###### <a class='page-ref' href='#Ikbd.c'>kbd.c</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ikbd.h'>kbd.h</a>"

int
<a name='Fkbdgetc'><a class='func-ref' href='#Fkbdgetc'>kbdgetc</a></a>(void)
{
  <span class='reserved'>static</span> uint shift;
  <span class='reserved'>static</span> uchar *charcode[4] = {
    normalmap, shiftmap, ctlmap, ctlmap
  };
  uint st, data, c;

  st = <a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#AKBSTATP'>KBSTATP</a>);
  <span class='reserved'>if</span>((st & <a class='define-ref' href='#AKBS_DIB'>KBS_DIB</a>) == 0)
    <span class='reserved'>return</span> -1;
  data = <a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#AKBDATAP'>KBDATAP</a>);

  <span class='reserved'>if</span>(data == 0xE0){
    shift |= <a class='define-ref' href='#AE0ESC'>E0ESC</a>;
    <span class='reserved'>return</span> 0;
  } <span class='reserved'>else</span> <span class='reserved'>if</span>(data & 0x80){
    <span class='comment'>// Key released</span>    data = (shift & <a class='define-ref' href='#AE0ESC'>E0ESC</a> ? data : data & 0x7F);
    shift &= ~(shiftcode[data] | <a class='define-ref' href='#AE0ESC'>E0ESC</a>);
    <span class='reserved'>return</span> 0;
  } <span class='reserved'>else</span> <span class='reserved'>if</span>(shift & <a class='define-ref' href='#AE0ESC'>E0ESC</a>){
    <span class='comment'>// Last character was an E0 escape; or with 0x80</span>    data |= 0x80;
    shift &= ~<a class='define-ref' href='#AE0ESC'>E0ESC</a>;
  }

  shift |= shiftcode[data];
  shift ^= togglecode[data];
  c = charcode[shift & (<a class='define-ref' href='#ACTL'>CTL</a> | <a class='define-ref' href='#ASHIFT'>SHIFT</a>)][data];
  <span class='reserved'>if</span>(shift & <a class='define-ref' href='#ACAPSLOCK'>CAPSLOCK</a>){
    <span class='reserved'>if</span>('a' &lt;= c && c &lt;= 'z')
      c += 'A' - 'a';
    <span class='reserved'>else</span> <span class='reserved'>if</span>('A' &lt;= c && c &lt;= 'Z')
      c += 'a' - 'A';
  }
  <span class='reserved'>return</span> c;
}

void
<a name='Fkbdintr'><a class='func-ref' href='#Fkbdintr'>kbdintr</a></a>(void)
{
  <a class='func-ref' href='#Fconsoleintr'>consoleintr</a>(<a class='func-ref' href='#Fkbdgetc'>kbdgetc</a>);
}



<hr/><a name='Iconsole.c'>###### <a class='page-ref' href='#Iconsole.c'>console.c</a> ########</a>

<span class='comment'>// Console <a class='str-ref' href='#Sinput'>input</a> and output.</span><span class='comment'>// Input is from the keyboard or serial port.</span><span class='comment'>// Output is written to the screen and serial port.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifs.h'>fs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifile.h'><a class='str-ref' href='#Sfile'>file</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"

<span class='reserved'>static</span> void <a class='func-ref' href='#Fconsputc'>consputc</a>(int);

<span class='reserved'>static</span> int panicked = 0;

<span class='reserved'>static</span> <span class='reserved'>struct</span> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  int locking;
} cons;

<span class='reserved'>static</span> void
<a name='Fprintint'><a class='func-ref' href='#Fprintint'>printint</a></a>(int xx, int base, int sign)
{
  <span class='reserved'>static</span> char digits[] = "0123456789abcdef";
  char <a class='str-ref' href='#Sbuf'>buf</a>[16];
  int i;
  uint x;

  <span class='reserved'>if</span>(sign && (sign = xx &lt; 0))
    x = -xx;
  <span class='reserved'>else</span>
    x = xx;

  i = 0;
  do{
    <a class='str-ref' href='#Sbuf'>buf</a>[i++] = digits[x % base];
  }<span class='reserved'>while</span>((x /= base) != 0);

  <span class='reserved'>if</span>(sign)
    <a class='str-ref' href='#Sbuf'>buf</a>[i++] = '-';

  <span class='reserved'>while</span>(--i &gt;= 0)
    <a class='func-ref' href='#Fconsputc'>consputc</a>(<a class='str-ref' href='#Sbuf'>buf</a>[i]);
}
<span class='comment'>//PAGEBREAK: 50</span>
<span class='comment'>// Print to the console. only understands %d, %x, %p, %s.</span>void
<a name='Fcprintf'><a class='func-ref' href='#Fcprintf'>cprintf</a></a>(char *fmt, ...)
{
  int i, c, locking;
  uint *argp;
  char *s;

  locking = cons.locking;
  <span class='reserved'>if</span>(locking)
    <a class='func-ref' href='#Facquire'>acquire</a>(&cons.lock);

  <span class='reserved'>if</span> (fmt == 0)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("null fmt");

  argp = (uint*)(void*)(&fmt + 1);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; (c = fmt[i] & 0xff) != 0; i++){
    <span class='reserved'>if</span>(c != '%'){
      <a class='func-ref' href='#Fconsputc'>consputc</a>(c);
      continue;
    }
    c = fmt[++i] & 0xff;
    <span class='reserved'>if</span>(c == 0)
      <span class='reserved'>break</span>;
    <span class='reserved'>switch</span>(c){
    <span class='reserved'>case</span> 'd':
      <a class='func-ref' href='#Fprintint'>printint</a>(*argp++, 10, 1);
      <span class='reserved'>break</span>;
    <span class='reserved'>case</span> 'x':
    <span class='reserved'>case</span> 'p':
      <a class='func-ref' href='#Fprintint'>printint</a>(*argp++, 16, 0);
      <span class='reserved'>break</span>;
    <span class='reserved'>case</span> 's':
      <span class='reserved'>if</span>((s = (char*)*argp++) == 0)
        s = "(null)";
      <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(; *s; s++)
        <a class='func-ref' href='#Fconsputc'>consputc</a>(*s);
      <span class='reserved'>break</span>;
    <span class='reserved'>case</span> '%':
      <a class='func-ref' href='#Fconsputc'>consputc</a>('%');
      <span class='reserved'>break</span>;
    <span class='reserved'>default</span>:
      <span class='comment'>// Print unknown % sequence to draw attention.</span>      <a class='func-ref' href='#Fconsputc'>consputc</a>('%');
      <a class='func-ref' href='#Fconsputc'>consputc</a>(c);
      <span class='reserved'>break</span>;
    }
  }

  <span class='reserved'>if</span>(locking)
    <a class='func-ref' href='#Frelease'>release</a>(&cons.lock);
}

void
<a name='Fpanic'><a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a></a>(char *s)
{
  int i;
  uint pcs[10];
  
  <a class='func-ref' href='#Fcli'>cli</a>();
  cons.locking = 0;
  <a class='func-ref' href='#Fcprintf'>cprintf</a>("<a class='str-ref' href='#Scpu'>cpu</a>%d: <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>: ", <a class='str-ref' href='#Scpu'>cpu</a>-&gt;id);
  <a class='func-ref' href='#Fcprintf'>cprintf</a>(s);
  <a class='func-ref' href='#Fcprintf'>cprintf</a>("\n");
  <a class='func-ref' href='#Fgetcallerpcs'>getcallerpcs</a>(&s, pcs);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i=0; i&lt;10; i++)
    <a class='func-ref' href='#Fcprintf'>cprintf</a>(" %p", pcs[i]);
  panicked = 1; <span class='comment'>// freeze other CPU</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(;;)
    ;
}

<span class='comment'>//PAGEBREAK: 50</span><a name='ABACKSPACE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ABACKSPACE'>BACKSPACE</a> 0x100
<a name='ACRTPORT'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACRTPORT'>CRTPORT</a> 0x3d4
<span class='reserved'>static</span> ushort *crt = (ushort*)<a class='define-ref' href='#AP2V'>P2V</a>(0xb8000);  <span class='comment'>// CGA memory</span>
<span class='reserved'>static</span> void
<a name='Fcgaputc'><a class='func-ref' href='#Fcgaputc'>cgaputc</a></a>(int c)
{
  int pos;
  
  <span class='comment'>// Cursor position: col + 80*row.</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>, 14);
  pos = <a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>+1) &lt;&lt; 8;
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>, 15);
  pos |= <a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>+1);

  <span class='reserved'>if</span>(c == '\n')
    pos += 80 - pos%80;
  <span class='reserved'>else</span> <span class='reserved'>if</span>(c == <a class='define-ref' href='#ABACKSPACE'>BACKSPACE</a>){
    <span class='reserved'>if</span>(pos &gt; 0) --pos;
  } <span class='reserved'>else</span>
    crt[pos++] = (c&0xff) | 0x0700;  <span class='comment'>// black on white</span>  
  <span class='reserved'>if</span>((pos/80) &gt;= 24){  <span class='comment'>// Scroll up.</span>    <a class='func-ref' href='#Fmemmove'>memmove</a>(crt, crt+80, sizeof(crt[0])*23*80);
    pos -= 80;
    <a class='func-ref' href='#Fmemset'>memset</a>(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
  }
  
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>, 14);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>+1, pos&gt;&gt;8);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>, 15);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACRTPORT'>CRTPORT</a>+1, pos);
  crt[pos] = ' ' | 0x0700;
}

void
<a name='Fconsputc'><a class='func-ref' href='#Fconsputc'>consputc</a></a>(int c)
{
  <span class='reserved'>if</span>(panicked){
    <a class='func-ref' href='#Fcli'>cli</a>();
    <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(;;)
      ;
  }

  <span class='reserved'>if</span>(c == <a class='define-ref' href='#ABACKSPACE'>BACKSPACE</a>){
    <a class='func-ref' href='#Fuartputc'>uartputc</a>('\b'); <a class='func-ref' href='#Fuartputc'>uartputc</a>(' '); <a class='func-ref' href='#Fuartputc'>uartputc</a>('\b');
  } <span class='reserved'>else</span>
    <a class='func-ref' href='#Fuartputc'>uartputc</a>(c);
  <a class='func-ref' href='#Fcgaputc'>cgaputc</a>(c);
}

<a name='AINPUT_BUF'></a><span class='hash'>#define</span> <a class='define-ref' href='#AINPUT_BUF'>INPUT_BUF</a> 128
<a name='Sinput'></a><span class='reserved'>struct</span> {
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sspinlock'>spinlock</a> lock;
  char <a class='str-ref' href='#Sbuf'>buf</a>[<a class='define-ref' href='#AINPUT_BUF'>INPUT_BUF</a>];
  uint r;  <span class='comment'>// Read index</span>  uint w;  <span class='comment'>// Write index</span>  uint e;  <span class='comment'>// Edit index</span>} <a class='str-ref' href='#Sinput'>input</a>;

<a name='AC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>(x)  ((x)-'@')  <span class='comment'>// Control-x</span>
void
<a name='Fconsoleintr'><a class='func-ref' href='#Fconsoleintr'>consoleintr</a></a>(int (*getc)(void))
{
  int c;

  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sinput'>input</a>.lock);
  <span class='reserved'>while</span>((c = getc()) &gt;= 0){
    <span class='reserved'>switch</span>(c){
    <span class='reserved'>case</span> <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('P'):  <span class='comment'>// Process listing.</span>      <a class='func-ref' href='#Fprocdump'>procdump</a>();
      <span class='reserved'>break</span>;
    <span class='reserved'>case</span> <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('U'):  <span class='comment'>// Kill line.</span>      <span class='reserved'>while</span>(<a class='str-ref' href='#Sinput'>input</a>.e != <a class='str-ref' href='#Sinput'>input</a>.w &&
            <a class='str-ref' href='#Sinput'>input</a>.<a class='str-ref' href='#Sbuf'>buf</a>[(<a class='str-ref' href='#Sinput'>input</a>.e-1) % <a class='define-ref' href='#AINPUT_BUF'>INPUT_BUF</a>] != '\n'){
        <a class='str-ref' href='#Sinput'>input</a>.e--;
        <a class='func-ref' href='#Fconsputc'>consputc</a>(<a class='define-ref' href='#ABACKSPACE'>BACKSPACE</a>);
      }
      <span class='reserved'>break</span>;
    <span class='reserved'>case</span> <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('H'): <span class='reserved'>case</span> '\x7f':  <span class='comment'>// Backspace</span>      <span class='reserved'>if</span>(<a class='str-ref' href='#Sinput'>input</a>.e != <a class='str-ref' href='#Sinput'>input</a>.w){
        <a class='str-ref' href='#Sinput'>input</a>.e--;
        <a class='func-ref' href='#Fconsputc'>consputc</a>(<a class='define-ref' href='#ABACKSPACE'>BACKSPACE</a>);
      }
      <span class='reserved'>break</span>;
    <span class='reserved'>default</span>:
      <span class='reserved'>if</span>(c != 0 && <a class='str-ref' href='#Sinput'>input</a>.e-<a class='str-ref' href='#Sinput'>input</a>.r &lt; <a class='define-ref' href='#AINPUT_BUF'>INPUT_BUF</a>){
        c = (c == '\r') ? '\n' : c;
        <a class='str-ref' href='#Sinput'>input</a>.<a class='str-ref' href='#Sbuf'>buf</a>[<a class='str-ref' href='#Sinput'>input</a>.e++ % <a class='define-ref' href='#AINPUT_BUF'>INPUT_BUF</a>] = c;
        <a class='func-ref' href='#Fconsputc'>consputc</a>(c);
        <span class='reserved'>if</span>(c == '\n' || c == <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('D') || <a class='str-ref' href='#Sinput'>input</a>.e == <a class='str-ref' href='#Sinput'>input</a>.r+<a class='define-ref' href='#AINPUT_BUF'>INPUT_BUF</a>){
          <a class='str-ref' href='#Sinput'>input</a>.w = <a class='str-ref' href='#Sinput'>input</a>.e;
          <a class='func-ref' href='#Fwakeup'>wakeup</a>(&<a class='str-ref' href='#Sinput'>input</a>.r);
        }
      }
      <span class='reserved'>break</span>;
    }
  }
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sinput'>input</a>.lock);
}

int
<a name='Fconsoleread'><a class='func-ref' href='#Fconsoleread'>consoleread</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, char *dst, int n)
{
  uint target;
  int c;

  <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip);
  target = n;
  <a class='func-ref' href='#Facquire'>acquire</a>(&<a class='str-ref' href='#Sinput'>input</a>.lock);
  <span class='reserved'>while</span>(n &gt; 0){
    <span class='reserved'>while</span>(<a class='str-ref' href='#Sinput'>input</a>.r == <a class='str-ref' href='#Sinput'>input</a>.w){
      <span class='reserved'>if</span>(<a class='str-ref' href='#Sproc'>proc</a>-&gt;killed){
        <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sinput'>input</a>.lock);
        <a class='func-ref' href='#Filock'>ilock</a>(ip);
        <span class='reserved'>return</span> -1;
      }
      <a class='func-ref' href='#Fsleep'>sleep</a>(&<a class='str-ref' href='#Sinput'>input</a>.r, &<a class='str-ref' href='#Sinput'>input</a>.lock);
    }
    c = <a class='str-ref' href='#Sinput'>input</a>.<a class='str-ref' href='#Sbuf'>buf</a>[<a class='str-ref' href='#Sinput'>input</a>.r++ % <a class='define-ref' href='#AINPUT_BUF'>INPUT_BUF</a>];
    <span class='reserved'>if</span>(c == <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>('D')){  <span class='comment'>// EOF</span>      <span class='reserved'>if</span>(n &lt; target){
        <span class='comment'>// Save ^D <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> next time, to make sure</span>        <span class='comment'>// caller gets a 0-byte result.</span>        <a class='str-ref' href='#Sinput'>input</a>.r--;
      }
      <span class='reserved'>break</span>;
    }
    *dst++ = c;
    --n;
    <span class='reserved'>if</span>(c == '\n')
      <span class='reserved'>break</span>;
  }
  <a class='func-ref' href='#Frelease'>release</a>(&<a class='str-ref' href='#Sinput'>input</a>.lock);
  <a class='func-ref' href='#Filock'>ilock</a>(ip);

  <span class='reserved'>return</span> target - n;
}

int
<a name='Fconsolewrite'><a class='func-ref' href='#Fconsolewrite'>consolewrite</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Sinode'>inode</a> *ip, char *<a class='str-ref' href='#Sbuf'>buf</a>, int n)
{
  int i;

  <a class='func-ref' href='#Fiunlock'>iunlock</a>(ip);
  <a class='func-ref' href='#Facquire'>acquire</a>(&cons.lock);
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; n; i++)
    <a class='func-ref' href='#Fconsputc'>consputc</a>(<a class='str-ref' href='#Sbuf'>buf</a>[i] & 0xff);
  <a class='func-ref' href='#Frelease'>release</a>(&cons.lock);
  <a class='func-ref' href='#Filock'>ilock</a>(ip);

  <span class='reserved'>return</span> n;
}

void
<a name='Fconsoleinit'><a class='func-ref' href='#Fconsoleinit'>consoleinit</a></a>(void)
{
  <a class='func-ref' href='#Finitlock'>initlock</a>(&cons.lock, "console");
  <a class='func-ref' href='#Finitlock'>initlock</a>(&<a class='str-ref' href='#Sinput'>input</a>.lock, "<a class='str-ref' href='#Sinput'>input</a>");

  <a class='str-ref' href='#Sdevsw'>devsw</a>[<a class='define-ref' href='#ACONSOLE'>CONSOLE</a>].write = <a class='func-ref' href='#Fconsolewrite'>consolewrite</a>;
  <a class='str-ref' href='#Sdevsw'>devsw</a>[<a class='define-ref' href='#ACONSOLE'>CONSOLE</a>].read = <a class='func-ref' href='#Fconsoleread'>consoleread</a>;
  cons.locking = 1;

  <a class='func-ref' href='#Fpicenable'>picenable</a>(<a class='define-ref' href='#AIRQ_KBD'>IRQ_KBD</a>);
  <a class='func-ref' href='#Fioapicenable'>ioapicenable</a>(<a class='define-ref' href='#AIRQ_KBD'>IRQ_KBD</a>, 0);
}




<hr/><a name='Itimer.c'>###### <a class='page-ref' href='#Itimer.c'>timer.c</a> ########</a>

<span class='comment'>// Intel 8253/8254/82C54 Programmable Interval Timer (PIT).</span><span class='comment'>// Only used on uniprocessors;</span><span class='comment'>// SMP machines use the local APIC timer.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"

<a name='AIO_TIMER1'></a><span class='hash'>#define</span> <a class='define-ref' href='#AIO_TIMER1'>IO_TIMER1</a>       0x040           <span class='comment'>// 8253 Timer #1</span>
<span class='comment'>// Frequency of all three count-down timers;</span><span class='comment'>// (<a class='define-ref' href='#ATIMER_FREQ'>TIMER_FREQ</a>/freq) is the appropriate count</span><span class='comment'>// to generate a frequency of freq Hz.</span>
<a name='ATIMER_FREQ'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATIMER_FREQ'>TIMER_FREQ</a>      1193182
<a name='ATIMER_DIV'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATIMER_DIV'>TIMER_DIV</a>(x)    ((<a class='define-ref' href='#ATIMER_FREQ'>TIMER_FREQ</a>+(x)/2)/(x))

<a name='ATIMER_MODE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATIMER_MODE'>TIMER_MODE</a>      (<a class='define-ref' href='#AIO_TIMER1'>IO_TIMER1</a> + 3) <span class='comment'>// timer mode port</span><a name='ATIMER_SEL0'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATIMER_SEL0'>TIMER_SEL0</a>      0x00    <span class='comment'>// select counter 0</span><a name='ATIMER_RATEGEN'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATIMER_RATEGEN'>TIMER_RATEGEN</a>   0x04    <span class='comment'>// mode 2, rate generator</span><a name='ATIMER_16BIT'></a><span class='hash'>#define</span> <a class='define-ref' href='#ATIMER_16BIT'>TIMER_16BIT</a>     0x30    <span class='comment'>// r/w counter 16 bits, LSB first</span>
void
<a name='Ftimerinit'><a class='func-ref' href='#Ftimerinit'>timerinit</a></a>(void)
{
  <span class='comment'>// Interrupt 100 times/sec.</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ATIMER_MODE'>TIMER_MODE</a>, <a class='define-ref' href='#ATIMER_SEL0'>TIMER_SEL0</a> | <a class='define-ref' href='#ATIMER_RATEGEN'>TIMER_RATEGEN</a> | <a class='define-ref' href='#ATIMER_16BIT'>TIMER_16BIT</a>);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_TIMER1'>IO_TIMER1</a>, <a class='define-ref' href='#ATIMER_DIV'>TIMER_DIV</a>(100) % 256);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#AIO_TIMER1'>IO_TIMER1</a>, <a class='define-ref' href='#ATIMER_DIV'>TIMER_DIV</a>(100) / 256);
  <a class='func-ref' href='#Fpicenable'>picenable</a>(<a class='define-ref' href='#AIRQ_TIMER'>IRQ_TIMER</a>);
}



<hr/><a name='Iuart.c'>###### <a class='page-ref' href='#Iuart.c'>uart.c</a> ########</a>

<span class='comment'>// Intel 8250 serial port (UART).</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Idefs.h'>defs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iparam.h'>param.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ispinlock.h'><a class='str-ref' href='#Sspinlock'>spinlock</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifs.h'>fs.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifile.h'><a class='str-ref' href='#Sfile'>file</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Iproc.h'><a class='str-ref' href='#Sproc'>proc</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"

<a name='ACOM1'></a><span class='hash'>#define</span> <a class='define-ref' href='#ACOM1'>COM1</a>    0x3f8

<span class='reserved'>static</span> int uart;    <span class='comment'>// is there a uart?</span>
void
<a name='Fuartinit'><a class='func-ref' href='#Fuartinit'>uartinit</a></a>(void)
{
  char *p;

  <span class='comment'>// Turn off the FIFO</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+2, 0);
  
  <span class='comment'>// 9600 baud, 8 data bits, 1 stop bit, parity off.</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+3, 0x80);    <span class='comment'>// Unlock divisor</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+0, 115200/9600);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+1, 0);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+3, 0x03);    <span class='comment'>// Lock divisor, 8 data bits.</span>  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+4, 0);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+1, 0x01);    <span class='comment'>// Enable receive interrupts.</span>
  <span class='comment'>// If status is 0xFF, no serial port.</span>  <span class='reserved'>if</span>(<a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+5) == 0xFF)
    <span class='reserved'>return</span>;
  uart = 1;

  <span class='comment'>// Acknowledge pre-existing interrupt conditions;</span>  <span class='comment'>// enable interrupts.</span>  <a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+2);
  <a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+0);
  <a class='func-ref' href='#Fpicenable'>picenable</a>(<a class='define-ref' href='#AIRQ_COM1'>IRQ_COM1</a>);
  <a class='func-ref' href='#Fioapicenable'>ioapicenable</a>(<a class='define-ref' href='#AIRQ_COM1'>IRQ_COM1</a>, 0);
  
  <span class='comment'>// Announce that we're here.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(p="xv6...\n"; *p; p++)
    <a class='func-ref' href='#Fuartputc'>uartputc</a>(*p);
}

void
<a name='Fuartputc'><a class='func-ref' href='#Fuartputc'>uartputc</a></a>(int c)
{
  int i;

  <span class='reserved'>if</span>(!uart)
    <span class='reserved'>return</span>;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i = 0; i &lt; 128 && !(<a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+5) & 0x20); i++)
    <a class='func-ref' href='#Fmicrodelay'>microdelay</a>(10);
  <a class='func-ref' href='#Foutb'>outb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+0, c);
}

<span class='reserved'>static</span> int
<a name='Fuartgetc'><a class='func-ref' href='#Fuartgetc'>uartgetc</a></a>(void)
{
  <span class='reserved'>if</span>(!uart)
    <span class='reserved'>return</span> -1;
  <span class='reserved'>if</span>(!(<a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+5) & 0x01))
    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> <a class='func-ref' href='#Finb'>inb</a>(<a class='define-ref' href='#ACOM1'>COM1</a>+0);
}

void
<a name='Fuartintr'><a class='func-ref' href='#Fuartintr'>uartintr</a></a>(void)
{
  <a class='func-ref' href='#Fconsoleintr'>consoleintr</a>(<a class='func-ref' href='#Fuartgetc'>uartgetc</a>);
}



<hr/><a name='Iinitcode.S'>###### <a class='page-ref' href='#Iinitcode.S'>initcode.S</a> ########</a>

# Initial process execs /<a class='func-ref' href='#Finit'>init</a>.

<span class='hash'>#include</span> "<a class='page-ref' href='#Isyscall.h'><a class='func-ref' href='#Fsyscall'>syscall</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"


# <a class='func-ref' href='#Fexec'>exec</a>(<a class='func-ref' href='#Finit'>init</a>, <a class='func-ref' href='#Fargv'>argv</a>)
.globl <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>
<a name='Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a></a>:
  pushl $<a class='func-ref' href='#Fargv'>argv</a>
  pushl $<a class='func-ref' href='#Finit'>init</a>
  pushl $0  <span class='comment'>// where caller pc would be</span>  movl $<a class='define-ref' href='#ASYS_exec'>SYS_exec</a>, %eax
  int $<a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>

# <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(;;) <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
<a name='Fexit'><a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a></a>:
  movl $<a class='define-ref' href='#ASYS_exit'>SYS_exit</a>, %eax
  int $<a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>
  jmp <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>

# char <a class='func-ref' href='#Finit'>init</a>[] = "/<a class='func-ref' href='#Finit'>init</a>\0";
<a name='Finit'><a class='func-ref' href='#Finit'>init</a></a>:
  .string "/<a class='func-ref' href='#Finit'>init</a>\0"

# char *<a class='func-ref' href='#Fargv'>argv</a>[] = { <a class='func-ref' href='#Finit'>init</a>, 0 };
.p2align 2
<a name='Fargv'><a class='func-ref' href='#Fargv'>argv</a></a>:
  .long <a class='func-ref' href='#Finit'>init</a>
  .long 0




<hr/><a name='Iusys.S'>###### <a class='page-ref' href='#Iusys.S'>usys.S</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Isyscall.h'><a class='func-ref' href='#Fsyscall'>syscall</a>.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Itraps.h'>traps.h</a>"

<a name='ASYSCALL'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(name) \
  .globl name; \
  name: \
    movl $SYS_ ## name, %eax; \
    int $<a class='define-ref' href='#AT_SYSCALL'>T_SYSCALL</a>; \
    ret

<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(<a class='func-ref' href='#Ffork'>fork</a>)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(<a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(<a class='func-ref' href='#Fwait'>wait</a>)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(<a class='str-ref' href='#Spipe'>pipe</a>)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(read)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(write)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(close)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(<a class='func-ref' href='#Fkill'>kill</a>)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(<a class='func-ref' href='#Fexec'>exec</a>)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(open)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(mknod)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(unlink)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(fstat)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(link)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(mkdir)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(chdir)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(dup)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(getpid)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(sbrk)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(<a class='func-ref' href='#Fsleep'>sleep</a>)
<a class='define-ref' href='#ASYSCALL'>SYSCALL</a>(uptime)



<hr/><a name='Iinit.c'>###### <a class='page-ref' href='#Iinit.c'><a class='func-ref' href='#Finit'>init</a>.c</a> ########</a>

<span class='comment'>// <a class='func-ref' href='#Finit'>init</a>: The initial user-level program</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Istat.h'><a class='str-ref' href='#Sstat'>stat</a>.h</a>"
<span class='hash'>#include</span> "user.h"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifcntl.h'>fcntl.h</a>"

char *<a class='func-ref' href='#Fargv'>argv</a>[] = { "sh", 0 };

int
<a name='Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a></a>(void)
{
  int pid, wpid;

  <span class='reserved'>if</span>(open("console", <a class='define-ref' href='#AO_RDWR'>O_RDWR</a>) &lt; 0){
    mknod("console", 1, 1);
    open("console", <a class='define-ref' href='#AO_RDWR'>O_RDWR</a>);
  }
  dup(0);  <span class='comment'>// stdout</span>  dup(0);  <span class='comment'>// stderr</span>
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(;;){
    printf(1, "<a class='func-ref' href='#Finit'>init</a>: starting sh\n");
    pid = <a class='func-ref' href='#Ffork'>fork</a>();
    <span class='reserved'>if</span>(pid &lt; 0){
      printf(1, "<a class='func-ref' href='#Finit'>init</a>: <a class='func-ref' href='#Ffork'>fork</a> failed\n");
      <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
    }
    <span class='reserved'>if</span>(pid == 0){
      <a class='func-ref' href='#Fexec'>exec</a>("sh", <a class='func-ref' href='#Fargv'>argv</a>);
      printf(1, "<a class='func-ref' href='#Finit'>init</a>: <a class='func-ref' href='#Fexec'>exec</a> sh failed\n");
      <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
    }
    <span class='reserved'>while</span>((wpid=<a class='func-ref' href='#Fwait'>wait</a>()) &gt;= 0 && wpid != pid)
      printf(1, "zombie!\n");
  }
}



<hr/><a name='Ish.c'>###### <a class='page-ref' href='#Ish.c'>sh.c</a> ########</a>

<span class='comment'>// Shell.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "user.h"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ifcntl.h'>fcntl.h</a>"

<span class='comment'>// Parsed command representation</span><a name='AEXEC'></a><span class='hash'>#define</span> <a class='define-ref' href='#AEXEC'>EXEC</a>  1
<a name='AREDIR'></a><span class='hash'>#define</span> <a class='define-ref' href='#AREDIR'>REDIR</a> 2
<a name='APIPE'></a><span class='hash'>#define</span> <a class='define-ref' href='#APIPE'>PIPE</a>  3
<a name='ALIST'></a><span class='hash'>#define</span> <a class='define-ref' href='#ALIST'>LIST</a>  4
<a name='ABACK'></a><span class='hash'>#define</span> <a class='define-ref' href='#ABACK'>BACK</a>  5

<a name='AMAXARGS'></a><span class='hash'>#define</span> <a class='define-ref' href='#AMAXARGS'>MAXARGS</a> 10

<a name='Scmd'></a><span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> {
  int type;
};

<span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a> {
  int type;
  char *<a class='func-ref' href='#Fargv'>argv</a>[<a class='define-ref' href='#AMAXARGS'>MAXARGS</a>];
  char *eargv[<a class='define-ref' href='#AMAXARGS'>MAXARGS</a>];
};

<span class='reserved'>struct</span> <a class='func-ref' href='#Fredircmd'>redircmd</a> {
  int type;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;
  char *<a class='str-ref' href='#Sfile'>file</a>;
  char *efile;
  int mode;
  int fd;
};

<span class='reserved'>struct</span> <a class='func-ref' href='#Fpipecmd'>pipecmd</a> {
  int type;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *left;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *right;
};

<span class='reserved'>struct</span> <a class='func-ref' href='#Flistcmd'>listcmd</a> {
  int type;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *left;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *right;
};

<span class='reserved'>struct</span> <a class='func-ref' href='#Fbackcmd'>backcmd</a> {
  int type;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;
};

int <a class='func-ref' href='#Ffork1'>fork1</a>(void);  <span class='comment'>// Fork but panics on failure.</span>void <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>(char*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='func-ref' href='#Fparsecmd'>parsecmd</a>(char*);

<span class='comment'>// Execute <a class='str-ref' href='#Scmd'>cmd</a>.  Never returns.</span>void
<a name='Fruncmd'><a class='func-ref' href='#Fruncmd'>runcmd</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>)
{
  int p[2];
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fbackcmd'>backcmd</a> *bcmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a> *ecmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Flistcmd'>listcmd</a> *lcmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fpipecmd'>pipecmd</a> *pcmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fredircmd'>redircmd</a> *rcmd;

  <span class='reserved'>if</span>(<a class='str-ref' href='#Scmd'>cmd</a> == 0)
    <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
  
  <span class='reserved'>switch</span>(<a class='str-ref' href='#Scmd'>cmd</a>-&gt;type){
  <span class='reserved'>default</span>:
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fruncmd'>runcmd</a>");

  <span class='reserved'>case</span> <a class='define-ref' href='#AEXEC'>EXEC</a>:
    ecmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <span class='reserved'>if</span>(ecmd-&gt;<a class='func-ref' href='#Fargv'>argv</a>[0] == 0)
      <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
    <a class='func-ref' href='#Fexec'>exec</a>(ecmd-&gt;<a class='func-ref' href='#Fargv'>argv</a>[0], ecmd-&gt;<a class='func-ref' href='#Fargv'>argv</a>);
    printf(2, "<a class='func-ref' href='#Fexec'>exec</a> %s failed\n", ecmd-&gt;<a class='func-ref' href='#Fargv'>argv</a>[0]);
    <span class='reserved'>break</span>;

  <span class='reserved'>case</span> <a class='define-ref' href='#AREDIR'>REDIR</a>:
    rcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fredircmd'>redircmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    close(rcmd-&gt;fd);
    <span class='reserved'>if</span>(open(rcmd-&gt;<a class='str-ref' href='#Sfile'>file</a>, rcmd-&gt;mode) &lt; 0){
      printf(2, "open %s failed\n", rcmd-&gt;<a class='str-ref' href='#Sfile'>file</a>);
      <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
    }
    <a class='func-ref' href='#Fruncmd'>runcmd</a>(rcmd-&gt;<a class='str-ref' href='#Scmd'>cmd</a>);
    <span class='reserved'>break</span>;

  <span class='reserved'>case</span> <a class='define-ref' href='#ALIST'>LIST</a>:
    lcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Flistcmd'>listcmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <span class='reserved'>if</span>(<a class='func-ref' href='#Ffork1'>fork1</a>() == 0)
      <a class='func-ref' href='#Fruncmd'>runcmd</a>(lcmd-&gt;left);
    <a class='func-ref' href='#Fwait'>wait</a>();
    <a class='func-ref' href='#Fruncmd'>runcmd</a>(lcmd-&gt;right);
    <span class='reserved'>break</span>;

  <span class='reserved'>case</span> <a class='define-ref' href='#APIPE'>PIPE</a>:
    pcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fpipecmd'>pipecmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <span class='reserved'>if</span>(<a class='str-ref' href='#Spipe'>pipe</a>(p) &lt; 0)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='str-ref' href='#Spipe'>pipe</a>");
    <span class='reserved'>if</span>(<a class='func-ref' href='#Ffork1'>fork1</a>() == 0){
      close(1);
      dup(p[1]);
      close(p[0]);
      close(p[1]);
      <a class='func-ref' href='#Fruncmd'>runcmd</a>(pcmd-&gt;left);
    }
    <span class='reserved'>if</span>(<a class='func-ref' href='#Ffork1'>fork1</a>() == 0){
      close(0);
      dup(p[0]);
      close(p[0]);
      close(p[1]);
      <a class='func-ref' href='#Fruncmd'>runcmd</a>(pcmd-&gt;right);
    }
    close(p[0]);
    close(p[1]);
    <a class='func-ref' href='#Fwait'>wait</a>();
    <a class='func-ref' href='#Fwait'>wait</a>();
    <span class='reserved'>break</span>;
    
  <span class='reserved'>case</span> <a class='define-ref' href='#ABACK'>BACK</a>:
    bcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fbackcmd'>backcmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <span class='reserved'>if</span>(<a class='func-ref' href='#Ffork1'>fork1</a>() == 0)
      <a class='func-ref' href='#Fruncmd'>runcmd</a>(bcmd-&gt;<a class='str-ref' href='#Scmd'>cmd</a>);
    <span class='reserved'>break</span>;
  }
  <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
}

int
<a name='Fgetcmd'><a class='func-ref' href='#Fgetcmd'>getcmd</a></a>(char *<a class='str-ref' href='#Sbuf'>buf</a>, int nbuf)
{
  printf(2, "$ ");
  <a class='func-ref' href='#Fmemset'>memset</a>(<a class='str-ref' href='#Sbuf'>buf</a>, 0, nbuf);
  gets(<a class='str-ref' href='#Sbuf'>buf</a>, nbuf);
  <span class='reserved'>if</span>(<a class='str-ref' href='#Sbuf'>buf</a>[0] == 0) <span class='comment'>// EOF</span>    <span class='reserved'>return</span> -1;
  <span class='reserved'>return</span> 0;
}

int
<a name='Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'><a class='func-ref' href='#Fmain'>main</a></a></a></a>(void)
{
  <span class='reserved'>static</span> char <a class='str-ref' href='#Sbuf'>buf</a>[100];
  int fd;
  
  <span class='comment'>// Assumes three <a class='str-ref' href='#Sfile'>file</a> descriptors open.</span>  <span class='reserved'>while</span>((fd = open("console", <a class='define-ref' href='#AO_RDWR'>O_RDWR</a>)) &gt;= 0){
    <span class='reserved'>if</span>(fd &gt;= 3){
      close(fd);
      <span class='reserved'>break</span>;
    }
  }
  
  <span class='comment'>// Read and <a class='str-ref' href='#Srun'>run</a> <a class='str-ref' href='#Sinput'>input</a> commands.</span>  <span class='reserved'>while</span>(<a class='func-ref' href='#Fgetcmd'>getcmd</a>(<a class='str-ref' href='#Sbuf'>buf</a>, sizeof(<a class='str-ref' href='#Sbuf'>buf</a>)) &gt;= 0){
    <span class='reserved'>if</span>(<a class='str-ref' href='#Sbuf'>buf</a>[0] == 'c' && <a class='str-ref' href='#Sbuf'>buf</a>[1] == 'd' && <a class='str-ref' href='#Sbuf'>buf</a>[2] == ' '){
      <span class='comment'>// Clumsy but will have to do <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> now.</span>      <span class='comment'>// Chdir has no effect on the parent <span class='reserved'>if</span> <a class='str-ref' href='#Srun'>run</a> in the child.</span>      <a class='str-ref' href='#Sbuf'>buf</a>[<a class='func-ref' href='#Fstrlen'>strlen</a>(<a class='str-ref' href='#Sbuf'>buf</a>)-1] = 0;  <span class='comment'>// chop \n</span>      <span class='reserved'>if</span>(chdir(<a class='str-ref' href='#Sbuf'>buf</a>+3) &lt; 0)
        printf(2, "cannot cd %s\n", <a class='str-ref' href='#Sbuf'>buf</a>+3);
      continue;
    }
    <span class='reserved'>if</span>(<a class='func-ref' href='#Ffork1'>fork1</a>() == 0)
      <a class='func-ref' href='#Fruncmd'>runcmd</a>(<a class='func-ref' href='#Fparsecmd'>parsecmd</a>(<a class='str-ref' href='#Sbuf'>buf</a>));
    <a class='func-ref' href='#Fwait'>wait</a>();
  }
  <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
}

void
<a name='Fpanic'><a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a></a>(char *s)
{
  printf(2, "%s\n", s);
  <a class='func-ref' href='#Fexit'><a class='func-ref' href='#Fexit'>exit</a></a>();
}

int
<a name='Ffork1'><a class='func-ref' href='#Ffork1'>fork1</a></a>(void)
{
  int pid;
  
  pid = <a class='func-ref' href='#Ffork'>fork</a>();
  <span class='reserved'>if</span>(pid == -1)
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Ffork'>fork</a>");
  <span class='reserved'>return</span> pid;
}

<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Constructors</span>
<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fexeccmd'><a class='func-ref' href='#Fexeccmd'>execcmd</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <a class='str-ref' href='#Scmd'>cmd</a> = malloc(sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='func-ref' href='#Fmemset'>memset</a>(<a class='str-ref' href='#Scmd'>cmd</a>, 0, sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;type = <a class='define-ref' href='#AEXEC'>EXEC</a>;
  <span class='reserved'>return</span> (<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fredircmd'><a class='func-ref' href='#Fredircmd'>redircmd</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *subcmd, char *<a class='str-ref' href='#Sfile'>file</a>, char *efile, int mode, int fd)
{
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fredircmd'>redircmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <a class='str-ref' href='#Scmd'>cmd</a> = malloc(sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='func-ref' href='#Fmemset'>memset</a>(<a class='str-ref' href='#Scmd'>cmd</a>, 0, sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;type = <a class='define-ref' href='#AREDIR'>REDIR</a>;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;<a class='str-ref' href='#Scmd'>cmd</a> = subcmd;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;<a class='str-ref' href='#Sfile'>file</a> = <a class='str-ref' href='#Sfile'>file</a>;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;efile = efile;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;mode = mode;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;fd = fd;
  <span class='reserved'>return</span> (<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fpipecmd'><a class='func-ref' href='#Fpipecmd'>pipecmd</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *left, <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *right)
{
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fpipecmd'>pipecmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <a class='str-ref' href='#Scmd'>cmd</a> = malloc(sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='func-ref' href='#Fmemset'>memset</a>(<a class='str-ref' href='#Scmd'>cmd</a>, 0, sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;type = <a class='define-ref' href='#APIPE'>PIPE</a>;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;left = left;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;right = right;
  <span class='reserved'>return</span> (<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Flistcmd'><a class='func-ref' href='#Flistcmd'>listcmd</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *left, <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *right)
{
  <span class='reserved'>struct</span> <a class='func-ref' href='#Flistcmd'>listcmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <a class='str-ref' href='#Scmd'>cmd</a> = malloc(sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='func-ref' href='#Fmemset'>memset</a>(<a class='str-ref' href='#Scmd'>cmd</a>, 0, sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;type = <a class='define-ref' href='#ALIST'>LIST</a>;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;left = left;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;right = right;
  <span class='reserved'>return</span> (<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fbackcmd'><a class='func-ref' href='#Fbackcmd'>backcmd</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *subcmd)
{
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fbackcmd'>backcmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <a class='str-ref' href='#Scmd'>cmd</a> = malloc(sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='func-ref' href='#Fmemset'>memset</a>(<a class='str-ref' href='#Scmd'>cmd</a>, 0, sizeof(*<a class='str-ref' href='#Scmd'>cmd</a>));
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;type = <a class='define-ref' href='#ABACK'>BACK</a>;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;<a class='str-ref' href='#Scmd'>cmd</a> = subcmd;
  <span class='reserved'>return</span> (<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
}
<span class='comment'>//PAGEBREAK!</span><span class='comment'>// Parsing</span>
char whitespace[] = " \t\r\n\v";
char symbols[] = "&lt;|&gt;&;()";

int
<a name='Fgettoken'><a class='func-ref' href='#Fgettoken'>gettoken</a></a>(char **ps, char *es, char **q, char **eq)
{
  char *s;
  int ret;
  
  s = *ps;
  <span class='reserved'>while</span>(s &lt; es && strchr(whitespace, *s))
    s++;
  <span class='reserved'>if</span>(q)
    *q = s;
  ret = *s;
  <span class='reserved'>switch</span>(*s){
  <span class='reserved'>case</span> 0:
    <span class='reserved'>break</span>;
  <span class='reserved'>case</span> '|':
  <span class='reserved'>case</span> '(':
  <span class='reserved'>case</span> ')':
  <span class='reserved'>case</span> ';':
  <span class='reserved'>case</span> '&':
  <span class='reserved'>case</span> '&lt;':
    s++;
    <span class='reserved'>break</span>;
  <span class='reserved'>case</span> '&gt;':
    s++;
    <span class='reserved'>if</span>(*s == '&gt;'){
      ret = '+';
      s++;
    }
    <span class='reserved'>break</span>;
  <span class='reserved'>default</span>:
    ret = 'a';
    <span class='reserved'>while</span>(s &lt; es && !strchr(whitespace, *s) && !strchr(symbols, *s))
      s++;
    <span class='reserved'>break</span>;
  }
  <span class='reserved'>if</span>(eq)
    *eq = s;
  
  <span class='reserved'>while</span>(s &lt; es && strchr(whitespace, *s))
    s++;
  *ps = s;
  <span class='reserved'>return</span> ret;
}

int
<a name='Fpeek'><a class='func-ref' href='#Fpeek'>peek</a></a>(char **ps, char *es, char *toks)
{
  char *s;
  
  s = *ps;
  <span class='reserved'>while</span>(s &lt; es && strchr(whitespace, *s))
    s++;
  *ps = s;
  <span class='reserved'>return</span> *s && strchr(toks, *s);
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='func-ref' href='#Fparseline'>parseline</a>(char**, char*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='func-ref' href='#Fparsepipe'>parsepipe</a>(char**, char*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='func-ref' href='#Fparseexec'>parseexec</a>(char**, char*);
<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='func-ref' href='#Fnulterminate'>nulterminate</a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*);

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fparsecmd'><a class='func-ref' href='#Fparsecmd'>parsecmd</a></a>(char *s)
{
  char *es;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  es = s + <a class='func-ref' href='#Fstrlen'>strlen</a>(s);
  <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fparseline'>parseline</a>(&s, es);
  <a class='func-ref' href='#Fpeek'>peek</a>(&s, es, "");
  <span class='reserved'>if</span>(s != es){
    printf(2, "leftovers: %s\n", s);
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("syntax");
  }
  <a class='func-ref' href='#Fnulterminate'>nulterminate</a>(<a class='str-ref' href='#Scmd'>cmd</a>);
  <span class='reserved'>return</span> <a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fparseline'><a class='func-ref' href='#Fparseline'>parseline</a></a>(char **ps, char *es)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fparsepipe'>parsepipe</a>(ps, es);
  <span class='reserved'>while</span>(<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, "&")){
    <a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, 0, 0);
    <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fbackcmd'>backcmd</a>(<a class='str-ref' href='#Scmd'>cmd</a>);
  }
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, ";")){
    <a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, 0, 0);
    <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Flistcmd'>listcmd</a>(<a class='str-ref' href='#Scmd'>cmd</a>, <a class='func-ref' href='#Fparseline'>parseline</a>(ps, es));
  }
  <span class='reserved'>return</span> <a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fparsepipe'><a class='func-ref' href='#Fparsepipe'>parsepipe</a></a>(char **ps, char *es)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fparseexec'>parseexec</a>(ps, es);
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, "|")){
    <a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, 0, 0);
    <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fpipecmd'>pipecmd</a>(<a class='str-ref' href='#Scmd'>cmd</a>, <a class='func-ref' href='#Fparsepipe'>parsepipe</a>(ps, es));
  }
  <span class='reserved'>return</span> <a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fparseredirs'><a class='func-ref' href='#Fparseredirs'>parseredirs</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>, char **ps, char *es)
{
  int tok;
  char *q, *eq;

  <span class='reserved'>while</span>(<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, "&lt;&gt;")){
    tok = <a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, 0, 0);
    <span class='reserved'>if</span>(<a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, &q, &eq) != 'a')
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("missing <a class='str-ref' href='#Sfile'>file</a> <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> redirection");
    <span class='reserved'>switch</span>(tok){
    <span class='reserved'>case</span> '&lt;':
      <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fredircmd'>redircmd</a>(<a class='str-ref' href='#Scmd'>cmd</a>, q, eq, <a class='define-ref' href='#AO_RDONLY'>O_RDONLY</a>, 0);
      <span class='reserved'>break</span>;
    <span class='reserved'>case</span> '&gt;':
      <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fredircmd'>redircmd</a>(<a class='str-ref' href='#Scmd'>cmd</a>, q, eq, <a class='define-ref' href='#AO_WRONLY'>O_WRONLY</a>|<a class='define-ref' href='#AO_CREATE'>O_CREATE</a>, 1);
      <span class='reserved'>break</span>;
    <span class='reserved'>case</span> '+':  <span class='comment'>// &gt;&gt;</span>      <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fredircmd'>redircmd</a>(<a class='str-ref' href='#Scmd'>cmd</a>, q, eq, <a class='define-ref' href='#AO_WRONLY'>O_WRONLY</a>|<a class='define-ref' href='#AO_CREATE'>O_CREATE</a>, 1);
      <span class='reserved'>break</span>;
    }
  }
  <span class='reserved'>return</span> <a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fparseblock'><a class='func-ref' href='#Fparseblock'>parseblock</a></a>(char **ps, char *es)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;

  <span class='reserved'>if</span>(!<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, "("))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("<a class='func-ref' href='#Fparseblock'>parseblock</a>");
  <a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, 0, 0);
  <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fparseline'>parseline</a>(ps, es);
  <span class='reserved'>if</span>(!<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, ")"))
    <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("syntax - missing )");
  <a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, 0, 0);
  <a class='str-ref' href='#Scmd'>cmd</a> = <a class='func-ref' href='#Fparseredirs'>parseredirs</a>(<a class='str-ref' href='#Scmd'>cmd</a>, ps, es);
  <span class='reserved'>return</span> <a class='str-ref' href='#Scmd'>cmd</a>;
}

<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fparseexec'><a class='func-ref' href='#Fparseexec'>parseexec</a></a>(char **ps, char *es)
{
  char *q, *eq;
  int tok, argc;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *ret;
  
  <span class='reserved'>if</span>(<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, "("))
    <span class='reserved'>return</span> <a class='func-ref' href='#Fparseblock'>parseblock</a>(ps, es);

  ret = <a class='func-ref' href='#Fexeccmd'>execcmd</a>();
  <a class='str-ref' href='#Scmd'>cmd</a> = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a>*)ret;

  argc = 0;
  ret = <a class='func-ref' href='#Fparseredirs'>parseredirs</a>(ret, ps, es);
  <span class='reserved'>while</span>(!<a class='func-ref' href='#Fpeek'>peek</a>(ps, es, "|)&;")){
    <span class='reserved'>if</span>((tok=<a class='func-ref' href='#Fgettoken'>gettoken</a>(ps, es, &q, &eq)) == 0)
      <span class='reserved'>break</span>;
    <span class='reserved'>if</span>(tok != 'a')
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("syntax");
    <a class='str-ref' href='#Scmd'>cmd</a>-&gt;<a class='func-ref' href='#Fargv'>argv</a>[argc] = q;
    <a class='str-ref' href='#Scmd'>cmd</a>-&gt;eargv[argc] = eq;
    argc++;
    <span class='reserved'>if</span>(argc &gt;= <a class='define-ref' href='#AMAXARGS'>MAXARGS</a>)
      <a class='func-ref' href='#Fpanic'><a class='func-ref' href='#Fpanic'>panic</a></a>("too many args");
    ret = <a class='func-ref' href='#Fparseredirs'>parseredirs</a>(ret, ps, es);
  }
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;<a class='func-ref' href='#Fargv'>argv</a>[argc] = 0;
  <a class='str-ref' href='#Scmd'>cmd</a>-&gt;eargv[argc] = 0;
  <span class='reserved'>return</span> ret;
}

<span class='comment'>// NUL-terminate all the counted strings.</span><span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a>*
<a name='Fnulterminate'><a class='func-ref' href='#Fnulterminate'>nulterminate</a></a>(<span class='reserved'>struct</span> <a class='str-ref' href='#Scmd'>cmd</a> *<a class='str-ref' href='#Scmd'>cmd</a>)
{
  int i;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fbackcmd'>backcmd</a> *bcmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a> *ecmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Flistcmd'>listcmd</a> *lcmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fpipecmd'>pipecmd</a> *pcmd;
  <span class='reserved'>struct</span> <a class='func-ref' href='#Fredircmd'>redircmd</a> *rcmd;

  <span class='reserved'>if</span>(<a class='str-ref' href='#Scmd'>cmd</a> == 0)
    <span class='reserved'>return</span> 0;
  
  <span class='reserved'>switch</span>(<a class='str-ref' href='#Scmd'>cmd</a>-&gt;type){
  <span class='reserved'>case</span> <a class='define-ref' href='#AEXEC'>EXEC</a>:
    ecmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fexeccmd'>execcmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(i=0; ecmd-&gt;<a class='func-ref' href='#Fargv'>argv</a>[i]; i++)
      *ecmd-&gt;eargv[i] = 0;
    <span class='reserved'>break</span>;

  <span class='reserved'>case</span> <a class='define-ref' href='#AREDIR'>REDIR</a>:
    rcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fredircmd'>redircmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <a class='func-ref' href='#Fnulterminate'>nulterminate</a>(rcmd-&gt;<a class='str-ref' href='#Scmd'>cmd</a>);
    *rcmd-&gt;efile = 0;
    <span class='reserved'>break</span>;

  <span class='reserved'>case</span> <a class='define-ref' href='#APIPE'>PIPE</a>:
    pcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fpipecmd'>pipecmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <a class='func-ref' href='#Fnulterminate'>nulterminate</a>(pcmd-&gt;left);
    <a class='func-ref' href='#Fnulterminate'>nulterminate</a>(pcmd-&gt;right);
    <span class='reserved'>break</span>;
    
  <span class='reserved'>case</span> <a class='define-ref' href='#ALIST'>LIST</a>:
    lcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Flistcmd'>listcmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <a class='func-ref' href='#Fnulterminate'>nulterminate</a>(lcmd-&gt;left);
    <a class='func-ref' href='#Fnulterminate'>nulterminate</a>(lcmd-&gt;right);
    <span class='reserved'>break</span>;

  <span class='reserved'>case</span> <a class='define-ref' href='#ABACK'>BACK</a>:
    bcmd = (<span class='reserved'>struct</span> <a class='func-ref' href='#Fbackcmd'>backcmd</a>*)<a class='str-ref' href='#Scmd'>cmd</a>;
    <a class='func-ref' href='#Fnulterminate'>nulterminate</a>(bcmd-&gt;<a class='str-ref' href='#Scmd'>cmd</a>);
    <span class='reserved'>break</span>;
  }
  <span class='reserved'>return</span> <a class='str-ref' href='#Scmd'>cmd</a>;
}



<hr/><a name='Ibootasm.S'>###### <a class='page-ref' href='#Ibootasm.S'>bootasm.S</a> ########</a>

<span class='hash'>#include</span> "<a class='page-ref' href='#Iasm.h'>asm.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Immu.h'>mmu.h</a>"

# Start the first CPU: <span class='reserved'>switch</span> to 32-bit protected mode, jump into <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.

.code16                       # Assemble <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> 16-bit mode
.globl <a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>
<a name='Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a></a>:
  <a class='func-ref' href='#Fcli'>cli</a>                         # BIOS enabled interrupts; disable

  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -&gt; Data Segment
  movw    %ax,%es             # -&gt; Extra Segment
  movw    %ax,%ss             # -&gt; Stack Segment

  # Physical address line A20 is tied to zero so that the first PCs 
  # with 2 MB would <a class='str-ref' href='#Srun'>run</a> software that assumed 1 MB.  Undo that.
seta20.1:
  <a class='func-ref' href='#Finb'>inb</a>     $0x64,%al               # Wait <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64
  <a class='func-ref' href='#Foutb'>outb</a>    %al,$0x64

seta20.2:
  <a class='func-ref' href='#Finb'>inb</a>     $0x64,%al               # Wait <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&gt; port 0x60
  <a class='func-ref' href='#Foutb'>outb</a>    %al,$0x60

  # Switch from real to protected mode.  Use a bootstrap GDT that makes
  # virtual addresses map directly to physical addresses so that the
  # effective memory map doesn't change during the transition.
  <a class='func-ref' href='#Flgdt'>lgdt</a>    <a class='func-ref' href='#Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'>gdtdesc</a></a>
  movl    %cr0, %eax
  orl     $<a class='define-ref' href='#ACR0_PE'>CR0_PE</a>, %eax
  movl    %eax, %cr0

<span class='comment'>//PAGEBREAK!</span>  # Complete transition to 32-bit protected mode by using long jmp
  # to reload %cs and %eip.  The segment descriptors are set up with no
  # translation, so that the mapping is still the identity mapping.
  ljmp    $(<a class='define-ref' href='#ASEG_KCODE'>SEG_KCODE</a>&lt;&lt;3), $<a class='func-ref' href='#Fstart32'><a class='func-ref' href='#Fstart32'>start32</a></a>

.code32  # Tell assembler to generate 32-bit code now.
<a name='Fstart32'><a class='func-ref' href='#Fstart32'><a class='func-ref' href='#Fstart32'>start32</a></a></a>:
  # Set up the protected-mode data segment registers
  movw    $(<a class='define-ref' href='#ASEG_KDATA'>SEG_KDATA</a>&lt;&lt;3), %ax    # Our data segment selector
  movw    %ax, %ds                # -&gt; DS: Data Segment
  movw    %ax, %es                # -&gt; ES: Extra Segment
  movw    %ax, %ss                # -&gt; SS: Stack Segment
  movw    $0, %ax                 # Zero segments not ready <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> use
  movw    %ax, %fs                # -&gt; FS
  movw    %ax, %gs                # -&gt; GS

  # Set up the stack pointer and call into <a class='define-ref' href='#AC'><a class='define-ref' href='#AC'>C</a></a>.
  movl    $<a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'><a class='func-ref' href='#Fstart'>start</a></a></a>, %esp
  call    <a class='func-ref' href='#Fbootmain'>bootmain</a>

  # If <a class='func-ref' href='#Fbootmain'>bootmain</a> returns (it shouldn't), trigger a Bochs
  # breakpoint <span class='reserved'>if</span> running under Bochs, then loop.
  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00
  movw    %ax, %dx
  <a class='func-ref' href='#Foutw'>outw</a>    %ax, %dx
  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00
  <a class='func-ref' href='#Foutw'>outw</a>    %ax, %dx
<a name='Fspin'><a class='func-ref' href='#Fspin'><a class='func-ref' href='#Fspin'>spin</a></a></a>:
  jmp     <a class='func-ref' href='#Fspin'><a class='func-ref' href='#Fspin'>spin</a></a>

# Bootstrap GDT
.p2align 2                                # force 4 byte alignment
<a name='Fgdt'><a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a></a>:
  <a class='define-ref' href='#ASEG_NULLASM'>SEG_NULLASM</a>                             # null seg
  <a class='define-ref' href='#ASEG_ASM'>SEG_ASM</a>(<a class='define-ref' href='#ASTA_X'><a class='define-ref' href='#ASTA_X'>STA_X</a></a>|<a class='define-ref' href='#ASTA_R'><a class='define-ref' href='#ASTA_R'>STA_R</a></a>, 0x0, 0xffffffff)   # code seg
  <a class='define-ref' href='#ASEG_ASM'>SEG_ASM</a>(<a class='define-ref' href='#ASTA_W'><a class='define-ref' href='#ASTA_W'>STA_W</a></a>, 0x0, 0xffffffff)         # data seg

<a name='Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'>gdtdesc</a></a></a>:
  .word   (<a class='func-ref' href='#Fgdtdesc'><a class='func-ref' href='#Fgdtdesc'>gdtdesc</a></a> - <a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a> - 1)             # sizeof(<a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>) - 1
  .long   <a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>                             # address <a class='func-ref' href='#Fgdt'><a class='func-ref' href='#Fgdt'>gdt</a></a>




<hr/><a name='Ibootmain.c'>###### <a class='page-ref' href='#Ibootmain.c'><a class='func-ref' href='#Fbootmain'>bootmain</a>.c</a> ########</a>

<span class='comment'>// Boot loader.</span><span class='comment'>// </span><span class='comment'>// Part of the boot sector, along with <a class='page-ref' href='#Ibootasm.S'>bootasm.S</a>, which calls <a class='func-ref' href='#Fbootmain'>bootmain</a>().</span><span class='comment'>// <a class='page-ref' href='#Ibootasm.S'>bootasm.S</a> has put the processor into protected 32-bit mode.</span><span class='comment'>// <a class='func-ref' href='#Fbootmain'>bootmain</a>() loads an ELF kernel image from the disk starting at</span><span class='comment'>// sector 1 and then jumps to the kernel <a class='func-ref' href='#Fentry'>entry</a> routine.</span>
<span class='hash'>#include</span> "<a class='page-ref' href='#Itypes.h'>types.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ielf.h'>elf.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Ix86.h'>x86.h</a>"
<span class='hash'>#include</span> "<a class='page-ref' href='#Imemlayout.h'>memlayout.h</a>"

<a name='ASECTSIZE'></a><span class='hash'>#define</span> <a class='define-ref' href='#ASECTSIZE'>SECTSIZE</a>  512

void <a class='func-ref' href='#Freadseg'>readseg</a>(uchar*, uint, uint);

void
<a name='Fbootmain'><a class='func-ref' href='#Fbootmain'>bootmain</a></a>(void)
{
  <span class='reserved'>struct</span> <a class='str-ref' href='#Selfhdr'>elfhdr</a> *elf;
  <span class='reserved'>struct</span> <a class='str-ref' href='#Sproghdr'>proghdr</a> *ph, *eph;
  void (*<a class='func-ref' href='#Fentry'>entry</a>)(void);
  uchar* pa;

  elf = (<span class='reserved'>struct</span> <a class='str-ref' href='#Selfhdr'>elfhdr</a>*)0x10000;  <span class='comment'>// scratch space</span>
  <span class='comment'>// Read 1st page off disk</span>  <a class='func-ref' href='#Freadseg'>readseg</a>((uchar*)elf, 4096, 0);

  <span class='comment'>// Is this an ELF executable?</span>  <span class='reserved'>if</span>(elf-&gt;<a class='define-ref' href='#Amagic'>magic</a> != <a class='define-ref' href='#AELF_MAGIC'>ELF_MAGIC</a>)
    <span class='reserved'>return</span>;  <span class='comment'>// let <a class='page-ref' href='#Ibootasm.S'>bootasm.S</a> handle error</span>
  <span class='comment'>// Load each program segment (ignores ph <a class='define-ref' href='#Aflags'>flags</a>).</span>  ph = (<span class='reserved'>struct</span> <a class='str-ref' href='#Sproghdr'>proghdr</a>*)((uchar*)elf + elf-&gt;phoff);
  eph = ph + elf-&gt;phnum;
  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(; ph &lt; eph; ph++){
    pa = (uchar*)ph-&gt;paddr;
    <a class='func-ref' href='#Freadseg'>readseg</a>(pa, ph-&gt;filesz, ph-&gt;off);
    <span class='reserved'>if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)
      <a class='func-ref' href='#Fstosb'>stosb</a>(pa + ph-&gt;filesz, 0, ph-&gt;memsz - ph-&gt;filesz);
  }

  <span class='comment'>// Call the <a class='func-ref' href='#Fentry'>entry</a> point from the ELF header.</span>  <span class='comment'>// Does not <span class='reserved'>return</span>!</span>  <a class='func-ref' href='#Fentry'>entry</a> = (void(*)(void))(elf-&gt;<a class='func-ref' href='#Fentry'>entry</a>);
  <a class='func-ref' href='#Fentry'>entry</a>();
}

void
<a name='Fwaitdisk'><a class='func-ref' href='#Fwaitdisk'>waitdisk</a></a>(void)
{
  <span class='comment'>// Wait <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a> disk ready.</span>  <span class='reserved'>while</span>((<a class='func-ref' href='#Finb'>inb</a>(0x1F7) & 0xC0) != 0x40)
    ;
}

<span class='comment'>// Read a single sector at offset into dst.</span>void
<a name='Freadsect'><a class='func-ref' href='#Freadsect'>readsect</a></a>(void *dst, uint offset)
{
  <span class='comment'>// Issue command.</span>  <a class='func-ref' href='#Fwaitdisk'>waitdisk</a>();
  <a class='func-ref' href='#Foutb'>outb</a>(0x1F2, 1);   <span class='comment'>// count = 1</span>  <a class='func-ref' href='#Foutb'>outb</a>(0x1F3, offset);
  <a class='func-ref' href='#Foutb'>outb</a>(0x1F4, offset &gt;&gt; 8);
  <a class='func-ref' href='#Foutb'>outb</a>(0x1F5, offset &gt;&gt; 16);
  <a class='func-ref' href='#Foutb'>outb</a>(0x1F6, (offset &gt;&gt; 24) | 0xE0);
  <a class='func-ref' href='#Foutb'>outb</a>(0x1F7, 0x20);  <span class='comment'>// <a class='str-ref' href='#Scmd'>cmd</a> 0x20 - read sectors</span>
  <span class='comment'>// Read data.</span>  <a class='func-ref' href='#Fwaitdisk'>waitdisk</a>();
  <a class='func-ref' href='#Finsl'>insl</a>(0x1F0, dst, <a class='define-ref' href='#ASECTSIZE'>SECTSIZE</a>/4);
}

<span class='comment'>// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.</span><span class='comment'>// Might copy more than asked.</span>void
<a name='Freadseg'><a class='func-ref' href='#Freadseg'>readseg</a></a>(uchar* pa, uint count, uint offset)
{
  uchar* epa;

  epa = pa + count;

  <span class='comment'>// Round down to sector boundary.</span>  pa -= offset % <a class='define-ref' href='#ASECTSIZE'>SECTSIZE</a>;

  <span class='comment'>// Translate from bytes to sectors; kernel starts at sector 1.</span>  offset = (offset / <a class='define-ref' href='#ASECTSIZE'>SECTSIZE</a>) + 1;

  <span class='comment'>// If this is too slow, we could read lots of sectors at a time.</span>  <span class='comment'>// We'd write more to memory than asked, but it doesn't matter --</span>  <span class='comment'>// we load in increasing order.</span>  <a class='func-ref' href='#Ffor'><a class='func-ref' href='#Ffor'><span class='reserved'>for</span></a></a>(; pa &lt; epa; pa += <a class='define-ref' href='#ASECTSIZE'>SECTSIZE</a>, offset++)
    <a class='func-ref' href='#Freadsect'>readsect</a>(pa, offset);
}

</div>
</body>
</html>